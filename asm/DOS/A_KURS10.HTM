<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: DOS, czê¶æ 10 - Inne jêzyki a asembler </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Prev"     hreflang="pl" lang="en" href="a_kurs09.htm">
<link rel="Next"     hreflang="pl" lang="en" href="a_kurs11.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, wstawki asemblerowe, C, Pascal
	Fortran, gcc">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Sun, Jul 10 2016 10:55:48 GMT">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler?<BR>
	<h1 class="nag">Czê¶æ 10 - Nie jeste¶my sami, czyli jak ³±czyæ asemblera
	 z innymi jêzykami</h1></div>

<P>
Jak wiemy, w asemblerze mo¿na napisaæ wszystko. Jednak nie zawsze wszystko trzeba pisaæ w
tym jêzyku. W tej czê¶ci poka¿ê, jak asemblera ³±czyæ z innymi jêzykami. S± na to 2 sposoby:</P>
<UL>
 <LI>Wstawki asemblerowe wpisywane bezpo¶rednio w kod programu</LI>
 <LI>Osobne modu³y asemblerowe do³±czane potem do modu³ów napisanych w innych jêzykach</LI>
</UL>
<P>Postaram siê z grubsza omówiæ te dwa sposoby na przyk³adzie jêzyków
 <span lang="en">Pascal</span>, C i Fortran 77.
Uprzedzam jednak, ¿e moja znajomo¶æ jêzyka <span lang="en">Pascal</span> i narzêdzi
 zwi±zanych z tym jêzykiem jest s³aba.</P>





<HR>
<h2 class="nag" lang="en">Pascal</h2>

	<BR><a href="#c" tabindex="1" class="bezdruk">(przeskocz <span lang="en">Pascal</span>a)</a>

<P>Wstawki asemblerowe realizuje siê u¿ywaj±c s³owa <q>asm</q>. Oto przyk³ad:</P>
<PRE title="wstawka asemblerowa w Pascalu" lang="en">
	{ DOS/Windows }

	program pas1;

	begin
 		asm mov eax,4
 	end;
	end.</PRE>

<P>Mo¿na te¿ stosowaæ nieco inny sposób - deklarowanie zmiennej reprezentuj±cej rejestry procesora.
Poni¿szy wycinek kodu prezentuje to w³a¶nie podej¶cie (wywo³uje przerwanie 13h z AH=48h, DL=80h,
 DS:DX wskazuj±cymi na obiekt a):</P>
<PRE title="Pascal a rejestry" lang="en">
	uses crt,dos;

	Var
	   regs: Registers;

	BEGIN
   		clrscr();
   		With regs DO
     		Begin
       		  Ah:=$48;
       		  DL:=$80;
       		  DS:=seg(a);
       		  DX:=ofs(a);
     		End;

		Intr($13,regs);</PRE>

<P>Teraz zajmiemy siê bardziej skomplikowan± spraw± - ³±czenie modu³ów napisanych w
 <span lang="en">Pascal</span>u i
asemblerze. <span lang="en">Pascal</span> dekoruje nazwy zmiennych i procedur, dorabiaj±c
znak podkre¶lenia z przodu. Jakby tego
by³o ma³o, do nazwy procedury dopisywana jest informacja o jej parametrach. Tak wiêc z kodu</P>
<PRE>
	var
 	 c:integer;
 	 d:char;

	procedure aaa(a:integer;b:char);</PRE>

<P>otrzymujemy symbole: _C, _D oraz _AAA$INTEGER$CHAR.</P>

<P>Oprócz tego, zwykle w <span lang="en">Pascal</span>u
 argumenty na stos sz³y od lewej do prawej, ale z tego co widzê
teraz, to <span lang="en">Free Pascal Compiler</span> dzia³a odwrotnie
 - argumenty id± na stos wspak. W naszym
przyk³adzie najpierw na stos pójdzie zmienna typu <q lang="en">char</q>, a potem typu
 <q lang="en">integer</q> (obie
rozszerzone do rozmiaru DWORDa).</P>
<P>
Jedno jest pewne: je¿eli Twoja procedura jest uruchamiana z programu napisanego w
 <span lang="en">Pascal</span>u, to
Ty <q>sprz±tasz po sobie</q> stos - nale¿y przy wyj¶ciu z procedury wykonaæ
 &nbsp;<code>RET liczba</code>, gdzie
liczba to rozmiar wszystkich parametrów w³o¿onych na stos (wszystkie parametry s± rozmiaru co
najmniej DWORD).<BR>
Je¶li to Ty uruchamiasz procedury napisane w <span lang="en">Pascal</span>u, to nie musisz
 siê martwiæ o zdejmowanie parametrów ze stosu.</P>

<P>Samo do³±czanie modu³ów odbywa siê na linii poleceñ, najlepiej w tym celu u¿yæ linkera
(po uprzednim skompilowaniu innych modu³ów na pliki obiektowe).</P>








<BR>
<HR>
<h2 class="nag"><a name="c" id="c">C i C++</a></h2>
	<BR><a href="#fortran" class="bezdruk">(przeskocz C i C++)</a>

<P>
Wstawki asemblerowe zaczynaj± siê wyra¿eniem <q>asm {</q> a koñcz± klamr± zamykaj±c± <q>}</q>
 (ale <em class="wazne">NIE</em> w gcc, o tym pó¼niej). Przyk³ad:</P>
<PRE title="wstawka asemblerowa w C">
	asm {
		mov eax, 1
	}</PRE>

<P>Wszystkie nowe kompilatory produkuj± programy 32- lub 64-bitowe, przypominam wiêc, aby we wstawkach
 <em class="wazne">NIE</em> u¿ywaæ przerwañ (
 <acronym lang="en" title="Disk Operating System">DOS</acronym>-a i
 <acronym lang="en" title="Basic Input/Output System">BIOS</acronym>-u w <span lang="en">Windows</span>).
</P>
<P>
W C i C++ mo¿na, podobnie jak w <span lang="en">Pascal</span>u, deklarowaæ zmienne
reprezentuj±ce rejestry procesora. Plik nag³ówkowy BIOS.H oferuje nam kilka mo¿liwo¶ci. Oto przyk³ad:</P>
<PRE title="C a rejestry">
	#include &lt;bios.h&gt;
	...

	REGS rejestry;
	...
		rejestry.x.ax = 0x13;
		rejestry.h.bl = 0xFF;
		int86 (0x10, rejestry, rejestry);</PRE>

<P>£±czenie modu³ów jest prostsze ni¿ w <span lang="en">Pascal</span>u. Jêzyk C dekoruje nazwy, dodaj±c
 znak podkre¶lenia  z przodu.<BR>
<em class="wazne">UWAGA</em> - w jêzyku C++ sprawy s± trudniejsze nawet ni¿ w
 <span lang="en">Pascal</span>u. Dlatego, je¶li chcemy, aby
nazwa naszej funkcji by³a niezmieniona (poza tym, ¿e ewentualnie dodamy podkre¶lenie z przodu)
i jednocze¶nie dzia³a³a w C++, zawsze przy deklaracji funkcji w pliku nag³ówkowym, nale¿y dodaæ
&nbsp;<CODE>extern &quot;C&quot;</CODE>, na przyk³ad</P>

<PRE title="opakowanie funkcji dla C++">
	#ifdef __cplusplus
	extern &quot;C&quot; {
	#endif

	extern void _naszafunkcja (int parametr, char* a);

	#ifdef  __cplusplus
	}
	#endif</PRE>

<P>W systemach 32-bitowych parametry przekazywane s± na stosie
<em class="wazne">OD PRAWEJ DO LEWEJ</em>,
czyli pierwszy parametr (u nas powy¿ej: int)
bêdzie w³o¿ony na stos jako ostatni, czyli bêdzie <q>najp³ycej</q>, a ostatni (u nas:
 <span lang="en">char</span>*)
bêdzie <q>najg³êbiej</q>.</P>

<P>W systemach 64-bitowych sprawa wygl±da trudniej: parametry, w zale¿no¶ci od klasy, s± przekazywane
(tak¿e od prawej do lewej):</P>
<ul>
<li>na stosie, je¶li ich rozmiar przekracza 8 bajtów lub zawiera pola niewyrównane co do adresu</li>
<li>kolejno w rejestrach RDI, RSI, RDX, RCX, R8, R9, je¶li jest klasy ca³kowitej (mie¶ci siê w
 rejestrze ogólnego przeznaczenia)</li>
<li>kolejno w rejestrach XMM0 ... XMM7 lub ich górnych czê¶ciach, je¶li jest klasy SSE lub
 SSEUP, odpowiednio</li>
<li>w obszarze pamiêci, je¶li jest klasy zmiennoprzecinkowej lub zespolonej</li>
</ul>

<P>W C/C++ to funkcja <em class="wazne">uruchamiaj±ca</em> zdejmuje w³o¿one parametry ze stosu,
 a <em class="wazne">NIE</em> funkcja uruchamiana.</P>
<P>
Na systemach 32-bitowych parametry ca³kowitoliczbowe do 32 bitów zwracane
s± w rejestrze EAX (lub jego czê¶ciach: AL, AX, w zale¿no¶ci od rozmiaru), 64-bitowe w EDX:EAX,
 zmiennoprzecinkowe w ST0. Wska¼niki
 w 32-bitowych kompilatorach s± 32-bitowe i s± zwracane w EAX (w 16-bitowych zapewne w AX).<br>
Struktury s± wk³adane na stos od ostatnich pól, a je¶li funkcja zwraca strukturê przez warto¶æ, na przyk³ad<br>
<code>struct xxx f ( struct xxx a )</code><br>
to tak naprawdê jest traktowana jak taka funkcja:<br>
<code>void f ( struct xxx *tu_bedzie_wynik, struct xxx a )</code><br>
czyli jako ostatni na stos wk³adany jest adres struktury, do której ta funkcja ma w³o¿yæ
 strukturê wynikow±.
</P>
<P>
Na systemach 64-bitowych sprawa ponownie wygl±da inaczej. Tu tak¿e klasyfikuje siê
typ zwracanych danych, które s± wtedy przekazywane:</P>
<ul>
<li>w pamiêci, której adres przekazano w RDI (tak, jakby by³ to pierwszy parametr) - tak
 na przyk³ad mo¿na zwracaæ struktury. Po powrocie, RAX bêdzie zawiera³ przekazany adres</li>
<li>w kolejnym wolnym rejestrze z grupy RAX, RDX, je¶li klasa jest ca³kowita</li>
<li>w kolejnym wolnym rejestrze z grupy XMM0, XMM1, je¶li klasa to SSE</li>
<li>w górnej czê¶ci ostatniego u¿ywanego rejestru SSE, je¶li klasa to SSEUP</li>
<li>w ST0, je¶li klasa jest zmiennoprzecinkowa</li>
<li>razem z poprzedni± warto¶ci± w ST0, je¶li klasa to X87UP</li>
<li>czê¶æ rzeczywista w ST0, a czê¶æ urojona w ST1, je¶li klasa jest zespolona</li>
</ul>
<P>Polecam do przeczytania x64 <acronym lang="en" title="Application Binary Interface"
>ABI</acronym> (na przyk³ad dokument x64-abi.pdf, do znalezienia w Internecie).</P>

<P>
Do³±czanie modu³ów (te napisane w asemblerze musz± byæ uprzednio skompilowane)
odbywa siê na linii poleceñ, z tym ¿e tym razem mo¿emy u¿yæ samego
kompilatora, aby wykona³ za nas ³±czenie (nie musimy uruchamiaæ linkera).
</P>
<P>
No to krótki 32-bitowy przyk³adzik (u¿yjê NASMa i <span lang="en">Borland C++ Builder</span>):</P>

<PRE title="przyk³ad asm+C">
	; NASM casm1.asm

	section .text use32

	global	_suma

	_suma:
	; po wykonaniu push ebp i mov ebp, esp:
	; w [ebp]    znajduje siê stary EBP
	; w [ebp+4]  znajduje siê adres powrotny z procedury
	; w [ebp+8]  znajduje siê pierwszy parametr,
	; w [ebp+12] znajduje siê drugi parametr
	; itd.

	%idefine	a	[ebp+8]
	%idefine	b	[ebp+12]

		push	ebp
		mov	ebp, esp

		mov	eax, a
		add	eax, b

	; LEAVE = mov esp, ebp / pop ebp
		leave
		ret</PRE>

<P>oraz plik casm.c:</P>
<PRE>
	#include &lt;stdio.h&gt;

	extern int _suma (int a, int b); /* deklaracja funkcji zewnêtrznej */

	int suma (int a, int b);	 /* prototyp funkcji */

	int c=1, d=2;

	int main()
	{
		printf(&quot;%d\n&quot;, suma(c,d));
		return 0;
	}</PRE>

<P>Kompilacja odbywa siê tak:</P>
<PRE>
	nasm -o casm1.obj -f obj casm1.asm
	bcc32 casm.c casm1.obj</PRE>

<P>Uwaga: w kompilatorach GNU: DJGPP, Dev-C++, MinGW, CygWin format wyj¶ciowy NASMa powinien byæ
 ustawiony na COFF. Mo¿liwe, ¿e format COFF trzeba bêdzie wybraæ tak¿e w innych.</P>

<P>W wyniku otrzymujemy programik, który na ekranie elegancko wy¶wietla wynik równy 3.</P>

<P>Mo¿e siê zdarzyæ te¿, ¿e chcemy tylko korzystaæ z funkcji jêzyka C, ale g³ówn± czê¶æ
 programu chcemy napisaæ w asemblerze. Nic trudnego: u¿ywane funkcje deklarujemy jako
 zewnêtrzne (pamiêtaj±c o znaku podkre¶lenia), ale
 <em class="wazne">uwaga - swoj± funkcjê g³ówn± musimy nazwaæ <q lang="en">_main</q></em>.
 Jest tak dlatego, ¿e teraz punkt startu programu nie jest w naszym kodzie, lecz w
 samej bibliotece jêzyka C. Program zaczyna siê miêdzy innymi ustawieniem tablic
 argumentów listy poleceñ i zmiennych ¶rodowiska. Dopiero po tych operacjach biblioteka
 C uruchamia funkcjê <q lang="en">_main</q> instrukcj± <span lang="en">CALL</span>.<br>
Inn± wa¿n± spraw± jest to, ¿e nasz± funkcjê g³ówn± powinni¶my zakoñczyæ instrukcj± RET
 (zamiast normalnych instrukcji wyj¶cia z programu), która
 pozwoli przekazaæ kontrolê z powrotem do biblioteki C, umo¿liwiaj±c posprz±tanie
 (na przyk³ad wyrzucenie buforów z wy¶wietlonymi informacjami w koñcu na ekran).<br>
Krótki (tak¿e 32-bitowy) przyk³adzik:
</P>
<pre>
	section .text

	global _main

	extern _printf

	_main:

		; printf("Liczba jeden to: %d\n", 1);
		push	dword 1		; drugi argument
		push	dword napis	; pierwszy argument
		call	_printf		; uruchomienie funkcji
		add	esp, 2*4	; posprz±tanie stosu

		; return 0;
		xor	eax, eax
		ret			; wyj¶cie z programu

	section .data

	napis: db "Liczba jeden to: %d", 10, 0</pre>

<P>Kompilacja powinna odbyæ siê tak:
<PRE>
	nasm -o casm2.obj -f obj casm2.asm
	bcc32 casm2.obj</PRE>

<P>Jedna uwaga: funkcje biblioteki C mog± zamazaæ nam zawarto¶æ wszystkich rejestrów
 (poza EBX, EBP, ESI, EDI w systemach 32-bitowych, i RBX, RBP, R12, R13, R14, R15 na
 systemach 64-bitowych), wiêc <em class="wazne">nie wolno nam polegaæ na zawarto¶ci rejestrów</em>
 po uruchomieniu jakiejkolwiek funkcji C.</P>


<P>
Kompilator GNU gcc wymaga osobnego wyt³umaczenia. Sk³adnia wstawek asemblerowych ró¿ni
 siê od powy¿szej do¶æ znacznie, a jej opisy mo¿ecie znale¼æ
 <a hreflang="en" href="http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/">w podrêczniku GCC</a>
(sekcje: 5.34 i 5.35),
<A HREF="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" hreflang="en"
	>na stronach DJGPP</A> oraz (w jêzyku polskim) na
<A HREF="http://www.cs.put.poznan.pl/adanilecki/inline_asm/index.php" hreflang="pl"
	>stronie pana Danileckiego</A>.</P>
<P>
Jak zauwa¿ycie, ró¿ni siê nawet sam wygl±d instrukcji, gdy¿ domy¶lnie gcc u¿ywa
 sk³adni <span lang="en">AT&amp;T</span> jêzyka asembler. U siebie mam
 <A HREF="../linux/attintel.html" hreflang="pl">krótkie porównanie</A> tych sk³adni.</P>





<BR>
<HR>
<h2 class="nag"><a name="fortran" id="fortran">Fortran 77</a></h2>

<P>
W tym jêzyku nie wiem nic o wstawkach asemblerowych, wiêc przejdziemy od razu do ³±czenia
modu³ów.</P>
<P>
Fortran dekoruje nazwy, stawiaj±c znak podkre¶lenia <em class="wazne">PO</em>
 nazwie funkcji lub zmiennej (wyj±tkiem jest funkcja
g³ówna - blok PROGRAM - która nazywa siê <CODE>MAIN__</CODE>, z dwoma podkre¶leniami).
</P>
<P>
Nie musimy pisaæ externów, ale jest kilka regu³ przekazywania parametrów:</P>
<UL>
 <LI>parametry przekazywane s± od prawej do lewej, czyli tak jak w C.</LI>
 <LI>je¶li to jest tylko mo¿liwe, wszystkie parametry przekazywane s± przez referencjê, czyli
	przez wska¼nik. Gdy to jest niemo¿liwe, przekazywane s± przez warto¶æ.</LI>
 <LI>je¶li na li¶cie parametrów pojawia siê ³añcuch znakowy (lub inna tablica), to na stosie przed innymi
	parametrami umieszczana jest jego d³ugo¶æ (lub wymiary podawane wspak -
	od ostatniego do pierwszego - w przypadku tablic wielowymiarowych).</LI>
 <LI>wyniki s± zwracane w tych samych miejscach, co w jêzyku C.</LI>
</UL>
<P>Na przyk³ad, nastêpuj±cy kod:</P>
<PRE title="przyk³adowy kod Fortrana">
        REAL FUNCTION aaa (a, b, c, i)

                CHARACTER a*(*)
                CHARACTER b*(*)
                REAL c
                INTEGER i

                aaa = c
        END

[...]
                CHARACTER x*8
                CHARACTER y*5
                REAL z,t
                INTEGER u

                t=aaa (x, y, z, u)
[...]</PRE>

<P>bêdzie przet³umaczony na asemblera tak (samo uruchomienie funkcji):</P>
<PRE title="powy¿szy kod w asemblerze">
	push	5
	push	8
	push	u_	; adres, czyli offset zmiennej &quot;u&quot;
	push	z_
	push	y_
	push	x_

	call	aaa_</PRE>

<P>(to niekoniecznie musi wygl±daæ tak ³adnie, gdy¿ zmienne <q>x</q>, <q>y</q>, <q>u</q> i <q>z</q>
 s± lokalne w funkcji MAIN__, czyli s± na stosie, wiêc ich adresy mog± wygl±daæ jak
 [ebp-28h] lub podobnie).</P>
<P>
Funkcja uruchamiaj±ca sprz±ta stos po uruchomieniu (podobnie jak w C).</P>
<P>
Do³±czaæ modu³y mo¿na bezpo¶rednio z linii poleceñ (w ka¿dym razie pod Linuksem z
kompilatorem F77/G77).</P>
<P>
Podam teraz przyk³ad ³±czenia Fortrana 77 i asemblera. W oryginale u¿y³em narzêdzi Linuksowych:
NASMa i F77, ale po minimalnych przeróbkach powinno to te¿ dzia³aæ pod <span lang="en">Windows</span>.
 Oto pliki:</P>
<PRE title="kod assmelbera wykorzystany w Fortranie">
	; NASM - asm1fl.asm
	section .text use32
	global	suma_

	suma_:

	; po wykonaniu push ebp i mov ebp, esp:
	; w [ebp]    znajduje siê stary EBP
	; w [ebp+4]  znajduje siê adres powrotny z procedury
	; w [ebp+8]  znajduje siê pierwszy parametr,
	; w [ebp+12] znajduje siê drugi parametr
	; itd.

	%idefine	a	[ebp+8]
	%idefine	b	[ebp+12]

		push	ebp
		mov	ebp, esp

	; przypominam, ¿e nasze parametry s± w rzeczywisto¶ci
	; wska¼nikami do prawdziwych parametrów

		mov	edx, a		; EDX = adres pierwszego parametru
		mov	eax, [edx]	; EAX = pierwszy parametr
		mov	edx, b
		add	eax, [edx]

		leave
		ret</PRE>

<P>I teraz plik asmfl.f:</P>
<PRE title="kod Fortrana korzystaj±cy z powy¿szego">
	PROGRAM funkcja_zewnetrzna

	INTEGER a,b,suma

	a=1
	b=2

	WRITE (*,*) suma(a,b)

	END</PRE>

<P>Po skompilowaniu (ewentualnie zmieniaj±c opcjê <q>-f</q> u NASMa):</P>
<PRE>
	nasm -f obj -o asm1fl.obj asm1fl.asm
	f77 -o asmfl.exe asmfl.f asm1fl.obj</PRE>
<P>i uruchomieniu na ekranie powinna ponownie pojawiæ siê cyfra 3.</P>






<HR>
<P class="b">
Informacji podanych w tym dokumencie <em class="wazne">NIE</em>
 nale¿y traktowaæ jako <q>uniwersalnych, jedynie
s³usznych regu³ dzia³aj±cych w ka¿dej sytuacji</q>. Aby uzyskaæ kompletne informacje, nale¿y
zapoznaæ siê z dokumentacj± posiadanego kompilatora.
</P>

<br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="a_kurs09.htm">Poprzednia czê¶æ kursu</a> (Alt+3)<BR>
<a accesskey="4" hreflang="pl" href="a_kurs11.htm">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>


<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Napisz plik asemblera, zawieraj±cy funkcjê obliczania reszty z dzielenia dwóch liczb
	ca³kowitych. Nastêpnie, po³±cz ten plik z programem napisanym w dowolnym innym jêzyku
	(najlepiej w C/C++, gdy¿ jest najpopularniejszy) w taki sposób, by Twoj± funkcjê mo¿na
	by³o uruchamiaæ z tamtego programu. Je¶li planujesz ³±czyæ asemblera z C, upewnij siê
	¿e Twoja funkcja dzia³a równie¿ z programami napisanymi w C++.</LI>
</OL>

</BODY></HTML>
