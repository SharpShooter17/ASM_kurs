<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: DOS, czê¶æ 4 - Pierwsze programy </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Prev"     hreflang="pl" lang="en" href="a_kurs03.htm">
<link rel="Next"     hreflang="pl" lang="en" href="a_kurs05.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, flagi, _pisz_ch, ile_pier">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Sun, Jul 10 2016 10:55:47 GMT">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler?<BR>
	<h1 class="nag">Czê¶æ 4 - Pierwsze programy, czyli prze³amywanie pierwszych lodów</h1></div>

<P>
Znamy ju¿ rejestry, trochê instrukcji i zasad. No ale teoria jest niczym bez praktyki. Dlatego
w tej czê¶ci przedstawiê kilka wzglêdnie prostych programów, które powinny rozbudziæ wyobra¼niê
tworzenia.
</P>
<P>Ten program spyta siê u¿ytkownika o imiê i przywita siê z nim:</P>
	<BR><a href="#a_kurs0400_1" tabindex="1" class="bezdruk">(przeskocz program pytaj±cy o imiê)</a>
<PRE title="Program witaj±cy siê z u¿ytkownikiem po imieniu">
	; Program witaj±cy siê z u¿ytkownikiem po imieniu
	;
	; Autor: Bogdan D.
	; kontakt: bogdandr (at) op (dot) pl
	;
	; kompilacja:
	; nasm -f bin -o czesc.com czesc.asm
	;
	; kompilacja FASM:
	; fasm czesc.asm czesc.com

	org 100h

		mov	ah, 9		; funkcja wy¶wietlania na ekran
		mov	dx, jak_masz	; co wy¶wietliæ
		int	21h		; wy¶wietl

		mov	ah, 0ah	; funkcja pobierania danych z klawiatury
		mov	dx, imie	; bufor na dane
		int	21h		; pobierz dane

		mov	ah, 9
		mov	dx, czesc
		int	21h		; wy¶wietl napis &quot;Cze¶æ&quot;

		mov	ah, 9
		mov	dx, imie+2	; adres wpisanych danych
		int	21h		; wy¶wietl wpisane dane

		mov	ax, 4c00h
		int	21h

	jak_masz	db	&quot;Jak masz na imie? $&quot;
	imie	db 20		; maksymalna liczba znaków do pobrania
		db 0		; tu dostaniemy, ile znaków pobrano
		times 22 db &quot;$&quot;	; miejsce na dane

	czesc		db	10, 13, 10, 13, &quot;Czesc $&quot;</pre>

<P><a name="a_kurs0400_1" id="a_kurs0400_1">Powy¿szy program</a> korzysta z jeszcze nieomówionej
 funkcji numer 10 (0Ah) przerwania DOSa. Oto jej opis z listy przerwañ
 Ralfa <span lang="en">Brown</span>'a -
<A HREF="http://www-2.cs.cmu.edu/afs/cs.cmu.edu/user/ralf/pub/WWW/files.html" hreflang="en"
	><acronym title="Ralf Brown's Interrupt List" lang="en">RBIL</acronym></A>:</P>

	<BR><a href="#a_kurs0400_2" class="bezdruk">(przeskocz opis int 21h, ah=0ah)</a>
<PRE lang="en" title="int 21h, ah=0ah">
	INT 21 - DOS 1+ - BUFFERED INPUT
		AH = 0Ah
		DS:DX -> buffer (see #01344)
	Return: buffer filled with user input

	Format of DOS input buffer:
	Offset	Size	Description	(Table 01344)
	 00h	BYTE	maximum characters buffer can hold
	 01h	BYTE	(call) number of chars from last input which
	 			may be recalled
			(ret) number of characters actually read,
				excluding CR
	 02h  N BYTEs	actual characters read, including the
	 			final carriage return</pre>

<P><a name="a_kurs0400_2" id="a_kurs0400_2">Jak widaæ, korzystanie z niej nie jest trudne.</a>
 Wystarczy stworzyæ tablicê bajtów na znaki
 czytane z klawiatury. Na pocz±tku tablicy podajemy, ile maksymalnie znaków chcemy wczytaæ.
 Drugi bajt ustawiamy na zero, by czytaæ tylko na bie¿±co wprowadzane znaki, a nie to, co
 jeszcze mo¿e tkwiæ w DOS-owym buforze wej¶ciowym.</P>
<hr>
<P>
Kolejny program wypisuje na ekranie rejestr flag w postaci dwójkowej. Zanim mu siê
przyjrzymy, potrzebna bêdzie nam informacja o funkcji 0Eh przerwania 10h (opis bierzemy
oczywi¶cie z RBIL):</P>

	<BR><a href="#a_kurs0400" class="bezdruk">(przeskocz opis int 10h, ah=0eh)</a>
<PRE lang="en" title="int 10h, ah=0eh">
	INT 10 - VIDEO - TELETYPE OUTPUT
	        AH = 0Eh
	        AL = character to write
	        BH = page number
	        BL = foreground color (graphics modes only)
	Return: nothing
	Desc:   display a character on the screen, advancing the
		 cursor and scrolling the screen as necessary
	Notes:  characters 07h (BEL), 08h (BS), 0Ah (LF), and 0Dh (CR)
		 are interpreted and do the expected things</PRE>

<P><a name="a_kurs0400" id="a_kurs0400">Dla nas zawarto¶æ BX nie bêdzie istotna</a>.
 A ta funkcja po prostu wypisuje na ekran jaki¶ znak. No,
teraz wreszcie mo¿emy przej¶æ do programu. Oto on (flagi.asm):</P>
	<BR><a href="#a_kurs0401" class="bezdruk">(przeskocz program wypisuj±cy flagi)</a>

<PRE title="program wypisuj±cy flagi">
; Program wypisuj±cy flagi w postaci dwójkowej
;
; Autor: Bogdan D.
; kontakt:  bogdandr (at) op (dot) pl
;
; kompilacja:
; tasm flagi.asm
; tlink flagi.obj /t


.model tiny		; to bêdzie ma³y program
.code			; tu zaczyna siê segment kodu
.386			; bêdziemy tu u¿ywaæ rejestrów 32-bitowych.
			; .386 MUSI byæ po .code !

org 100h		; to bêdzie program typu .com

main:			; etykieta jest dowolna, byleby zgadza³a siê
			; z t± na koñcu

	pushfd		; 32 bity flag id± na stos

	mov ax,0e30h	; AH = 0eh, czyli funkcja wy¶wietlania,
			; AL = 30h = kod ASCII cyfry zero

	pop esi		; flagi ze stosu do ESI

	mov cx,32	; tyle bitów i tyle razy trzeba przej¶æ
			; przez pêtlê

petla:			; etykieta oznaczaj±ca pocz±tek pêtli.

	and al,30h	; upewniamy siê, ¿e AL zawiera tylko 30h,
			; co zaraz siê mo¿e zmieniæ. A dok³adniej,
			; czy¶cimy bity 0-3, z których bit 0 mo¿e
			; siê zaraz zmieniæ

	shl esi,1	; Przesuwamy bity w ESI o 1 w lewo.
			; 31 bit ESI idzie
			; do Carry Flag (CF)

	adc al,0	; ADC - add with carry. Do AL dodaj
			; 0 + warto¶æ CF.

			; je¶li CF (czyli 31 bit ESI) = 1,
			; to AL := AL+1, inaczej AL bez zmian
	int 10h		; funkcja 0e, wy¶wietl znak w AL,
			; czyli albo zero (30h) albo jedynkê (31h)

	loop petla	; przejd¼ na pocz±tek pêtli,
			; je¶li nie skoñczyli¶my

	mov ah,4ch	; funkcja wyj¶cia do DOS
	int 21h		; wychodzimy

end main		; koniec programu. Ta sama etykieta, co na pocz±tku.</PRE>

<hr>
<P><a name="a_kurs0401" id="a_kurs0401">Wersje NASM i FASM</a>:</P>
	<BR><a href="#a_kurs0402" class="bezdruk">(przeskocz wersjê NASM/FASM programu)</a>

<PRE title="program wypisuj±cy flagi, wersja NASM/FASM">
; Program wypisuj±cy flagi w postaci dwójkowej
;
; Autor: Bogdan D.
; kontakt:  bogdandr (at) op (dot) pl
;
; kompilacja NASM:
;   nasm -o flagi.com -f bin flagi.asm
;
; kompilacja FASM:
;   fasm flagi.asm flagi.com


org 100h		; to bêdzie program typu .com

main:			; etykieta dowolna, nawet niepotrzebna

	pushfd		; 32 bity flag id± na stos

	mov ax,0e30h	; AH = 0eh, czyli funkcja wy¶wietlania,
			; AL = 30h = kod ASCII cyfry zero

	pop esi		; flagi ze stosu do ESI

	mov cx,32	; tyle bitów i tyle razy trzeba przej¶æ
			; przez pêtlê

petla:			; etykieta oznaczaj±ca pocz±tek pêtli.

	and al,30h	; upewniamy siê, ¿e AL zawiera tylko 30h,
			; co zaraz siê mo¿e zmieniæ. A dok³adniej,
			; czy¶cimy bity 0-3, z których bit 0
			; mo¿e siê zaraz zmieniæ

	shl esi,1	; Przesuwamy bity w ESI o 1 w lewo.
			; 31 bit ESI idzie do flagi CF

	adc al,0	; ADC - add with carry. Do AL dodaj
			; 0 + warto¶æ CF.
			; je¶li CF (czyli 31 bit ESI) = 1,
			; to AL := AL+1, inaczej AL bez zmian

	int 10h		; funkcja 0e, wy¶wietl znak w AL,
			; czyli albo zero (30h) albo jedynkê (31h)

	loop petla	; przejd¼ na pocz±tek pêtli,
			; je¶li nie skoñczyli¶my

	mov ah,4ch	; funkcja wyj¶cia do DOS
	int 21h		; wychodzimy</PRE>

<hr>
<P><a name="a_kurs0402" id="a_kurs0402">Kompilujemy go nastêpuj±co</a> (wszystkie programy
bêdziemy tak kompilowaæ, chyba ¿e powiem inaczej):</P>
<PRE>
	tasm flagi.asm
	tlink flagi.obj /t</PRE>
<P>Lub, dla NASMa:</P>
<PRE>	nasm -o flagi.com -f bin flagi.asm</PRE>
<P>Lub, dla FASMa:</P>
<PRE>	fasm flagi.asm flagi.com</PRE>

<P>Nie ma w tym programie wielkiej filozofii. Po prostu 25 bajtów rado¶ci...<BR>
Dociekliwy zapyta, z jakim kodem wyj¶cia wychodzi ten program. Odpowied¼ brzmi oczywi¶cie:<br>
- Albo 30h albo 31h, w zale¿no¶ci od ostatniego bitu oryginalnych flag.
</P>
<hr>
<P>Teraz krótki programik, którego jedynym celem jest wy¶wietlenie na ekranie cyfr od 0 do 9,
ka¿da w osobnej linii:</P>
	<BR><a href="#a_kurs0403" class="bezdruk">(przeskocz program wy¶wietlaj±cy cyfry)</a>
<PRE title="program wy¶wietlaj±cy cyfry">
; tylko wersja NASM/FASM
;
; Program wypisuje na ekranie cyfry od 0 do 9
;
; kompilacja NASM:
;   nasm -O999 -o cyfry.com -f bin cyfry.asm
; kompilacja FASM:
;   fasm cyfry.asm cyfry.com

; definiujemy sta³e:

%define		lf	10	; Line Feed
%define		cr	13	; Carriage Return

; sta³e w wersji FASM:
;	lf = 10
;	cr = 13


org 100h			; robimy program typu .com

	mov	eax, 0		; pierwsza wypisywana cyfra

wyswietlaj:
	call	_pisz_ld	; uruchom procedurê wy¶wietlania
				; liczby w EAX
	call	_nwln		; uruchom procedurê, która przechodzi
				; do nowej linii
	add	eax, 1		; zwiêkszamy cyfrê
	cmp	eax, 10		; sprawdzamy, czy ci±gle EAX &lt; 10
	jb	wyswietlaj	; je¶li EAX &lt; 10, to wy¶wietlamy
				; cyfrê na ekranie

	mov	ax, 4c00h	; funkcja wyj¶cia z programu
	int	21h		; wychodzimy



; nastêpuj±ce procedury (wy¶wietlanie liczby i przechodzenie
; do nowego wiersza) nie s± a¿ tak istotne, aby omawiaæ je
; szczegó³owo, gdy¿ w przysz³o¶ci bêdziemy u¿ywaæ tych samych
; procedur, ale z biblioteki, a te wstawi³em tutaj dla
; uproszczenia kompilacji programu.

; Ogólny schemat dzia³ania tej procedury wygl±da tak:
; we¼my liczbê EAX=12345. Robimy tak:
; 1. dzielimy EAX przez 10. reszta = EDX = DL = 5.
; Zapisz do bufora. EAX = 1234 (iloraz)
; 2. dzielimy EAX przez 10. reszta = DL = 4.
; Zapisz do bufora. EAX=123 (iloraz)
; 3. dzielimy EAX przez 10. reszta = DL = 3.
; Zapisz do bufora. EAX=12
; 4. dziel EAX przez 10. DL = 2. zapisz. iloraz = EAX = 1
; 5. dziel EAX przez 10. DL = 1. zapisz. iloraz = EAX = 0.
; Przerywamy pêtlê.
; Teraz w buforze s± znaki: <q>54321</q>. Wystarczy wypisaæ
; wspak i oryginalna liczba pojawia siê na ekranie.


_pisz_ld:

;pisz32e
;we: EAX=liczba bez znaku do wypisania

	pushfd			; zachowujemy modyfikowane rejestry
	push	ecx
	push	edx
	push	eax
	push	esi

	xor si,si		; SI bêdzie wska¼nikiem do miejsca,
				; gdzie przechowujemy cyfry.
				; Teraz SI=0.

	mov ecx,10		; liczba, przez która bêdziemy dzieliæ

_pisz_ld_petla:
	xor edx,edx		; wyzeruj EDX, bo instrukcja DIV
				; go u¿ywa
	div ecx			; dzielimy EAX przez 10

	mov [_pisz_bufor+si],dl	; do bufora id± reszty z dzielenia
				; przez 10, czyli cyfry wspak

	inc si			; zwiêksz wska¼nik na wolne miejsce.
				; Przy okazji, SI jest te¿ ilo¶ci±
				; cyfr w buforze

	or eax,eax		; sprawdzamy, czy liczba =0
	jnz _pisz_ld_petla	; je¶li nie, to dalej j± dzielimy
				; przez 10

	mov ah,0eh		; funkcja wypisywania
_pisz_ld_wypis:
	mov al,[_pisz_bufor+si-1]	; wypisujemy reszty wspak
	or al,&quot;0&quot;	; z warto¶ci 0-9 zrobimy cyfrê &quot;0&quot;-&quot;9&quot;
	int 10h			; wypisujemy cyfrê

	dec si			; przechodzimy na wcze¶niejsz± cyfrê
	jnz _pisz_ld_wypis	; je¶li SI=0, to nie ma ju¿ cyfr

	pop esi			; przywracamy zmienione rejestry
	pop eax
	pop edx
	pop ecx
	popfd

	ret			; powrót z procedury

_pisz_bufor:	times	40	db 0	; miejsce na 40 cyferek (bajtów)

_nwln:

;wy¶wietla znak koñca linii (Windows)

	push ax
	push bp
	mov ax,(0eh &lt;&lt; 8) | lf		; AX = 0e0ah
	int 10h				; wy¶wietlamy znak LF
	mov al,cr
	int 10h				; wy¶wietlamy znak CR
	pop bp
	pop ax
	ret</PRE>

<BR>
<hr>
<P><a name="a_kurs0403" id="a_kurs0403">Nastêpny <q>twór</q> nie jest wolno stoj±cym programem</a>,
ale pewn± procedur±. Pobiera ona informacje z rejestru AL i wypisuje, co trzeba. Oto ona:</P>
	<BR><a href="#a_kurs0404" class="bezdruk">(przeskocz procedurê _pisz_ch)</a>
<PRE title="procedura _pisz_ch">
_pisz_ch:

;we: AL=cyfra heksadecymalna do wypisania 0...15
; CF=1 je¶li b³±d

	push bp		; zachowaj modyfikowane rejestry: BP, AX, Flagi
	push ax
	pushf

	cmp al,9		; Sprawdzamy dane wej¶ciowe : AL jest w
				; 0-9 czy w 10-15?
	ja _ch_hex		; AL &gt; 9. Skok do _ch_hex
	or al,30h		; 0 &lt; AL &lt; 9. Or ustawia 2 bity,
				; czyni±c z AL liczbê z
				; przedzia³u 30h - 39h, czyli od &quot;0&quot;
				; do &quot;9&quot;. Mo¿na by³o napisaæ
				; &quot;ADD al,30h&quot;, ale zdecydowa³em siê
				; na OR, bo jest szybsze a efekt ten sam.

	jmp short _ch_pz	; AL ju¿ poprawione. Skacz do miejsca,
				; gdzie wypisujemy znak.

_ch_hex:			; AL &gt; 9. Mo¿e bêdzie to cyfra hex,
				; mo¿e nie.
	cmp al,15		; AL &gt; 15?
	ja _blad_ch		; je¶li tak, to mamy b³±d
	add al,&quot;A&quot;-10	; Du¿y skok my¶lowy. Ale wystarczy to rozbiæ
				; na 2 kroki i wszystko staje siê jasne.
				; Najpierw odejmujemy 10 od AL. Zamiast
				; liczby od 10 do 15 mamy ju¿ liczbê
				; od 0 do 5. Teraz tê liczbê dodajemy do
				; &quot;A&quot;, czyli kodu ASCII litery A,
				; otrzymuj±c znak od &quot;A&quot; do &quot;F&quot;

_ch_pz:				; miejsce wypisywania znaków.
	mov ah,0eh		; numer funkcji: 0Eh
	int 10h			; wypisz znak

	popf			; zdejmij ze stosu flagi
	clc			; CF := 0 dla zaznaczenia braku b³êdu
				; (patrz opis procedury powy¿ej)
	jmp short _ch_ok	; skok do wyj¶cia

_blad_ch:			; sekcja obs³ugi b³êdu (AL &gt; 15)
	popf			; zdejmij ze stosu flagi
	stc			; CF := 1 na znak b³êdu

_ch_ok:				; miejsce wyj¶cia z procedury
	pop ax			; zdejmij modyfikowane rejestry
	pop bp

	ret			; return, powrót</PRE>

<P><a name="a_kurs0404" id="a_kurs0404">To chyba nie by³o zbyt trudne</a>, co?<BR>
Szczegó³y dotycz±ce pisania procedur (i bibliotek) znajduj± siê w moim
<a href="bibl_tut.htm" hreflang="pl">artykule o pisaniu bibliotek</a>.</P>

<hr>
<P>Teraz poka¿ê pewien program, który wybra³em ze wzglêdu na du¿± liczbê ró¿nych instrukcji i
sztuczek. Niestety, nie jest on krótki. Ale wspólnie spróbujemy przez niego przej¶æ. Jest to
wersja dla TASMa, ale obok instrukcji postaram siê zamie¶ciæ ich NASMowe odpowiedniki.
Oto on:</P>
	<BR><a href="#a_kurs0405" class="bezdruk">(przeskocz program zliczaj±cy liczby pierwsze)</a>
<PRE title="program zliczaj±cy liczby pierwsze">
; Program liczy liczby pierwsze w przedzia³ach
; 2-10, 2-100, 2-1000,... 2-100.000
;
; Autor: Bogdan D.
; kontakt: bogdandr (at) op (dot) pl
;
; kompilacja TASM:
;   tasm ile_pier.asm
;   tlink ile_pier.obj /t
;
; kompilacja NASM:
;   nasm -f bin -o ile_pier.com ile_pier.asm
;
; kompilacja FASM:
;   fasm ile_pier.asm ile_pier.com


.model tiny		; to bêdzie ma³y program. NASM/FASM: usun±æ.
.code			; pocz±tek segmentu kodu. NASM:
			; &quot;section .text&quot; lub nic. FASM: nic
.386			; bêdziemy u¿ywaæ rejestrów 32-bitowych.
			; NASM: &quot;CPU 386&quot; lub nic, FASM: nic

org 100h		; to bêdzie program typu .com

start:			; pocz±tek...

	xor ebx,ebx	; EBX = liczba, któr± sprawdzamy, czy jest
			; pierwsza. Zaczniemy od 3. Poni¿ej jest 3
			; razy INC (zwiêksz o 1). Najpierw EBX = 0,
			; bo &quot;XOR rej,rej&quot; zeruje dany rejestr.

	xor edi,edi	; EDI = bie¿±cy licznik liczb pierwszych

	xor ecx,ecx	; ECX = stary licznik liczb (z poprzedniego
			; przedzia³u).
			; Chwilowo, oczywi¶cie 0.

	inc ebx		; EBX = 1

	mov esi,10	; ESI = bie¿±cy koniec przedzia³u: 10, 100, ..

	inc edi		; EDI = 1. uwzglêdniamy 2, która jest
			; liczb± pierwsz±

	inc ebx		; EBX = 2, pierwsza liczba bêdzie = 3

petla:			; pêtla przedzia³u

	cmp ebx,esi	; czy koniec przedzia³u? (ebx=liczba,
			; esi=koniec przedzia³u)
	jae pisz	; EBX &gt;= ESI - id¼ do sekcji wypisywania
			; wyników

	mov ebp,2	; EBP - liczby, przez które bêdziemy dzieliæ.
			; pierwszy dzielnik = 2

	inc ebx		; zwiêkszamy liczbê. EBX=3. Bêdzie to
			; pierwsza sprawdzana.

spr:			; pêtla sprawdzania pojedynczej liczby

	mov eax,ebx	; EAX = sprawdzana liczba
	xor edx,edx	; EDX = 0
	div ebp		; EAX = EAX/EBP (EDX by³o=0),
			; EDX=reszta z dzielenia

	or edx,edx	; instrukcja OR tak jak wiele innych,
			; ustawi flagê zera ZF na 1, gdy jej wynik
			; by³ zerem. W tym przypadku pytamy:
			; czy EDX jest zerem?

	jz petla	; je¿eli dzieli siê bez reszty (reszta=EDX=0),
			; to nie jest liczb± pierwsz±
			; i nale¿y zwiêkszyæ liczbê sprawdzan±
			; (inc ebx)

	inc ebp		; zwiêkszamy dzielnik

	cmp ebp,ebx	; dzielniki a¿ do liczby
	jb spr		; liczba &gt; dzielnik - sprawdzaj dalej tê
			; liczbê. Wiem, ¿e mo¿na by³o sprawdzaæ tylko
			; do SQRT(liczba) lub LICZBA/2, ale
			; wyd³u¿y³oby to program i brakowa³o mi ju¿
			; rejestrów...

juz:			; przerobili¶my wszystkie dzielniki,
			; zawsze wychodzi³a reszta,
			; wiêc liczba badana jest pierwsza

	inc edi		; zwiêkszamy licznik liczb znalezionych
	jmp short petla	; sprawdzaj kolejn± liczbê a¿ do koñca
			; przedzia³u.

			; sekcja wypisywania informacji

pisz:
	mov edx,offset przedzial	; NASM/FASM: bez &quot;offset&quot;
	mov ah,9
	int 21h		; wypisujemy napis &quot;Przedzia³ 2-....&quot;

	mov eax,esi	; EAX=ESI=koniec przedzia³u
	call _pisz_ld	; wypisz ten koniec (EAX)


; NASM: mov ax,(0eh &lt;&lt; 8) | &quot;:&quot;	; &lt;&lt; to shift left, | to logiczne OR

	mov ax,(0eh shl 8) or &quot;:&quot; ; to wygl±da zbyt skomplikowanie,
			; ale jest o dziwo prawid³ow± instrukcj±.
			; Jest tak dlatego, ¿e wyra¿enie z prawej
			; strony jest obliczane przez kompilator.
			; 0eh przesuniête w lewo o 8 miejsc daje
			; 0E00 w AX. Dalej, dopisujemy do tego
			; dwukropek, którego kod ASCII nas nie
			; interesuje a bêdzie obliczony przez
			; kompilator. Ostatecznie, to wyra¿enie
			; zostanie skompilowane jako &quot;mov ax,0e3a&quot;.
			; Chodzi o to po prostu, aby
			; nie uczyæ siê tabeli kodów ASCII na pamiêæ.

	int 10h		; wypisujemy dwukropek

	add ecx,edi	; dodajemy poprzedni± liczbê znalezionych
			; liczb pierwszych
	mov eax,ecx	; EAX = liczba liczb pierwszych od 2 do
			; koñca bie¿±cego przedzia³u

	call _pisz_ld	; wypisujemy tê liczbê.


	mov ah,1	; int 16h, funkcja nr 1: czy w buforze
			; klawiatury jest znak?
	int 16h
	jz dalej	; ZF = 1 oznacza brak znaku. Pracuj dalej.
	xor ah,ah
	int 16h		; pobierz ten znak z bufora
			; (int 16h/ah=1 tego nie robi)
koniec:
	mov ax,4c00h
	int 21h		; wyjd¼ z programu z kodem wyj¶cia = 0

dalej:			; nie naci¶niêto klawisza
	cmp esi,100000	; 10^5
	je koniec	; ESI = 100.000? Tak - koniec, bo dalej
			; liczy zbyt d³ugo.

	mov eax,esi	; EAX=ESI
	shl eax,3	; EAX = EAX*8
	shl esi,1	; ESI=ESI*2
	add esi,eax	; ESI = ESI*2 + EAX*8 =ESI*2+ESI*8= ESI*10.
			; Znacznie szybciej ni¿ MUL

	xor edi,edi	; bie¿±cy licznik liczb

	jmp short petla	; robimy od pocz±tku...

przedzial	db	10,13,&quot;Przedzial 2-$&quot;


; NASM/FASM:
; _pisz_bufor: times 6 db 0
_pisz_bufor db 6 dup (0) ; miejsce na cyfry dla nastêpuj±cej procedury:


_pisz_ld:

;we: EAX=liczba bez znaku do wypisania

	push ecx		; zachowujemy modyfikowane rejestry
	push edx
	push eax
	push esi

	xor si,si	; SI=0. Bêdzie wska¼nikiem w powy¿szy bufor.

	mov ecx,10	; bêdziemy dzieliæ przez 10, aby uzyskiwaæ
			; kolejne cyfry. Reszty z dzielenia pójd±
			; do bufora, potem bêd± wypisane wspak, bo
			; pierwsza reszta jest przecie¿ cyfr± jedno¶ci

_pisz_ld_petla:
	xor edx,edx	; EDX=0

	div ecx		; EAX=EAX/ECX, EDX = reszta, która mie¶ci siê
			; w DL, bo to jest tylko 1 cyfra dziesiêtna

	mov [_pisz_bufor+si],dl	; Cyfra do bufora.

	inc si		; Zwiêksz numer komórki w buforze, do której
			; bêdziemy teraz pisaæ

	or eax,eax	; EAX = 0 ?

	jnz _pisz_ld_petla ; Je¶li nie (JNZ), to skok do pocz±tku pêtli

	mov ah,0eh		; funkcja wypisania
_pisz_ld_wypis:
	mov al,[_pisz_bufor+si-1] ; SI wskazuje poza ostatni± cyfrê,
			; dlatego jest -1. Teraz AL= ostatnia cyfra,
			; czyli ta najbardziej znacz±ca w liczbie

		; Zamieñ liczbê 0-9 w AL na gotow± do wypisania cyfrê:
	or al,&quot;0&quot; ; lub &quot;OR al,30h&quot; lub &quot;ADD al,30h&quot;.

	int 10h			; wypisz AL

	dec si			; zmniejsz wska¼nik do bufora.

	jnz _pisz_ld_wypis	; Je¶li ten wska¼nik (SI) nie jest zerem,
				; wypisuj dalej

	pop esi			; odzyskaj zachowane rejestry
	pop eax
	pop edx
	pop ecx

	ret			; powrót z procedury

end start			; NASM/FASM: usun±æ tê linijkê</PRE>

<P><a name="a_kurs0405" id="a_kurs0405">Kilka uwag o tym programie</a>:</P>
<UL>
 <LI>Czemu nie zrobi³em <CODE>MOV EBX,2</CODE> a potem <CODE>INC EBX</CODE>, które musia³o byæ w pêtli?<BR>
	Bo <code>XOR EBX, EBX</code> jest krótsze i szybsze.<BR><BR></LI>
 <LI>Dobra. Wiêc czemu nie:
	<PRE>
		xor ebx,ebx
		inc ebx
		inc ebx	</PRE>
	<P>Te instrukcje operuj± na tym samym rejestrze i ka¿da musi poczekaæ, a¿ poprzednia siê
	zakoñczy. Wspó³czesne procesory potrafi± wykonywaæ niezale¿ne czynno¶ci równolegle,
	dlatego wcisn±³em w ¶rodek jeszcze kilka niezale¿nych instrukcji.</P></LI>
 <LI>Ten program sprawdza za du¿o dzielników. Nie mo¿na by³o sprawiæ, by sprawdza³ tylko do na przyk³ad
	po³owy sprawdzanej liczby?<BR>
	<P>Mo¿na by³o. U¿ywaj±c zmiennych w pamiêci. Niechêtnie to robiê, bo w porównaniu z
	prêdko¶ci± operacji procesora, pamiêæ jest wprost NIEWIARYGODNIE wolna. Zale¿a³o mi na
	szybko¶ci.</P></LI>
 <LI>Czy zamiast
	<PRE>		mov ax,(0eh shl 8) or &quot;:&quot;	</PRE>
	nie pro¶ciej by³oby zapisaæ
	<PRE>
		mov ah,0eh
		mov al,&quot;:&quot;	; lub 3ah	</PRE>

	<P>Jasne, ¿e by³oby pro¶ciej... zrozumieæ. Ale nie wykonaæ dla procesora. Jedn± instrukcjê
	wykonuje siê szybciej ni¿ 2 i to jeszcze po¶rednio operuj±ce na tym samym rejestrze (AX).
	</P></LI>
 <LI> Czy nie pro¶ciej zamiast tych wszystkich <code>SHL</code> zapisaæ jedno
	<code>MUL</code> lub <code>IMUL</code>?<BR>
	<P>Jasne, ¿e pro¶ciej. Przy okazji dobre kilka[na¶cie] razy wolniej.</P></LI>

 <LI>Dlaczego ci±gle <CODE>XOR rej,rej</CODE>?<BR>
	<P>Szybsze ni¿ <CODE>MOV rej,0</CODE>, gdzie to zero musi byæ czêsto zapisane
	 4 bajtami zerowymi. Tak wiêc i krótsze. Oprócz tego, dziêki instrukcji <code>XOR</code>
	lub <code>SUB</code> wykonanej na tym samym rejestrze, procesor wie, ¿e ten rejestr ju¿
	jest pusty. Mo¿e to przy¶pieszyæ niektóre operacje.
	</P></LI>

 <LI>Dlaczego na niektórych etykietach s± jakie¶ znaki podkre¶lenia z przodu?<BR>
	<P>Niektóre procedury s± ¿ywcem wyjête z mojej biblioteki, pisz±c któr± musia³em zadbaæ, by
	przypadkowo nazwa jakie¶ mojej procedury nie by³a identyczna z nazw± jakiej¶ innej
	napisanej w programie korzystaj±cym z biblioteki.<BR>
	Czy nie mog³em tego potem zmieniæ?<BR>
	Jasne, ¿e mog³em. Ale nie by³o takiej potrzeby.</P></LI>
 <LI>Czemu <CODE>OR rej,rej</CODE> a nie <CODE>CMP rej,0</CODE>?<BR>
	<P>OR jest krótsze i szybsze. Mo¿na te¿ u¿ywaæ <CODE>TEST rej,rej</CODE>, które nie zmienia
	zawarto¶ci rejestru.</P></LI>
 <LI>Czemu <CODE>OR al, &quot;0&quot;</CODE>?<BR>
	<P>Bardziej czytelne ni¿ <CODE>ADD/OR al,30h</CODE>. Chodzi o to, aby dodaæ kod ASCII zera. I mo¿na
	to zrobiæ bardziej lub mniej czytelnie.</P></LI>
<!--
 <LI>Po co te ¶mieszne gwiazdki i znaki równo¶ci w komentarzach?<BR>
	<P>Gdy program siê rozrasta, pozwalaj± utrzymaæ czytelno¶æ. Takich linijek u¿ywam do
	oddzielania ró¿nych procedur/sekcji kodu.</P></LI>
-->
</UL>
<P>Wiem, ¿e ten program nie jest doskona³y. Ale taki ju¿ po prostu napisa³em...<BR>
Nie martwcie siê, je¶li czego¶ od razu nie zrozumiecie. Naprawdê, z czasem samo przyjdzie.
Ja te¿ przecie¿ nie umia³em wszystkiego od razu.</P>

<P>Inny program do liczb pierwszych znajdziecie tu: <a href="asm/inni/prime.txt">prime.txt</a>.
</P>
<P>Nastêpnym razem co¶ o u³amkach i koprocesorze.</P>

<blockquote>Podstawowe prawo logiki:<BR>
 Je¿eli wiesz, ¿e nic nie wiesz, to nic nie wiesz.<BR>
  Je¿eli wiesz, ¿e nic nie wiesz, to co¶ wiesz.<BR>
  Wiêc nie wiesz, ¿e nic nie wiesz. </blockquote>

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="a_kurs03.htm">Poprzednia czê¶æ kursu</a> (Alt+3)<BR>
<a accesskey="4" hreflang="pl" href="a_kurs05.htm">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

<BR><HR>
<h2 class="nag">Æwiczenia</h2>
 (mo¿na korzystaæ z zamieszczonych tu procedur)
<OL>
 <LI>Napisz program, który na ekranie wy¶wietli liczby od 90 do 100.<BR><BR></LI>
 <LI>Napisz program sprawdzaj±cy, czy dana liczba (umie¶cisz j± w kodzie, nie musi byæ
	wczytywana znik±d) jest liczb± pierwsz±.<BR><BR></LI>
 <LI>Napisz program wypisuj±cy dzielniki danej liczby (liczba te¿ w kodzie).</LI>

</OL>

</BODY></HTML>
