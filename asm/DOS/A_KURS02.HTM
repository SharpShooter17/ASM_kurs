<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: DOS, czê¶æ 2 - Pamiêæ </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Prev"     hreflang="pl" lang="en" href="a_kurs01.htm">
<link rel="Next"     hreflang="pl" lang="en" href="a_kurs03.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<META NAME="Author"      CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Language"    CONTENT="pl">
<META NAME="Generator"   CONTENT="KWrite">
<META NAME="Keywords"    CONTENT="kurs, asm, asembler, assembler, pamiêæ, RAM, zmienne, DOS, .com, .exe,
	stos, przerwania, procedury, db, dw, dd, dp, df dq, dt, adresowanie, nasm, tasm, fasm,
	segment, offset, tablice">
<meta http-equiv="Last-Modified" content="Sun, Jul 10 2016 10:55:47 GMT">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler?<BR>
	<h1 class="nag">Czê¶æ 2 - Pamiêæ, czyli gdzie upychaæ co¶, co siê nie mie¶ci w procesorze</h1></div>
<P>
Poznali¶my ju¿ rejestry procesora. Jak widaæ, jest ich ograniczona liczba i nie maj± one
zbyt du¿ego rozmiaru. Rejestry ogólnego przeznaczenia s± co najwy¿ej 32-bitowe (czterobajtowe).
Dlatego czêsto programista musi niektóre zmienne umieszczaæ w pamiêci. Przyk³adem tego by³
napis, który wy¶wietlali¶my w poprzedniej czê¶ci artyku³u. By³ on zadeklarowany dyrektyw± DB,
co oznacza <q lang="en">declare byte</q>. Ta dyrektywa niekoniecznie musi deklarowaæ
 dok³adnie 1 bajt. Tak jak
widzieli¶my, mo¿na ni± deklarowaæ napisy lub kilka bajtów pod rz±d. Teraz omówimy rodzinê
dyrektyw s³u¿±cych w³a¶nie do rezerwowania pamiêci.
</P>
<P>
Ogólnie, zmienne mo¿na deklarowaæ jako bajty (dyrektyw± DB, co¶ jak
&nbsp;<span lang="en">char</span>&nbsp; w jêzyku C),
 s³owa (&nbsp;<span lang="en">word</span>&nbsp; = 16 bitów = 2 bajty, co¶ jak
&nbsp; <span lang="en">short</span>&nbsp; w C) dyrektyw± DW,
 podwójne s³owa DD (&nbsp;<span lang="en">double word = dword</span>&nbsp; = 32bity = 4 bajty, jak
  &nbsp;<span lang="en">long</span>&nbsp; w C), potrójne s³owa pword = 6 bajtów - PW,
 poczwórne s³owa DQ (&nbsp;<span lang="en">quad word = qword</span>&nbsp; = 8 bajtów, typ
&nbsp;<span lang="en">long long</span>&nbsp;),
  tbyte = 10 bajtów - DT (typ &nbsp;<span lang="en">long double</span>&nbsp; w C).
</P>
<P>
 Przyk³ady (zakomentowane zduplikowane linijki s± w sk³adni TASMa):</P>
	<BR><a href="#a_kurs0201" tabindex="1" class="bezdruk">(przeskocz przyk³ady)</a>

	<PRE title="przyk³ady deklaracji zmiennych">
	dwa		db 2
	szesc_dwojek	db 2, 2, 2, 2, 2, 2 ; tablica sze¶ciu bajtów
	litera_g	db &quot;g&quot;
	_ax		dw 4c00h	; dwubajtowa liczba ca³kowita
	alfa		dd 12348765h	; czterobajtowa liczba ca³kowita

	;liczba_a	dq 1125		; o¶miobajtowa liczba ca³kowita. NASM
					; starszy ni¿ wersja 2.00
					; tego nie przyjmie, zamienimy to na
					; postaæ równowa¿n±:
	liczba_a	dd 1125, 0	; 2 * 4 bajty

	liczba_e	dq 2.71		; liczba zmiennoprzecinkowa
					; podwójnej precyzji (double)

	;duza_liczba  	dt 6af4aD8b4a43ac4d33h	; 10-bajtowa liczba ca³kowita.
						; NASM/FASM tego nie przyjmie,
						; zrobimy to tak:
	duza_liczba	dd 43ac4d33h, 0f4aD8b4ah; czemu z zerem z przodu?
						; Czytaj dalej
			db 6ah

	pi		dt 3.141592
	;nie_init	db ?		; niezainicjalizowany bajt.
					; Warto¶æ nieznana.
					; NASM tak tego nie przyjmie.
					; Nale¿y u¿yæ:
	nie_init	resb 1
					; za¶ dla FASMa:
	;nie_init	rb 1

	napis1		db &quot;NaPis1.&quot;
	xxx		db 1
			db 2
			db 3
			db 4	</PRE>

<P><a name="a_kurs0201" id="a_kurs0201">Zwróæcie uwagê </a>
na sposób rozbijania du¿ych liczb na poszczególne bajty: najpierw deklarowane
s± m³odsze bajty, a potem starsze (na przyk³ad <q>dd 11223344h</q> jest równoznaczne z
 <q>db 44h, 33h, 22h, 11h</q>). To dzia³a, gdy¿ procesory Intela i
 <acronym title="Advanced Micro Devices" lang="en">AMD</acronym>
  (i wszystkie inne klasy x86) s± procesorami typu
<q lang="en">little-endian</q>, co znaczy, ¿e najm³odsze bajty danego ci±gu bajtów s± umieszczane przez
procesor w najni¿szych adresach pamiêci. Dlatego my te¿ tak deklarujemy nasze zmienne.
</P>
<P>
Ale z kolei takie co¶:</P>
	<PRE>	beta	db aah	</PRE>
<P>nie podzia³a. Dlaczego? <em class="wazne">KA¯DA liczba musi zaczynaæ siê od cyfry</em>.
Jak to obej¶æ? Tak:</P>
	<PRE>	beta	db 0aah	</PRE>
<P>czyli poprzedziæ zerem.<BR>
Nie podzia³a równie¿ to:</P>
	<PRE>	0gamma	db 	9	</PRE>
<P>Dlaczego? Etykiety (dotyczy to tak danych, jak i kodu programu)
 <em class="wazne">nie mog± zaczynaæ siê od cyfr</em>.</P>
<p>
Zapisanie kilku warto¶ci po dyrektywie Dx (DB, DW, DD, i tak dalej) automatycznie
tworzy tablicê elementów odpowiedniego rozmiaru o tych warto¶ciach, z których ka¿da nastêpna
jest tu¿ po poprzedniej w pamiêci.
Na przyk³ad, nastêpuj±ca dyrektywa tworzy tak naprawdê tablicê sze¶ciu bajtów o warto¶ci 2, a nie
próbuje z sze¶ciu dwójek utworzyæ warto¶æ, któr± potem umie¶ci w pojedynczym bajcie:
</p>
<pre>
	szesc_dwojek	db 2, 2, 2, 2, 2, 2</pre>
<P>
A co, je¶li chcemy zadeklarowaæ zmienn±, powiedzmy, sk³adaj±c± siê z 234 bajtów równych zero?
Trzeba je wszystkie napisaæ?
<BR>
Ale¿ sk±d! Nale¿y u¿yæ operatora <q lang="en">duplicate</q>. Odpowied¼ na pytanie brzmi (TASM):</P>
<PRE title="deklaracja tablic w TASM">
	zmienna		db	234	dup(0)
	nazwa		typ	liczba       co zduplikowaæ</PRE>

<P>Lub, dla NASMa i FASMa:</P>
<PRE title="deklaracja tablic w NASM i FASM">
	zmienna:	TIMES	 234	db	0
	nazwa			liczba   typ    co zduplikowaæ</PRE>

<P>A co, je¶li chcemy mieæ dwuwymiarow± tablicê podwójnych s³ów o wymiarach 25 na 34?<BR>
Robimy tak (TASM):</P>

<PRE>	Tablica		dd	25	dup (34 dup(?))</PRE>

<P>Lub, dla NASMa i FASMa na przyk³ad tak:</P>
<PRE>	Tablica:	TIMES	 25*34	dd	0</PRE>

<P>Do obs³ugi takich tablic przydadz± siê bardziej skomplikowane sposoby adresowania zmiennych. O
tym za moment.</P>
<P>
Zmiennych trzeba te¿ umieæ u¿ywaæ.<BR>
Do uzyskania adresu danej zmiennej u¿ywa siê operatora (s³owa kluczowego) <q>offset</q> (TASM), tak
jak widzieli¶my wcze¶niej. Zawarto¶æ zmiennej otrzymuje siê poprzez umieszczenie jej w nawiasach
kwadratowych. Oto przyk³ad:</P>
<PRE title="przyk³ady deklaracji i dostêpu do zmiennych">
	rejestr_ax	dw	4c00h
	rejestr_bx	dw	?		; nie w NASMie/FASMie.
						; u¿yæ na przyk³ad 0 zamiast &quot;?&quot;
	rejestr_cl	db	?		; jak wy¿ej
	...
		mov	[rejestr_bx], bx
		mov	cl, [rejestr_cl]
		mov	ax, [rejestr_ax]
		int	21h</PRE>

<P>Zauwa¿cie zgodno¶æ rozmiarów zmiennych i rejestrów.<BR>
Mo¿emy jednak mieæ problem w skompilowaniu czego¶ takiego:</P>
<PRE>	mov	[jakas_zmienna], 2</PRE>
<P>Dlaczego? Kompilator wie, ¿e gdzie¶ zadeklarowali¶my <q>jakas_zmienna</q>, ale nie wie, czy by³o to</P>
<PRE>	jakas_zmienna	db	0</PRE>
<P>czy</P>
<PRE>	jakas_zmienna	dw	22</PRE>
<P>czy mo¿e</P>
<PRE>	jakas_zmienna	dd	&quot;g&quot;</PRE>
<P>Chodzi o to, aby pokazaæ, jaki rozmiar ma obiekt docelowy. Nie bêdzie problemów, gdy napiszemy:</P>
<PRE title="przyk³ady wpisywania liczb do zmiennych">
	mov	word ptr [jakas_zmienna], 2	; TASM
	mov	word [jakas_zmienna], 2		; NASM/FASM - bez PTR</PRE>

<P>I to obojêtnie, czy zmienna by³a bajtem (wtedy nastêpny bajt bêdzie równy 0), czy s³owem
(wtedy bêdzie ono mia³o warto¶æ 2) czy mo¿e podwójnym s³owem lub czym¶ wiêkszym (wtedy 2
pierwsze bajty zostan± zmienione, a pozosta³e nie). Dzieje siê tak dlatego, ¿e zmienne zajmuj±
kolejne bajty w pamiêci, najm³odszy bajt w komórce o najmniejszym adresie. Na przyk³ad:</P>
<PRE>	xxx	dd	8</PRE>
<P>jest równowa¿ne:</P>
<PRE>	xxx	db	8,0,0,0</PRE>
<P>oraz:</P>
<PRE>	xxx	db	8
		db	0
		db	0
		db	0</PRE>

<P>
Te przyk³ady nie s± jedynymi sposobami adresowania zmiennych (poprzez nazwê). Ogólny schemat
wygl±da tak:</P>
<P>U¿ywaj±c rejestrów 16-bitowych:</P>

    <span class="b" style="font-size: 200%;">[ (BX albo BP) lub (SI albo DI) lub liczba ]</span><br>


<P>     s³owo <q>albo</q> wyklucza wyst±pienie obu rejestrów na raz
<BR>   na przyk³ad
</P>
<PRE title="16-bitowe sposoby adresowania">
	mov	al, [ nazwa_zmiennej+2 ]
	mov	[ di-23 ], cl
	mov	al, [ bx + si + nazwa_zmiennej+18 ]</PRE>

   <P>nazwa_zmiennej to te¿ liczba, obliczana zazwyczaj przez linker.</P>
<P>
   W trybie rzeczywistym (na przyk³ad pod DOSem) pamiêæ podzielona jest na segmenty, po 64kB
 (65536 bajtów) ka¿dy, przy czym
   ka¿dy kolejny segment zaczyna³ siê 16 bajtów dalej ni¿ wcze¶niejszy (nachodz±c na niego).
   Pamiêæ adresowalna wynosi³a maksymalnie 65536 (maks. liczba segmentów) * 16 bajtów/segment
   = 1MB. O tym limicie powiem jeszcze dalej.</P>
	<BR><a href="#a_kurs0202" class="bezdruk">(przeskocz ilustracjê u³o¿enia segmentów)</a>
<PRE title="u³o¿enie segmentów wzglêdem siebie" class="asciiart">
U³o¿enie kolejnych segmentów wzglêdem siebie

	segment o numerze 0
0	+-----------------+
	|		  |	segment o numerze 1
10h	+-----------------+	+-----------------+
	|		  |	|		  |	segment o numerze 2
20h	+-----------------+	+-----------------+	+-----------------+
	|		  |	|		  |	|		  |
30h	+-----------------+	+-----------------+	+-----------------+
	|		  |	|		  |	|		  |</PRE>

<P>
  <a name="a_kurs0202" id="a_kurs0202">S³owo <span lang="en">offset</span> oznacza odleg³o¶æ</a>
    jakiego¶ miejsca od pocz±tku segmentu. Adresy mo¿na by³o pisaæ w
   postaci SEG:OFF. Adres liniowy (prawdziwy) otrzymywa³o siê mno¿±c segment przez 16 (liczba bajtów) i
   dodaj±c do otrzymanej warto¶ci <span lang="en">offset</span>, na przyk³ad adres segmentowy
   1111h:2222h = adres bezwzglêdny 13332h (h = szesnastkowy).<BR>
   Nale¿y te¿ dodaæ, ¿e ró¿ne adresy postaci SEG:OFF mog± dawaæ w wyniku ten sam adres
   rzeczywisty. Oto przyk³ad: 0040h:0072h = (seg*16+off) 400h + 72h = 00472h = 0000h:0472h.
</P>
<P>
   Na procesorach 32-bitowych (od 386) odnoszenie siê do pamiêci mo¿e (w kompilatorze TASM
nale¿y po dyrektywie <q>.code</q> dopisaæ liniê ni¿ej <q>.386</q>) odbywaæ siê wg schematu:</P>

    <span class="b" style="font-size: 200%;">zmienna [rej_baz + rej_ind * skala +- liczba]</span> (tylko TASM/MASM)<BR>
      <P>lub</P>
    <span class="b" style="font-size: 200%;">[    zmienna + rej_baz + rej_ind * skala +- liczba    ]</span>
<P>
   gdzie:</P>
<UL>
 <LI><q>zmienna</q> oznacza nazwê zmiennej i jest to liczba obliczana przez kompilator lub linker</LI>
 <LI>rej_baz (rejestr bazowy) = jeden z rejestrów EAX, EBX, ECX, EDX, ESI,
 	EDI, EBP, ESP</LI>
 <LI>rej_ind (rejestr indeksowy) = jeden z rejestrów EAX, EBX, ECX, EDX, ESI,
 	EDI, EBP (bez ESP)</LI>
 <LI>mno¿nik (scale) = 1, 2, 4 lub 8 (gdy nie jest podany, przyjmuje siê 1)</LI>
</UL>
<P>Tak, tego schematu te¿ <em class="wazne">mo¿na</em> u¿ywaæ w DOSie.<BR>
<BR>
Przyk³ady:</P>
<PRE title="przyk³ady 32-bitowego adresowania">
	mov	al, [ nazwa_zmiennej+2 ]
	mov	[ edi-23 ], cl
	mov	dl, [ ebx + esi*2 + nazwa_zmiennej+18 ]</PRE>

<P>
   Na procesorach 64-bitowych odnoszenie siê do pamiêci mo¿e (w kompilatorze TASM
nie jest to obs³ugiwane) odbywaæ siê wg schematu:</P>

    <span class="b" style="font-size: 200%;">zmienna [rej_baz + rej_ind * skala +- liczba]</span> (tylko TASM/MASM)<BR>
      <P>lub</P>
    <span class="b" style="font-size: 200%;">[    zmienna + rej_baz + rej_ind * skala +- liczba    ]</span>
<P>
   gdzie:</P>
<UL>
 <LI><q>zmienna</q> oznacza nazwê zmiennej i jest to liczba obliczana przez kompilator lub linker</LI>
 <LI>rej_baz (rejestr bazowy) = jeden z rejestrów RAX, RBX, RCX, RDX, RSI,
 	RDI, RBP, RSP, R8, ..., R15, a nawet RIP (ale wtedy nie mo¿na u¿yæ ¿adnego
	rejestru indeksowego)</LI>
 <LI>rej_ind (rejestr indeksowy) = jeden z rejestrów RAX, RBX, RCX, RDX, RSI,
 	RDI, RBP, R8, ..., R15 (bez RSP i RIP)</LI>
 <LI>mno¿nik (scale) = 1, 2, 4 lub 8 (gdy nie jest podany, przyjmuje siê 1)</LI>
</UL>
<P>Tak, tego schematu te¿ <em class="wazne">mo¿na</em> u¿ywaæ w DOSie.<BR>
<BR>
Dwie zasady:</P>
<ul>
<li> miêdzy nawiasami kwadratowymi nie mo¿na mieszaæ rejestrów ró¿nych rozmiarów</li>
<li> w trybie 64-bitowym nie mo¿na do adresowania u¿ywaæ rejestrów cz±stkowych: R*D, R*W, R*B.</li>
</ul>
<P>Przyk³ady:</P>
<PRE title="przyk³ady 64-bitowego adresowania">
	mov	al, [ nazwa_zmiennej+2 ]
	mov	[ rdi-23 ], cl
	mov	dl, [ rbx + rsi*2 + nazwa_zmiennej+18 ]
	mov	rax, [rax+rbx*8-34]
	mov	rax, [ebx]
	mov	r8d, [ecx-11223344]
	mov	cx, [r8]</PRE>



<P>
A teraz inny przyk³ad: spróbujemy wczytaæ 5 elementów o numerach 1, 3, 78, 25, i 200 (pamiêtajmy, ¿e
liczymy od zera) z tablicy <q>zmienna</q> (tej o 234 bajtach, zadeklarowanej wcze¶niej)
do kilku rejestrów 8-bitowych. Operacja nie jest trudna i wygl±da po prostu tak:</P>
<PRE title="przyk³ad dostêpu do tablicy">
	mov	al, [ zmienna + 1 ]
	mov	ah, [ zmienna + 3 ]
	mov	cl, [ zmienna + 78 ]
	mov	ch, [ zmienna + 25 ]
	mov	dl, [ zmienna + 200 ]</PRE>

<P>Oczywi¶cie, kompilator nie sprawdzi za Was, czy takie elementy tablicy rzeczywi¶cie istniej± -
o to musicie zadbaæ sami.</P>
<P>
W powy¿szym przyk³adzie rzuca siê w oczy, ¿e ci±gle u¿ywamy s³owa <q>zmienna</q>, bo wiemy, gdzie
jest nasza tablica. Je¶li tego nie wiemy (dynamiczne przydzielanie pamiêci), lub z
innych przyczyn nie chcemy ci±gle pisaæ <q>zmienna</q>, mo¿emy pos³u¿yæ siê bardziej z³o¿onymi
sposobami adresowania. Po chwili zastanowienia bez problemu stwierdzicie, ¿e powy¿szy kod
mo¿na bez problemu zast±piæ czym¶ takim (i te¿ bêdzie dzia³aæ):</P>
<PRE title="dostêp do tablicy z u¿yciem rejestru">
	mov	bx, OFFSET zmienna	; w NASMie/FASMie: <q>mov bx, zmienna</q>
	mov	al, [ bx + 1 ]
	mov	ah, [ bx + 3 ]
	mov	cl, [ bx + 78 ]
	mov	ch, [ bx + 25 ]
	mov	dl, [ bx + 200 ]</PRE>

<P>Teraz trudniejszy przyk³ad: spróbujmy dobraæ siê do kilku elementów dwuwymiarowej tablicy dwordów
zadeklarowanej wcze¶niej (tej o rozmiarze 25 na 34). Mamy 25 wierszy po 34 elementy ka¿dy.
Aby do EAX wpisaæ pierwszy element pierwszego wiersza, piszemy oczywi¶cie tylko:</P>
<PRE>
	mov	eax, [Tablica]</PRE>

<P>Ale jak odczytaæ 23 element 17 wiersza? Otó¿, sprawa nie jest taka trudna, jakby siê mog³o
wydawaæ. Ogólny schemat wygl±da tak (zak³adam, ¿e ostatni wska¼nik zmienia siê najszybciej,
potem przedostatni itd. - pamiêtamy, ¿e rozmiar elementu wynosi 4):</P>
<PRE>
	Tablica[17][23] = [ Tablica + (17*d³ugo¶æ_wiersza + 23)*4 ]</PRE>

<P>No wiêc piszemy (u¿yjemy tutaj wygodniejszego adresowania 32-bitowego):</P>

<PRE title="dostêp do tablicy w pêtli">
		mov	ebx, OFFSET Tablica	; w NASMie/FASMie:
						; mov ebx, Tablica
		mov	esi, 17
	jakas_petla:
		imul	esi, 34		; ESI = ESI * 34 =
					; 17 * d³ugo¶æ wiersza
		add	esi, 23		; ESI = ESI + 23 =
					; 17 * d³ugo¶æ wiersza + 23
		mov	eax, [ ebx + esi*4 ]	; mno¿ymy numer elementu
						; przez rozmiar elementu
		...</PRE>

<P>Mo¿na by³o to zrobiæ po prostu tak:</P>
<PRE>	mov	eax, [ Tablica + (17*34 + 23)*4 ]</PRE>
<P>ale poprzednie rozwi±zanie (na rejestrach) jest wprost idealne do pêtli, w której robimy co¶
z coraz to innym elementem tablicy.</P>
<P>
Podobnie (<q>(numer_wiersza*d³ugo¶æ_wiersza1 + numer_wiersza*d³ugo¶æ_wiersza2 + ...
)*rozmiar_elementu</q>)
adresuje siê tablice wielowymiarowe. Schemat jest nastêpuj±cy:</P>
<PRE title="adresowanie z³o¿onych tablic">
	Tablica[d1][d2][d3][d4]	  - 4 wymiary o d³ugo¶ciach wierszy
				    d1, d2, d3 i d4

	Tablica[i][j][k][m] = [ Tablica + (i*d2*d3*d4+j*d3*d4+k*d4+m)*
				*rozmiar elementu ]</PRE>

<P>Teraz powiedzmy, ¿e mamy tak± tablicê:
<PRE>	dword tab1[24][78][13][93]</PRE>
<P>Aby dobraæ siê do elementu tab1[5][38][9][55], piszemy:</P>
<PRE>	mov	eax, [ tab1 + (5*78*13*93 + 38*13*93 + 9*93 + 55)*4 ]</PRE>
<P>
Pytanie: do jakich segmentów odnosi siê to ca³e adresowanie? Przecie¿ mamy kilka rejestrów
segmentowych, które mog± wskazywaæ na zupe³nie co innego.<BR>
Odpowied¼:<BR>
Na rejestrach 16-bitowych obowi±zuj± regu³y:</P>
<UL>
 <LI>je¶li pierwszym rejestrem jest BP, u¿ywany jest SS</LI>
 <LI>w pozosta³ych przypadkach u¿ywany jest DS</LI>
</UL>
<P>Na rejestrach 32-bitowych mamy:</P>
<UL>
 <LI>je¶li pierwszym w kolejno¶ci rejestrem jest EBP lub ESP, u¿ywany jest SS</LI>
 <LI>w pozosta³ych przypadkach u¿ywany jest DS</LI>
</UL>
<P>W systemach 64-bitowych segmenty odchodz± w zapomnienie.
<br>
Domy¶lne ustawianie mo¿na zawsze obej¶æ u¿ywaj±c przedrostków, na przyk³ad</P>
<PRE title="u¿ycie segmentów innych ni¿ domy¶lne">
	; TASM:
		mov	ax, ss:[si]
		mov	gs:[eax+ebx*2-8], cx

	; NASM/FASM:
		mov	ax, [ss:si]
		mov	[gs:eax+ebx*2-8], cx
</PRE>

<BR><BR><BR>




<HR>
<h2 class="nag">Organizacja pamiêci w komputerze</h2>
<P>
Po za³adowaniu systemu <acronym lang="en" title="Disk Operating System">DOS</acronym>,
 pamiêæ wygl±da z grubsza tak (niektóre elementy zostan± zaraz opisane) :</P>

	<BR><a href="#a_kurs0203" class="bezdruk">(przeskocz ilustracjê pamiêci w DOSie)</a>
<PRE title="pamiêæ w systemie DOS" class="asciiart">
	FFFFF	+-----------------------------------------------+
		|	Pamiêæ urz±dzeñ, HMA, UMB, czê¶æ BIOSu	|
	BFFFF	+-----------------------------------------------+
		|	Pamiêæ karty graficznej			|
	A0000	+-----------------------------------------------+
		|						|
		..		...				..
		..		...				..
		|	Uruchamiane programy			|
		+-----------------------------------------------+
		|						|
		..		...				..
		..		...				..
		|	DOS - jego kod, dane i stos		|
	~500h	+-----------------------------------------------+
		|	BIOS Data Area (segment 40h)		|
	400h	+-----------------------------------------------+
		|	Tablica wektorów przerwañ		|
	0	+-----------------------------------------------+</PRE>

<P><a name="a_kurs0203" id="a_kurs0203">Od segmentu A0000</a>
 zaczyna siê pamiêæ karty graficznej. Pamiêæ ta jest bezpo¶rednim odwzorowaniem ekranu
 i pisz±c tam, zmieniamy zawarto¶æ ekranu (wiêcej o tym w innych artyku³ach). Po przeliczeniu A0000 na
 system dziesiêtny dostajemy 655360, czyli ... 640<abbr title="kilobajt">kB</abbr>.
  St±d wzi±³ siê ten s³awny limit pamiêci konwencjonalnej.</P>
<P>Powy¿ej znajduje siê DOSowy <span lang="en">Upper Memory Block</span>
 i <span lang="en">High Memory Area</span>. Na samym koñcu granic adresowania
 (czyli tu¿ pod 1<abbr title="megabajt">MB</abbr>) jest jeszcze skrawek BIOSu
  i to miejsce (a w³a¶ciwie to adres FFFF:0000) jest
 punktem startu procesora tu¿ po w³±czeniu zasilania. W okolicach tego adresu znajduje siê
 instrukcja skoku, która mówi procesorowi, gdzie s± dalsze instrukcje.<br>
 Od adresu zero zaczyna siê Tablica Wektorów Przerwañ (<span lang="en">Interrupt Vector Table</span>,
 IVT), maj±ca 256 adresów procedur obs³ugi przerwañ po 4 bajty (segment+offset) ka¿dy.<br>
 Potem jest <span lang="en">BIOS Data Area</span> (segment 40h), powy¿ej - kod DOSa, a
 po nim miejsce na uruchamiane programy.
 </P>

<P>Ale chwileczkê! DOS nie mo¿e korzystaæ z wiêcej ni¿ 1 MB pamiêci? A co z
<acronym title="Expanded Memory Specification" lang="en">EMS</acronym> i
<acronym title="Extended Memory Specification" lang="en">XMS</acronym>?<BR>
 Megabajt pamiêci to wszystko, co mo¿e osi±gn±æ procesor 16-bitowy. Procesory od 80386 w górê s±
 co najmniej 32-bitowe, co daje ³±czn± mo¿liwo¶æ zaadresowania 2^32 = 4<abbr title="gigabajt">GB</abbr>
  pamiêci, o ile tylko jest tyle zainstalowane.<BR>
 Menad¿ery EMS i XMS s± to programy (napisane dla procesorów 32-bitowych), które umo¿liwiaj± innym
 programom dostêp do pamiêci powy¿ej 1 MB. Sam DOS nie musi mieæ a¿ tyle pamiêci, ale inne
 programy mog± korzystaæ z dobrodziejstw wiêkszych ilo¶ci pamiêci
 <acronym lang="en" title="Random Access Memory">RAM</acronym>. Zamiast korzystaæ z przerwania DOSa
 do rezerwacji pamiêci, programy te korzystaj± z interfejsu udostêpnianego przez na przyk³ad HIMEM.SYS czy
 EMM386.EXE i udokumentowanego w
 <A HREF="http://www-2.cs.cmu.edu/afs/cs.cmu.edu/user/ralf/pub/WWW/files.html" hreflang="en"
 	>spisie przerwañ Ralfa <span lang="en">Brown</span>'a</A>.
<br>
O tym, jak korzystaæ z pamiêci EMS i XMS, mo¿ecie przeczytaæ te¿ w moim
<a href="emsxms.htm" hreflang="pl">mini-kursie o pamiêci EMS i XMS</a>.
</P>
<P>
Struktura pamiêci dla poszczególnych programów zale¿y od ich typu. Jak pamiêtamy z czê¶ci pierwszej, program
 typu .com mie¶ci siê w jednym segmencie, wykonywanie zaczyna siê od adresu 100h (256. bajt), a wcze¶niej
 jest miêdzy innymi linia poleceñ programu.<BR>
Wygl±da to tak:</P>
	<BR><a href="#a_kurs0204" class="bezdruk">(przeskocz ilustracjê pamiêci programu COM)</a>
<PRE title="uk³ad programu .com" class="asciiart">
			+-----------------------+
			|	CS:FFFF		|	- tu zaczyna siê stos
			|   Stos, zm. lokalne	|
			|   argumenty funkcji	|
			|			|
			+-	 .....	       -+
			|			|
			+-	 .....	       -+
			|			|
			+-	 .....	       -+
			| CS:100h pocz±tek kodu	|
			+-----------------------+
			|			|
	CS=DS=ES=SS	+-----------------------+</PRE>

<P><a name="a_kurs0204" id="a_kurs0204">Kod zaczyna siê od CS:100h</a>, wszystkie rejestry
segmentowe maj± równe warto¶ci. Od CS:FFFF zaczyna siê stos rosn±cy oczywi¶cie w dó³, wiêc
pisz±c taki program trzeba uwa¿aæ, by ze stosem nie wej¶æ na kod lub dane.
</P>
<P>
 Programy .exe maj±
 nieco bardziej z³o¿on± strukturê. Kod zaczyna siê pod adresem 0 w danym, wyznaczonym
 przez DOS, segmencie. Ale rejestry DS i ES maj± inn± warto¶æ ni¿ CS i wskazuj± na wspomniane przy
 okazji programów .com 256 bajtów zawieraj±cych liniê poleceñ programu itp. Dane programu, je¶li
 zosta³y umieszczone w kodzie w osobnym segmencie, te¿ mog± dostaæ w³asny segment pamiêci.
 Segment stosu za¶ jest ca³kowicie oddzielony od pozosta³ych, zwykle za kodem.
 Jego po³o¿enie zale¿y od rozmiaru kodu i danych. Jako ¿e programy .exe posiadaj± nag³ówek,
 DOS nie musi przydzielaæ im ca³ego segmentu. Zamiast tego,
 rozmiar segmentu kodu (i stosu) odczyta sobie z nag³ówka pliku.<BR>
Graficznie wygl±da to tak:</P>

	<BR><a href="#a_kurs0205" class="bezdruk">(przeskocz ilustracjê pamiêci programu EXE)</a>
<PRE title="uk³ad programu .exe" class="asciiart">
			+-----------------------+
			|   Stos, zm. lokalne	|
			|   argumenty funkcji	|
	SS		+-----------------------+

			+-----------------------+
			|  Dane, zm. globalne	|
			|      (statyczne)	|
			+-----------------------+

			+-----------------------+
			|	CS:xxxx		|
			+-	 .....	       -+
			|			|
			+-	 .....	       -+
			|			|
			+-	 .....	       -+
			|			|
			+-	 .....	       -+
			|   CS:0 pocz±tek kodu	|
	CS		+-----------------------+

			+-----------------------+
			|			|
	DS=ES		+-----------------------+</PRE>






<BR><BR><HR>
<h2 class="nag"><a name="a_kurs0205" id="a_kurs0205">Stos</a></h2>
<P>
Przysz³a pora na omówienie, czym jest stos.<BR>
Otó¿, stos jest po prostu kolejnym segmentem pamiêci.
 S± na nim umieszczane dane tymczasowe, na przyk³ad
<em class="wazne">adres powrotny z funkcji, jej parametry wywo³ania, jej zmienne lokalne</em>.
S³u¿y te¿ do zachowywania zawarto¶ci rejestrów.<BR>
Obs³uga stosu jest jednak zupe³nie inna.<BR>
Po pierwsze, stos jest <q>budowany</q> od góry na dó³! Rysunek bêdzie pomocny:
</P>
	<BR><a href="#a_kurs0206" class="bezdruk">(przeskocz rysunek stosu)</a>
<PRE title="rysunek stosu" class="asciiart">

	Adres
			SS
		+-------------------+
	100h	|		    |
		+-------------------+	&lt;----- SP = 100h
	0FEh	|		    |
		+-------------------+
	0FCh	|		    |
		+-------------------+
	0FAh	|		    |
		+-------------------+
	0F8h	|		    |
		+-------------------+
	0F6h	|		    |
	...		....</PRE>

<P><a name="a_kurs0206" id="a_kurs0206">Na tym rysunku</a>
 SP=100h, czyli SP wskazuje na komórkê o adresie 100h w segmencie SS.<BR>
Dane na stosie umieszcza siê instrukcj± <code><span lang="en">PUSH</span></code>
a zdejmuje instrukcj± <code>POP</code>.
 <code><span lang="en">PUSH</span></code> jest równowa¿ne parze pseudo-instrukcji:</P>
<PRE>
	sub	sp, ..	; rozmiar zale¿y od rozmiaru obiektu w bajtach
	mov	ss:[sp], ..</PRE>

<P>a <code>POP</code>:</P>
<PRE>
	mov	.., ss:[sp]
	add	sp, ..</PRE>

<P>Tak wiêc, po wykonaniu instrukcji <code><span lang="en">PUSH</span> AX</code>
i <code><span lang="en">PUSH</span> DX</code> powy¿szy stos bêdzie wygl±da³ tak:</P>
	<BR><a href="#a_kurs0207" class="bezdruk">(przeskocz rysunek dzia³ania stosu)</a>
<PRE title="operacje na stosie: PUSH" class="asciiart">
	Stos po wykonaniu PUSH AX i PUSH DX, czyli
		sub	sp, 2
		mov	ss:[sp], ax
		sub	sp, 2
		mov	ss:[sp], dx

			SS
		+-------------------+
	100h	|		    |
		+-------------------+
	0FEh	|	AX	    |
		+-------------------+
	0FCh	|	DX	    |
		+-------------------+	&lt;----- SP = 0FCh
	...		....</PRE>

<P><a name="a_kurs0207" id="a_kurs0207">SP=0FCh, pod [SP] znajduje siê warto¶æ DX</a>, a pod
[SP+2] - warto¶æ AX. A po wykonaniu instrukcji <code>POP EBX</code> (tak, mo¿na zdj±æ
dane do innego rejestru, ni¿ ten, z którego pochodzi³y):</P>
	<BR><a href="#a_kurs0208" class="bezdruk">(przeskocz drugi rysunek dzia³ania stosu)</a>
<PRE title="operacje na stosie: POP" class="asciiart">
	Stos po wykonaniu POP EBX, czyli
		mov	ebx, ss:[sp]
		add	sp, 4

			SS
		+-------------------+
	100h	|		    |
		+-------------------+	&lt;----- SP = 100h
	0FEh	|	AX	    |
		+-------------------+
	0FCh	|	DX	    |
		+-------------------+
	...		....</PRE>

<P><a name="a_kurs0208" id="a_kurs0208">Teraz ponownie SP=100h</a>.
Zauwa¿cie, ¿e dane s± tylko kopiowane ze stosu, a nie z niego usuwane. Ale w ¿adnym przypadku nie
mo¿na na nich ju¿ polegaæ. Dlaczego? Zobaczycie zaraz.<BR>
Najpierw bardzo wa¿na uwaga, która jest wnioskiem z powy¿szych rysunków.<BR>
Dane (które chcemy z powrotem odzyskaæ w niezmienionej postaci) po³o¿one na stosie instrukcj±
<code><span lang="en">PUSH</span></code> nale¿y zdejmowaæ kolejnymi instrukcjami <code>POP</code>
 <em class="wazne">W ODWROTNEJ KOLEJNO¦CI</em> ni¿ by³y k³adzione. Zrobienie czego¶ takiego:</P>
<PRE>
	push	ax
	push	dx
	pop	ax
	pop	dx
</PRE>
<P><em class="wazne">nie przywróci rejestrom ich dawnych warto¶ci!</em></P>







<BR><BR>
<HR>
<h2 class="nag">Przerwania i procedury a stos</h2>
<P>
U¿ywali¶my ju¿ instrukcji przerwania, czyli <code>INT</code>. Przy okazji omawiania stosu nadesz³a pora, aby
powiedzieæ, co ta instrukcja w ogóle robi. Otó¿, <code>INT</code> jest równowa¿ne temu pseudo-kodowi:</P>
<!-- 	<BR><a href="#a_kurs0208_1" class="bezdruk">(przeskocz dzia³anie INT)</a> -->
<PRE title="dzia³anie instrukcji INT">
	pushf			; w³ó¿ na stos rejestr stanu procesora (flagi)
	push	cs		; segment, w którym aktualnie pracujemy
	push	ip_next		; adres instrukcji po INT
	jmp	procedura_obslugi_przerwania</PRE>

<P><a name="a_kurs0208_1" id="a_kurs0208_1">Ka¿da procedura obs³ugi przerwania</a>
(<span lang="en">Interrupt Service Routine</span>, ISR) koñczy siê instrukcj± <code>IRET</code>
 (<span lang="en">interrupt return</span>), która odwraca powy¿szy kod, czyli z
ISR procesor wraca do dalszej obs³ugi naszego programu.</P>
<P>
Jednak oprócz instrukcji <code>INT</code> przerwania mog± byæ wywo³ane w inny sposób - przez sprzêt. Tutaj
w³a¶nie pojawiaj± siê <acronym lang="en" title="Interrupt Request">IRQ</acronym>.
 Do urz±dzeñ wywo³uj±cych przerwania IRQ nale¿± miêdzy innymi  karta d¼wiêkowa,
modem, zegar, kontroler dysku twardego, itd...</P>
<P>
Bardzo istotn± rolê gra zegar, utrzymuj±cy aktualny czas w systemie. Jak napisa³em w jednym z
artyku³ów, tyka on z czêstotliwo¶ci± ok. 18,2 Hz. Czyli ok. 18 razy na sekundê wykonywane s± 3
<code><span lang="en">PUSH</span></code>e a po nich 3 <code>POP</code>y. Nie zapominajmy o
<code>PUSH</code> i <code>POP</code> wykonywanych w samej ISR tylko po to, aby zachowaæ modyfikowane
rejestry. Ka¿dy <code><span lang="en">PUSH</span></code> zmieni to, co jest poni¿ej SP.</P>

<P><em class="wazne">Dlatego w³a¶nie ¿adne dane poni¿ej SP nie mog± byæ uznawane za wiarygodne.</em></P>
<P>
Gdzie za¶ znajduj± siê procedury obs³ugi przerwañ?<BR>
W pamiêci, pod adresami od 0000:0000 do 0000:03ff w³±cznie znajduj± siê czterobajtowe adresy (pary
CS oraz IP) odpowiednich procedur. Jest ich 256.<BR>
Pierwszy adres jest pod 0000:0000 - wskazuje on na procedurê obs³ugi przerwania int 0<BR>
Drugi    adres jest pod 0000:0004 - int 1<BR>
Trzeci   adres jest pod 0000:0008 - int 2<BR>
Czwarty  adres jest pod 0000:000c - int 3<BR>
...<BR>
255-ty   adres jest pod 0000:03fc - int 0FFh<BR>
W taki w³a¶nie sposób dzia³a mechanizm przerwañ w DOSie.
</P>
<P>
Mniej skomplikowana jest instrukcja <code><span lang="en">CALL</span></code>,
 która s³u¿y do wywo³ywania zwyk³ych procedur, na przyk³ad:</p>
<pre>
	call proc1		; wywo³anie proste
	call [adres_proc1]	; wywo³anie procedury, której adres
				; jest w zmiennej adres_proc1
	...
proc1:
	...
	ret</pre>
<p> W
zale¿no¶ci od rodzaju procedury (<span lang="en">near</span> - zwykle w tym samym pliku/programie,
 far - na przyk³ad w innym pliku/segmencie), instrukcja <code><span lang="en">CALL</span></code>
 wykonuje takie co¶:</P>
<!-- 	<BR><a href="#a_kurs0208_2" class="bezdruk">(przeskocz dzia³anie CALL)</a> -->
<PRE title="dzia³anie instrukcji CALL">
	push	cs		; tylko je¶li FAR
	push	ip_next		; adres instrukcji po CALL</PRE>

<P><a name="a_kurs0208_2" id="a_kurs0208_2">Procedura mo¿e zawieraæ dowolne </a>
(nawet ró¿ne ilo¶ci instrukcji <code><span lang="en">PUSH</span></code> i <code>POP</code>), ale
pod koniec SP musi byæ taki sam, jak by³ na pocz±tku, czyli wskazywaæ na prawid³owy adres powrotu,
który ze stosu jest zdejmowany instrukcj± <code>RET</code> (lub <code>RETF</code>). Dlatego
nieprawid³owe jest takie co¶:</P>
<!-- 	<BR><a href="#a_kurs0209" class="bezdruk">(przeskocz przyk³ad z³ej procedury)</a> -->
<PRE title="nieprawid³owa procedura">
	zla_procedura:
		push	ax
		push	bx
		add	ax, bx
		ret</PRE>

<P><a name="a_kurs0209" id="a_kurs0209">gdy¿ w chwili wykonania </a>
instrukcji <code>RET</code> na wierzchu stosu jest BX, a nie adres powrotny! B³±d
stosu jest przyczyn± wielu trudnych do znalezienia usterek w programie.
<BR> Jak to poprawiæ bez zmiany sensu? Na przyk³ad tak:</P>
<!-- 	<BR><a href="#a_kurs0210" class="bezdruk">(przeskocz przyk³ad dobrej procedury)</a> -->
<PRE title="prawid³owa procedura">
	dobra_procedura:
		push	ax
		push	bx
		add	ax, bx
		add	sp, 4
		ret</PRE>
	<a name="a_kurs0210" id="a_kurs0210"></a>

<P>Teraz ju¿ wszystko powinno byæ dobrze. SP wskazuje na dobry adres powrotny. Dopuszczalne jest
te¿ takie co¶:</P>
	<BR><a href="#a_kurs0211" class="bezdruk">(przeskocz przyk³ad innej dobrej procedury)</a>
<PRE title="kolejna prawid³owa procedura">
	; TASM:
	proc1	proc	near
		push	ax
		cmp	ax, 0		; czy AX jest zerem?
		je	koniec1		; je¶li tak, to koniec1

		pop	bx
		ret
	koniec1:
		pop	cx
		ret
	proc1	endp</PRE>


<BR><a href="#a_kurs0212" name="a_kurs0211" id="a_kurs0211" class="bezdruk">(przeskocz ten sam przyk³ad w wersji NASM i FASM)</a>

<PRE title="kolejna prawid³owa procedura w wersji NASM/FASM">
	; NASM/FASM:
	proc1:				; bez PROC i NEAR
		push	ax
		cmp	ax, 0		; czy AX jest zerem?
		je	koniec1		; je¶li tak, to koniec1

		pop	bx
		ret
	koniec1:
		pop	cx
		ret
	; bez ENDP</PRE>

<P><a name="a_kurs0212" id="a_kurs0212">SP ci±gle jest dobrze ustawiony</a>
 przy wyj¶ciu z procedury mimo, i¿ jest 1 <code><span lang="en">PUSH</span></code> a 2 <code>POP</code>y.<BR>
Po prostu <em class="wazne">ZAWSZE</em> nale¿y robiæ tak, aby SP wskazywa³ na poprawny
adres powrotny, niezale¿nie od sposobu.
W sk³ad tego wchodzi definiowanie procedur pod g³ównym programem (po ostatnich instrukcjach
zamykaj±cych program).
Dlaczego? Niektóre (najprostsze)
formaty plików wykonywalnych nie pozwalaj± na okre¶lenie pocz±tku programu i takie programy
s± wykonywane po prostu z góry na dó³. Je¶li u góry kodu umie¶ci siê procedury, zostan± one wykonane,
po czym instrukcja <code>RET</code> (lub <code>RETF</code>) spowoduje zamkniêcie programu
(w najlepszym przypadku) lub wej¶cie procesora na nieprawid³owe lub losowe instrukcje w pamiêci.
</P>






<hr>
<h2 class="nag">Alokacja zmiennych lokalnych procedury</h2>
<P>
Nie musi siê to Wam od razu przydaæ, ale przy okazji stosu omówiê, gdzie znajduj± siê
 zmienne lokalne funkcji (na przyk³ad takich w jêzyku C) oraz jak rezerwowaæ na nie miejsce.</P>
<P>
Gdy program wykonuje instrukcjê <code><span lang="en">CALL</span></code>, na stosie umieszczany jest adres
 powrotny (o czym ju¿ wspomnia³em). Jako ¿e nad nim mog± byæ jakie¶ dane wa¿ne dla programu
 (na przyk³ad zachowane rejestry, inne adresy powrotne),
 nie wolno tam nic zapisywaæ. Ale pod adresem powrotnym jest du¿o miejsca i to tam w³a¶nie
 programy umieszczaj± swoje zmienne lokalne.</P>
<P>Samo rezerwowanie miejsca jest do¶æ proste: liczymy, ile ³±cznie bajtów nam potrzeba na
 w³asne zmienne i tyle w³a¶nie odejmujemy od rejestru SP, robi±c tym samym miejsce na stosie, które
 nie bêdzie zamazane przez instrukcje <code>INT</code> i <code><span lang="en">CALL</span></code>
(gdy¿ one zamazuj± tylko to, co jest pod SP).</P>
<P>
Na przyk³ad, je¶li nasze zmienne zajmuj± 8 bajtów (np.dwa DWORDy lub dwie 32-bitowe zmienne
 typu "int" w jêzyku C), to odejmujemy te 8 od SP i nasz nowy stos wygl±da tak:</P>

<pre title="rezerwacja miejsca na zmienne lokalne" class="asciiart">
			SS
		+-------------------+
	100h	|  adres powrotny   |
		+-------------------+	&lt;----- stary SP = 100h
	0FEh	|	wolne	    |
		+-------------------+
	0FCh	|	wolne	    |
		+-------------------+
	0FAh	|	wolne	    |
		+-------------------+
	0F8h	|	wolne	    |
		+-------------------+	&lt;----- SP = 0F8h</pre>

<P>SP wynosi 0F8h, nad nim jest 8 bajtów wolnego miejsca, po czym adres powrotny i inne stare dane.3
</p>
<p>
Nie trzeba podawaæ typów zmiennych lokalnych, ich liczby ani ich nazywaæ - wystarczy obliczyæ ich
³±czny rozmiar i ten rozmiar odj±æ od SP. To, gdzie która zmienna faktycznie w pamiêci siê
znajdzie (lub inaczej: który obszar pamiêci bêdzie przypisany której zmiennej), zale¿y
ca³kowicie od programisty - na przyk³ad [SP] mo¿e przechowywaæ pierwsz± zmienn±, a [SP+4]
- drug±, ale mo¿e byæ te¿ ca³kiem na odwrót.</P>
<P>
Miejsce ju¿ mamy, korzystanie z niego jest proste - wystarczy odwo³ywaæ siê do
 [SP], [SP+2], [SP+4], [SP+6]. Ale stanowi to pewien problem, bo po ka¿dym wykonaniu
 instrukcji <code><span lang="en">PUSH</span></code> lub <code><span lang="en">POP</span></code>,
 te cyferki siê zmieniaj± (bo przecie¿ adresy siê
 nie zmieniaj±, ale SP siê zmienia). Dlatego w³a¶nie do adresowania zmiennych lokalnych
 czêsto u¿ywa siê innego rejestru ni¿ SP. Jako ¿e domy¶lnym segmentem dla BP
 jest segment stosu, wybór pad³ w³a¶nie na ten rejestr (oczywi¶cie, mo¿na u¿ywaæ
 dowolnego innego, tylko trzeba dostawiaæ SS: z przodu, co kosztuje za ka¿dym razem 1 bajt).</P>
<P>
Aby móc naj³atwiej dostaæ siê do swoich zmiennych lokalnych, wiêkszo¶æ funkcji na pocz±tku
 zrównuje BP z SP, potem wykonuje rezerwacjê miejsca na zmienne lokalne, a dopiero potem
 - zachowywanie rejestrów itp. (czyli swoje <code><span lang="en">PUSH</span></code>e). Wygl±da to tak:</P>
<pre>
	push	bp		; zachowanie starego BP
	mov	bp, sp		; BP = SP

	sub	sp, xxx		; rezerwacja miejsca na zmienne lokalne
	push	rej1		; tu SP siê zmienia, ale BP ju¿ nie
	push	rej2
	...

	...
	pop	rej2		; tu SP znów siê zmienia, a BP - nie
	pop	rej1

	mov	sp, bp		; zwalnianie zmiennych lokalnych
				;   mo¿na te¿ (ADD SP,xxx)
	pop	bp

	ret</pre>
<p>
Niektóre kompilatory umo¿liwiaj± deklaracjê procedury z parametrami, zmiennymi lokalnymi i ich typami:
</p>
<pre>
	proc2 proc a:DWORD,b:DWORD
		LOCAL c:DWORD
		LOCAL d:DWORD
		LOCAL e:DWORD
		...
		ret
	proc2 endp</pre>
<p>
Mo¿na wtedy odwo³ywaæ siê do parametrów i zmiennych lokalnych przez ich nazwy, zamiast przez wyra¿enia
typu [SP+nnn] i [SP-nnn].
</p>
<P>Przy instrukcji <code>MOV SP, BP</code> napisa³em, ¿e zwalnia ona zmienne lokalne.
 Zmienne te oczywi¶cie dalej s± na stosie, ale teraz s± ju¿ poni¿ej SP, a niedawno
 napisa³em: <em class="wazne">¿adne dane poni¿ej SP nie mog± byæ uznawane za wiarygodne.</em></P>
<P>
Po piêciu pierwszych instrukcjach nasz stos wygl±da tak:</P>
<pre title="BP i SP po prologu" class="asciiart">
			   SS
		+-----------------------+
		|    adres powrotny	|
		+-----------------------+
		|       stary BP	|
		+-----------------------+	&lt;----- BP
		|      xxx bajtów	|
		|			|
		|			|
		+-----------------------+
		|  	  rej1		|
		+-----------------------+
		|	  rej2		|
		+-----------------------+	&lt;----- SP</pre>

<P>Rejestr BP wskazuje na star± warto¶æ BP, za¶ SP - na ostatni element w³o¿ony na stos.<br>
I widaæ teraz, ¿e zamiast odwo³ywaæ siê do zmiennych lokalnych poprzez <code>[SP+liczba]</code> przy ci±gle
 zmieniaj±cym siê SP, o wiele wygodniej odwo³ywaæ siê do nich przez <code>[BP-liczba]</code>
 (zauwa¿cie: minus), bo BP pozostaje niezmienione.</P>
<P>
Czêsto na przyk³ad w disasemblowanych programach widaæ instrukcje typu <code><span lang="en">AND</span> SP, NOT 16</code>
 (lub <code> <span lang="en">AND</span> SP, ~16</code> w sk³adni NASM). Jedynym celem takich instrukcji jest
 wyrównanie SP do pewnej po¿±danej granicy, na przyk³ad 16 bajtów (wtedy <code><span lang="en">AND</span></code>
 z warto¶ci± NOT 16, czyli FFFFFFF0h), ¿eby dostêp do zmiennych lokalnych trwa³ krócej.
 Gdy adres
 zmiennej na przyk³ad czterobajtowej jest nieparzysty, to potrzeba dwóch dostêpów do pamiêci, ¿eby j± ca³±
 pobraæ (bo mo¿na pobraæ 32 bity z na raz w procesorze 32-bitowym i tylko z adresu podzielnego przez 4).
</P>
<P>
Ogó³ danych: adres powrotny, parametry funkcji, zmienne lokalne i zachowane rejestry nazywany jest
 czasem <span class="b">ramk± stosu</span> (ang. <span lang="en">stack frame</span>).<br>
  Rejestr BP jest czasem nazywany wska¼nikiem ramki, gdy¿ umo¿liwia od dostêp do
  wszystkich istotnych danych poprzez
 sta³e przesuniêcia (offsety, czyli te liczby dodawane i odejmowane od BP): zmienne
 lokalne s± pod <code>[BP-liczba]</code>, parametry funkcji przekazane z zewn±trz -
 pod <code>[BP+liczba]</code>, za¶ pod <code>[BP]</code> jest stara warto¶æ BP. Je¶li wszystkie
 funkcje w programie zaczynaj± siê tym samym prologiem: <code>PUSH BP / MOV BP, SP</code>, to
 po wykonaniu instrukcji <code>MOV BP, [BP]</code> w BP znajdzie siê wska¼nik ramki ...
 procedury wywo³uj±cej. Je¶li znamy jej strukturê, mo¿na w ten sposób dostaæ siê do jej
 zmiennych lokalnych.</P>

<Hr>
<P>
Zainteresowanych szczegó³ami adresowania lub instrukcjami odsy³am do
<A class="intel_link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" hreflang="en">Intela</A>
lub
<A class="amd_link" href="http://developer.amd.com/Resources/documentation/guides/Pages/default.aspx" hreflang="en">AMD</A></P>
<P>
Nastêpnym razem o podstawowych instrukcjach jêzyka asembler.</P>

<blockquote>- Ilu programistów potrzeba, aby wymieniæ ¿arówkê?<BR>
- Ani jednego. To wygl±da na problem sprzêtowy.</blockquote>

<br><br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="a_kurs01.htm">Poprzednia czê¶æ kursu</a> (Alt+3)<BR>
<a accesskey="4" hreflang="pl" href="a_kurs03.htm">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

<BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL class="dec">
 <LI>Zadeklaruj tablicê 12 zmiennych maj±cych po 10 bajtów:
  <OL class="alfa">
   <LI>zainicjalizowan± na zera (pamiêtaj o ograniczeniach kompilatora)</LI>
   <LI>niezainicjalizowan±</LI>
  </OL>
 <BR></LI>

 <LI>Zadeklaruj tablicê 12 s³ów (16-bitowych) o warto¶ci BB (szesnastkowo), po czym do
	ka¿dego z tych s³ów wpisz warto¶æ FF szesnastkowo (bez ¿adnych pêtli).
	Mo¿na (a nawet trzeba) u¿yæ wiêcej ni¿ 1 instrukcji.
	 Pamiêtaj o odleg³o¶ciach miêdzy
	poszczególnymi elementami tablicy. Naucz siê ró¿nych sposobów adresowania: liczba
	(nazwa zmiennej + numer), baza (rejestr bazowy + liczba), baza + indeks (rejestr
	bazowy + rejestr indeksowy).<BR><BR></LI>

 <LI>Zadeklaruj dwuwymiarow± tablicê bajtów o warto¶ci 0 o wymiarach 13 wierszy na 5 kolumn,
	 po czym do elementu numer 3 (przedostatni) w wierszu o numerze 12 (ostatni) wpisz
	 warto¶æ FF. Spróbuj u¿yæ ró¿nych sposobów adresowania.
	</LI>
</OL>

</BODY></HTML>
