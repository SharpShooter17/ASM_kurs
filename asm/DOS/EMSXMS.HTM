<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: DOS: Pamiêæ EMS i XMS </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Porty szeregowe i równoleg³e">
<META NAME="Keywords" CONTENT="asm, assembler, asembler, DOS, pamiêæ, EMS, XMS">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite/Kate; www.kate-editor.org">
<meta http-equiv="Last-Modified" content="Sun, Jul 10 2016 10:55:48 GMT">
</HEAD><BODY>

<h1 class="nag">Pamiêæ <acronym title="Expanded Memory Specification" lang="en">EMS</acronym> i
<acronym title="Extended Memory Specification" lang="en">XMS</acronym></h1>

<P>
Jak wiemy, programy w trybie 16-bitowym s± ograniczone do jednego megabajta pamiêci,
z której mog± korzystaæ. Dzieje siê tak ze wzglêdu na to, ¿e w trybie 16-bitowym
adres fizyczny otrzymuje siê, mno¿±c zawarto¶æ rejestru segmentowego przez 16
i dodaj±c offset (adres w segmencie), co daje 16 * 65536 = 1<abbr title="megabajt">MB</abbr>.
Wiêcej po prostu fizycznie procesor nie jest w stanie zaadresowaæ. A je¶li nie mo¿na
podaæ adresu wy¿szego ni¿ 1MB, to nie mo¿na tam nic zapisaæ ani odczytaæ.
O strukturze pamiêci pisa³em szerzej w <a href="a_kurs02.htm" hreflang="pl">czê¶ci drugiej</a>
mojego kursu.
</P>
<p>
Jednak na procesorach od 80386 w górê mo¿na adresowaæ wy¿sze obszary pamiêci.
Robi siê to przy u¿yciu menad¿erów pamiêci EMS i XMS.
Te specjalne programy wprowadzaj± procesor w tryb, który umo¿liwia adresowanie
pamiêci w obszarach powy¿ej 1MB, nadal bêd±c w ¶rodowisku 16-bitowym, takim jak DOS.
</p>
<p>
Menad¿ery pamiêci, po uruchomieniu, udostêpniaj± interfejs w postaci przerwañ, z których
mog± korzystaæ programy 16-bitowe. Tym interfejsem siê w³a¶nie zajmiemy.
</p>





<hr>
<h2 class="nag">EMS</h2>
	<BR><a href="#xms" class="bezdruk" tabindex="1">(przeskocz EMS)</a>

<P>
Historycznie, <a href="http://pl.wikipedia.org/wiki/Expanded_Memory_Specification"
hreflang="pl">pamiêæ EMS</a> by³a fizycznym urz±dzeniem, kart± wk³adan± do gniazd rozszerzeñ,
jak karty ISA czy PCI.
</P>
<P>
Wraz ze spadkiem kosztu pamiêci <acronym lang="en" title="Random Access Memory">RAM</acronym>,
pamiêæ EMS zaczê³a byæ emulowana za pomoc±
standardowej pamiêci RAM komputera i tak te¿ pozosta³o - wspó³czesne menad¿ery EMS (jak
<a href="http://www.japheth.de/Jemm.html" hreflang="en">Jemm</a>
czy EMM386) emuluj± dostêp do tych kart rozszerzeñ z pamiêci± i zamiast wysy³aæ ¿±dania
do urz±dzenia, po prostu wykorzystuj± pamiêæ RAM. Aby to dzia³a³o, potrzebny jest jednak
sterownik XMS, który w ogóle umo¿liwia dostêp do wy¿szych adresów.
</P>
<P>
Skoro nie mo¿na bezpo¶rednio dostaæ siê do pamiêci powy¿ej 1MB, trzeba jako¶ taki dostêp
umo¿liwiæ poprzez dostêpn± pamiêæ. W EMS jest to zrealizowane za pomoc± tak zwanej ramki stron.
Jest to segment (czyli 64 kilobajty) pamiêci w obszarze poni¿ej 1MB, który s³u¿y jako bufor
do tymczasowego przechowywania danych kopiowanych do i z EMS.
</P>
<P>
Najmniejsz± jednostk±, któr± mo¿na buforowaæ, jest tak zwana strona pamiêci. Strona pamiêci
ma wielko¶æ 16 kilobajtów, wiêc ramka stron mie¶ci 4 strony fizyczne, do których mapowane
(odwzorowywane) mog± byæ strony logiczne EMS, znajduj±ce siê ju¿ powy¿ej granicy 1MB.
</P>
<P>
Jak wiêc wykorzystaæ pamiêæ EMS w swoim programie? Algorytm jest nastêpuj±cy:
</P>
<ol>
 <li>sprawdziæ, czy sterownik EMS w ogóle jest za³adowany</li>
 <li>pobraæ numer segmentu zawieraj±cego ramkê stron</li>
 <li>opcjonalnie sprawdziæ, czy s± jakie¶ wolne uchwyty pamiêci (podobne do uchwytów plików)</li>
 <li>zaalokowaæ odpowiedni± liczbê logicznych stron pamiêci (w obszarze powy¿ej 1MB)</li>
 <li>zmapowaæ logiczne strony pamiêci (w obszarze powy¿ej 1MB) na fizyczne strony
	znajduj±ce siê w ramce stron (w obszarze poni¿ej 1MB)</li>
 <li>korzystaæ z pamiêci</li>
 <li>zwolniæ pamiêæ EMS (je¶li tego nie zrobimy, pamiêæ bêdzie zaznaczona jako niedostêpna
	dla innych programów a¿ do restartu komputera)</li>
</ol>
<P>
Teraz omówimy te punkty po kolei. Funkcje EMS s± udostêpniane przez przerwanie 67h, a zerowa warto¶æ
rejestru AH po powrocie z wywo³ania oznacza brak b³êdu.
</P>
<ol>
 <li>Sprawdziæ, czy sterownik EMS w ogóle jest za³adowany.<br>
	Robi siê to w prosty sposób:
	<ul>
	 <li>pobieramy numer segmentu zawieraj±cego procedurê obs³ugi przerwania 67h (przerwania EMS)</li>
	 <li>sprawdzamy, czy po 10 bajtach od pocz±tku tego segmentu znajduje siê ci±g znaków EMMXXXX0</li>
	</ul>
	<br><br></li>
 <li>Pobraæ numer segmentu zawieraj±cego ramkê stron.<br>
	Skoro ju¿ wiemy, ¿e sterownik jest za³adowany, mo¿na korzystaæ z przerwania 67h. Do pobrania
	numeru segmentu zawieraj±cego ramkê stron s³u¿y funkcja 41h:
	<ul>
	 <li>ustawiamy AH=41h</li>
	 <li>wywo³ujemy przerwanie 67h</li>
	 <li>po pomy¶lnym wywo³aniu w rejestrze BX bêdzie numer segmentu zawieraj±cego ramkê stron</li>
	</ul>
	<br><br></li>
 <li>Opcjonalnie sprawdziæ, czy s± jakie¶ wolne uchwyty pamiêci (podobne do uchwytów plików).<br>
	Aby obliczyæ liczbê wolnych uchwytów pamiêci EMS, nale¿y od ³±cznej liczby uchwytów
	odj±æ liczbê uchwytów zajêtych. Robi siê to dwoma wywo³aniami:
	<ul>
	 <li>ustawiamy AX=5402h</li>
	 <li>wywo³ujemy przerwanie 67h</li>
	 <li>po pomy¶lnym wywo³aniu w rejestrze BX bêdzie ³±czna liczba uchwytów</li>
	 <li>ustawiamy AH=4Bh</li>
	 <li>wywo³ujemy przerwanie 67h</li>
	 <li>po pomy¶lnym wywo³aniu w rejestrze BX bêdzie liczba u¿ywanych uchwytów</li>
	</ul>
	<br><br></li>
 <li>Zaalokowaæ odpowiedni± liczbê logicznych stron pamiêci (w obszarze powy¿ej 1MB).<br>
	Tê czynno¶æ wykonuje siê jednym wywo³aniem:
	<ul>
	 <li>ustawiamy AH=43h</li>
	 <li>ustawiamy BX na liczbê logicznych stron, które chcemy zaj±æ (zaalokowaæ)</li>
	 <li>wywo³ujemy przerwanie 67h</li>
	 <li>po pomy¶lnym wywo³aniu w rejestrze DX bêdzie uchwyt do przydzielonego nam obszaru</li>
	</ul>
	<br><br></li>
 <li>Zmapowaæ logiczne strony pamiêci (w obszarze powy¿ej 1MB) na fizyczne strony
	znajduj±ce siê w ramce stron (w obszarze poni¿ej 1MB).<br>
	Tê czynno¶æ równie¿ wykonuje siê jednym wywo³aniem:
	<ul>
	 <li>ustawiamy AH=44h</li>
	 <li>ustawiamy AL na numer fizycznej strony w ramce stron, do której chcemy przypisaæ
		logiczn± stronê. Jako ¿e ramka stron mie¶ci tylko 4 strony, AL powinien mieæ
		warto¶æ od 0 do 3.</li>
	 <li>ustawiamy BX na numer logicznej strony, któr± wcze¶niej zaalokowali¶my, a któr±
		chcemy zmapowaæ do fizycznej strony. Strony numerujemy od zera, wiêc BX
		powinien mieæ warto¶æ od 0 do liczby zaalokowanych logicznych stron minus jeden.</li>
	 <li>wpisujemy do DX uchwyt do przydzielonego nam obszaru, z którego maj± byæ brane
		strony logiczne</li>
	 <li>wywo³ujemy przerwanie 67h</li>
	</ul>
	<br><br></li>
 <li>Korzystaæ z pamiêci.<br>
	Tu inwencja zale¿y tylko od twórcy programu. W wiêkszych obszarach pamiêci mo¿na
	przechowywaæ obrazy i d¼wiêki dla gier, inne dane i cokolwiek akurat trzeba.
	<br><br></li>
 <li>Zwolniæ pamiêæ EMS.<br>
	Zwalnianie logicznych stron pamiêci wykonuje siê funkcj± 45h:
	<ul>
	 <li>ustawiamy AH=45h</li>
	 <li>wpisujemy do DX uchwyt do przydzielonego nam obszaru, który chcemy zwolniæ</li>
	 <li>wywo³ujemy przerwanie 67h</li>
	</ul>
	<br><br></li>
</ol>
<P>
Poni¿ej znajduje siê przyk³adowy, gotowy program ilustruj±cy podane wy¿ej funkcjonalno¶ci
(sk³adnia NASM).
</P>
<PRE>
org 100h

start:
	; pobierz segment przerwania sterownika EMS (67h)
	xor	ax, ax
	mov	es, ax
	mov	ds, [es:(67h &lt;&lt; 2) + 2]

	; szukaj znacznika
	mov	si, 10	; DS:SI = adres znacznika w pamiêci
	mov	cx, znacznik_ems_dl
	mov	ax, cs
	mov	es, ax
	mov	di, znacznik_ems	; ES:DI = adres zmiennej
	repe	cmpsb
	je	jest_ems

	mov	ds, ax
	mov	dx, brak_ems
	mov	ah, 9
	int	21h

	mov	ax, 4c01h
	int	21h

jest_ems:
	mov	ds, ax

	; pobieramy segment ramki EMS
	mov	ah, 41h
	int	67h
	test	ah, ah
	jz	mamy_segment

	mov	dx, brak_ramki
	mov	ah, 9
	int	21h

	mov	ax, 4c02h
	int	21h

mamy_segment:
	mov	[segment_ramki], bx

	; sprawd¼ liczbê wolnych uchwytów pamiêci EMS
	mov	ah, 4bh
	int	67h
	test	ah, ah
	jz	mamy_uzywane_uchwyty

	mov	ah, 9
	mov	dx, blad_uchwyty_u
	int	21h

	mov	ax, 4c03h
	int	21h

mamy_uzywane_uchwyty:
	mov	cx, bx	; CX = liczba u¿ywanych uchwytów pamiêci
	mov	ax, 5402h
	int	67h
	test	ah, ah
	jz	mamy_laczne_uchwyty

	mov	ah, 9
	mov	dx, blad_uchwyty
	int	21h

	mov	ax, 4c04h
	int	21h

mamy_laczne_uchwyty:
	; BX = ³±czna liczba uchwytów
	sub	bx, cx	; BX = liczba wolnych uchwytów
	jnz	sa_uchwyty

	mov	ah, 9
	mov	dx, brak_uchwytow
	int	21h

	mov	ax, 4c05h
	int	21h

sa_uchwyty:
	; alokujemy jedn± logiczn± stronê pamiêci
	mov	ah, 43h
	mov	bx, 1
	int	67h
	test	ah, ah
	jz	jest_alokacja

	mov	ah, 9
	mov	dx, blad_alok
	int	21h

	mov	ax, 4c06h
	int	21h

jest_alokacja:
	mov	[uchwyt_pamieci], dx

	; mapujemy logiczn± stronê pamiêci na pierwsz± stronê
	; fizyczn± w ramce pamiêci EMS
	mov	ax, 4400h	; mapuj do zerowej strony fizycznej
	xor	bx, bx		; pierwsza strona logiczna
	;mov	dx, [uchwyt_pamieci]	; DX ju¿ zawiera uchwyt pamiêci
	int	67h
	test	ah, ah
	jz	zapelnij_pamiec

	mov	ah, 9
	mov	dx, blad_mapowanie
	int	21h

	; dealokacja pamiêci
	mov	ah, 45h
	mov	dx, [uchwyt_pamieci]
	int	67h

	mov	ax, 4c07h
	int	21h

zapelnij_pamiec:
	; pamiêæ przydzielona, zape³niamy j±
	mov	ax, [segment_ramki]
	mov	es, ax
	mov	ax, 5a5ah
	mov	cx, 1 &lt;&lt; 12	; CX = 16kB / 4 = 4kB
	xor	di, di
	rep	stosd

	mov	ah, 9
	mov	dx, wszystko_ok
	int	21h

koniec:
	; dealokacja pamiêci
	mov	ah, 45h
	mov	dx, [uchwyt_pamieci]
	int	67h

	mov	ax, 4c00h
	int	21h



uchwyt_pamieci	dw	0
segment_ramki	dw	0
znacznik_ems	db	'EMMXXXX0'
znacznik_ems_dl	equ	$ - znacznik_ems
brak_ems	db	'Brak EMS', 13, 10, '$'
brak_ramki	db	'Nie mozna pobrac ramki EMS', 13, 10, '$'
blad_uchwyty_u	db	'Nie mozna pobrac liczby uzywanych uchwytow', 13, 10, '$'
blad_uchwyty	db	'Nie mozna pobrac lacznej liczby uchwytow', 13, 10, '$'
brak_uchwytow	db	'Brak wolnych uchwytow', 13, 10, '$'
blad_alok	db	'Blad alokacji pamieci', 13, 10, '$'
blad_mapowanie	db	'Blad mapowania pamieci', 13, 10, '$'
wszystko_ok	db	'Wszystko ukonczone prawidlowo', 13, 10, '$'</PRE>


<P>
Wiêcej przyk³adów mo¿na znale¼æ pod adresami:
</P>
<ul>
 <li><a href="http://www.phatcode.net/articles.php?id=155"
	hreflang="en">www.phatcode.net/articles.php?id=155</a></li>
 <li><a href="http://petesqbsite.com/sections/tutorials/zines/chronicles/3-ems.html"
	hreflang="en">petesqbsite.com/sections/tutorials/zines/chronicles/3-ems.html</a></li>
</ul>













<hr>
<h2 class="nag"><a name="xms" id="xms">XMS</a></h2>

<P>
Pamiêæ <a href="http://pl.wikipedia.org/wiki/Extended_Memory_Specification"
hreflang="pl">XMS</a> to po prostu pamiêæ RAM o adresach powy¿ej 1MB.
</P>
<P>
Skoro pamiêæ XMS tak¿e jest po³o¿ona powy¿ej granicy osi±galnej w trybie rzeczywistym,
to tak¿e nie mo¿na siê do
niej bezpo¶rednio odwo³ywaæ. A skoro tak, to tak¿e potrzebny jest do niej sterownik
(menad¿er), taki jak HIMEM.SYS czy <a href="http://www.japheth.de/Jemm.html"
hreflang="en">HimemX</a>. Sterownik taki udostêpnia swoje funkcje,
z których mog± korzystaæ programy.
</P>
<P>
Menad¿ery XMS udostêpniaj± mieszany interfejs - czê¶æ funkcjonalno¶ci udostêpniana
jest przez przerwania, a czê¶æ - poprzez bezpo¶rednie wywo³anie funkcji w obszarze
pamiêci sterownika.
</P>
<P>
Dostêp do pamiêci XMS nie odbywa siê za pomoc± ramek stron, wiec trzeba mieæ przygotowane
w³asne bufory na dane. Oto algorytm wykorzystania pamiêci XMS w swoim programie:
</P>
<ol>
 <li>sprawdziæ, czy sterownik XMS w ogóle jest za³adowany</li>
 <li>pobraæ adres g³ównej funkcji sterownika XMS, z której bêdziemy korzystaæ</li>
 <li>opcjonalnie sprawdziæ, ile jest wolnej pamiêci</li>
 <li>zaalokowaæ odpowiedni± ilo¶æ pamiêci (w obszarze powy¿ej 1MB)</li>
 <li>korzystaæ z pamiêci</li>
 <li>zwolniæ pamiêæ XMS (je¶li tego nie zrobimy, pamiêæ bêdzie zaznaczona jako niedostêpna
	dla innych programów a¿ do restartu komputera)</li>
</ol>
<P>
Teraz omówimy te punkty po kolei. Funkcje XMS s± udostêpniane przez przerwanie 2Fh
oraz przez funkcjê znajduj±c± siê wewn±trz sterownika, a warto¶æ
rejestru AX równa 1 po powrocie z wiêkszo¶ci wywo³añ oznacza brak b³êdu.
</P>
<ol>
 <li>Sprawdziæ, czy sterownik XMS w ogóle jest za³adowany.<br>
	Do tej czynno¶ci s³u¿y funkcja 4300h przerwania 2Fh:
	<ul>
	 <li>ustawiamy AX=4300h</li>
	 <li>wywo³ujemy przerwanie 2Fh</li>
	 <li>po pomy¶lnym wywo³aniu (je¶li sterownik XMS jest dostêpny) w rejestrze AH bêdzie warto¶æ 80h</li>
	</ul>
	<br><br></li>
 <li>Pobraæ adres g³ównej funkcji sterownika XMS, z której bêdziemy korzystaæ.<br>
	W tym celu nale¿y wywo³aæ funkcjê 4310h przerwania 2Fh:
	<ul>
	 <li>ustawiamy AX=4310h</li>
	 <li>wywo³ujemy przerwanie 2Fh</li>
	 <li>po pomy¶lnym wywo³aniu w parze rejestrów ES:BX bêdzie pe³ny adres
		(segment i offset) funkcji obs³uguj±cej XMS, któr± bêdziemy wywo³ywaæ</li>
	</ul>
	<br><br></li>
 <li>Opcjonalnie sprawdziæ, ile jest wolnej pamiêci.<br>
	Do tego s³u¿y czynno¶æ numer 8 funkcji obs³uguj±cej XMS:
	<ul>
	 <li>ustawiamy AH=8</li>
	 <li>wywo³ujemy funkcjê obs³uguj±c± XMS (<span lang="en">CALL FAR</span>!)</li>
	 <li>po pomy¶lnym wywo³aniu w rejestrze DX bêdzie ilo¶æ wolnej pamiêci XMS w kilobajtach</li>
	</ul>
	<br><br></li>
 <li>Zaalokowaæ odpowiedni± ilo¶æ pamiêci (w obszarze powy¿ej 1MB).<br>
	Do alokacji pamiêci s³u¿y czynno¶æ numer 9 funkcji obs³uguj±cej XMS:
	<ul>
	 <li>ustawiamy AH=9</li>
	 <li>ustawiamy DX na liczbê kilobajtów, które chcemy zaalokowaæ</li>
	 <li>wywo³ujemy funkcjê obs³uguj±c± XMS</li>
	 <li>po pomy¶lnym wywo³aniu w rejestrze DX bêdzie uchwyt do przydzielonego nam obszaru</li>
	</ul>
	<br><br></li>
 <li>Korzystaæ z pamiêci.<br>
	W obszarach pamiêci wiêkszych ni¿ ten poni¿ej granicy 1MB mo¿na
	przechowywaæ obrazy i d¼wiêki dla gier, inne dane i cokolwiek akurat trzeba.<br>
	Problem w tym, ¿e skoro w XMS nie ma ramki stron, gdzie mo¿emy sobie mapowaæ pamiêæ,
	trzeba mieæ w³asne bufory oraz sposób przekazania sterownikowi XMS informacji, ¿e
	chcemy przenie¶æ gdzie¶ zawarto¶æ pamiêci.<br>
	Do opisu pojedynczej operacji przenoszenia zawarto¶ci pamiêci s³u¿y taka struktura
	(sk³adnia NASM):
	<pre>
		struc struk_kopia_xms
			dlugosc		resd	1
			uchwyt_zrodla	resw	1
			offset_zrodla	resd	1
			uchwyt_celu	resw	1
			offset_celu	resd	1
		endstruc</pre>
	Pola oznaczaj± kolejno:
	<ul>
	 <li>d³ugo¶æ - liczba bajtów, które chcemy skopiowaæ w tej operacji</li>
	 <li>uchwyt ¼ród³a - uchwyt do pamiêci XMS (otrzymany z alokacji), z którego pobraæ dane.
		Je¶li dane maj± byæ kopiowane z pamiêci konwencjonalnej, nale¿y wstawiæ tu zero.</li>
	 <li>offset ¼ród³a - adres pocz±tkowy w ¼ród³owym obszarze pamiêci, z którego pobieraæ dane.
		Je¶li dane maj± byæ kopiowane z pamiêci konwencjonalnej, nale¿y wstawiæ tu offset
		(w m³odszych dwóch bajtach) i segment (w starszych dwóch bajtach) bufora ¼ród³owego.</li>
	 <li>uchwyt celu - uchwyt do pamiêci XMS (otrzymany z alokacji), do którego skopiowaæ dane.
		Je¶li dane maj± byæ kopiowane do pamiêci konwencjonalnej, nale¿y wstawiæ tu zero.</li>
	 <li>offset celu - adres pocz±tkowy w docelowym obszarze pamiêci, do którego skopiowaæ dane.
		Je¶li dane maj± byæ kopiowane do pamiêci konwencjonalnej, nale¿y wstawiæ tu offset
		(w m³odszych dwóch bajtach) i segment (w starszych dwóch bajtach) bufora ¼ród³owego.</li>
	</ul>
	<br>
	Odpowiednio wype³nion± strukturê przekazujemy do czynno¶ci 0Bh funkcji obs³uguj±cej XMS:
	<ul>
	 <li>ustawiamy AH=0Bh</li>
	 <li>ustawiamy SI na adres wype³nionej struktury, opisanej powy¿ej</li>
	 <li>wywo³ujemy funkcjê obs³uguj±c± XMS</li>
	</ul>
	<br><br></li>
 <li>Zwolniæ pamiêæ XMS.<br>
	Do dealokacji pamiêci s³u¿y czynno¶æ numer 10 funkcji obs³uguj±cej XMS:
	<ul>
	 <li>ustawiamy AH=10</li>
	 <li>ustawiamy DX na uchwyt do przydzielonego nam obszaru, który chcemy zwolniæ</li>
	 <li>wywo³ujemy funkcjê obs³uguj±c± XMS</li>
	</ul>
	<br><br></li>
</ol>
<P>
Poni¿ej znajduje siê przyk³adowy, gotowy program pokazuj±cy wymienione wy¿ej czynno¶ci
(sk³adnia NASM). Zauwa¿cie, ¿e wywo³ania funkcji obs³uguj±cej XMS musz± byæ wywo³aniami dalekimi
(<span lang="en">CALL FAR</span>), gdy¿ znajduje siê ona w innym segmencie.
</P>
<PRE>
org 100h

start:
	; sprawd¼, czy XMS jest zainstalowane
	mov	ax, 4300h
	int	2fh
	cmp	al, 80h
	je	jest_xms

	mov	dx, brak_ster_xms
	mov	ah, 9
	int	21h

	mov	ax, 4c01h
	int	21h

jest_xms:
	; pobierz adres punktu wej¶cia do XMS (funkcji steruj±cej)
	mov	ax, 4310h
	int	2fh
	mov	[funkcja_xms], bx
	mov	[funkcja_xms+2], es

	; sprawd¼ ilo¶æ wolnej pamiêci XMS
	mov	ah, 8
	call	far [funkcja_xms]
	test	dx, dx
	jnz	mamy_pamiec

	mov	ah, 9
	mov	dx, brak_pamieci_xms
	int	21h

	mov	ax, 4c02h
	int	21h

mamy_pamiec:
	; alokujemy pamiêæ równie du¿±, co nasz bufor
	mov	ah, 9
	mov	dx, bufor_dl &gt;&gt; 10	; liczba kilobajtów
	call	far [funkcja_xms]
	cmp	ax, 1
	je	jest_alokacja

	mov	ah, 9
	mov	dx, blad_alok
	int	21h

	mov	ax, 4c03h
	int	21h

jest_alokacja:
	mov	[uchwyt_pamieci], dx

	; pamiêæ przydzielona, zape³niamy j±
	mov	dword [opis_kopiowania + dlugosc], bufor_dl
	mov	word [opis_kopiowania + uchwyt_zrodla], 0	; pamiêæ RAM
	mov	word [opis_kopiowania + offset_zrodla], bufor
	mov	word [opis_kopiowania + offset_zrodla+2], ds
	mov	[opis_kopiowania + uchwyt_celu], dx
	mov	dword [opis_kopiowania + offset_celu], 0
	mov	ah, 0bh
	mov	si, opis_kopiowania
	call	far [funkcja_xms]
	cmp	ax, 1
	je	kopia_ok

	mov	ah, 9
	mov	dx, blad_kopiowanie
	int	21h

	; dealokacja pamiêci
	mov	ah, 10
	mov	dx, [uchwyt_pamieci]
	call	far [funkcja_xms]

	mov	ax, 4c04h
	int	21h

kopia_ok:
	mov	ah, 9
	mov	dx, wszystko_ok
	int	21h

	; dealokacja pamiêci
	mov	ah, 10
	mov	dx, [uchwyt_pamieci]
	call	far [funkcja_xms]

	mov	ax, 4c00h
	int	21h



funkcja_xms		dd	0
uchwyt_pamieci		dw	0
brak_ster_xms		db	'Brak sterownika XMS', 13, 10, '$'
brak_pamieci_xms	db	'Brak wolnej pamieci XMS', 13, 10, '$'
blad_alok		db	'Blad alokacji pamieci', 13, 10, '$'
blad_kopiowanie		db	'Blad kopiowania pamieci', 13, 10, '$'
wszystko_ok		db	'Wszystko ukonczone prawidlowo', 13, 10, '$'

bufor			times	(1 &lt;&lt; 14) db 0
bufor_dl		equ	$ - bufor

struc struk_kopia_xms
	dlugosc		resd	1
	uchwyt_zrodla	resw	1
	offset_zrodla	resd	1
	uchwyt_celu	resw	1
	offset_celu	resd	1
endstruc

opis_kopiowania		istruc struk_kopia_xms</pre>





<P>
Wiêcej przyk³adów mo¿na znale¼æ pod adresami:
</P>
<ul>
 <li><a href="http://petesqbsite.com/sections/tutorials/zines/chronicles/1-xms.html"
	hreflang="en">petesqbsite.com/sections/tutorials/zines/chronicles/1-xms.html</a></li>
 <li><a href="http://computer-programming-forum.com/46-asm/7e08914900e20d5e.htm"
	hreflang="en">computer-programming-forum.com/46-asm/7e08914900e20d5e.htm</a></li>
</ul>






<br><br>
<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
