<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: DOS: Pisanie bootsektorów </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Pisanie bootsektorów w asemblerze">
<META NAME="Keywords" CONTENT="boot, bootsector, bootsektor, assembler, asm, asembler">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Sun, Jul 10 2016 10:55:48 GMT">
</HEAD><BODY>

<h1 class="nag">Pisanie <span lang="en">boot</span>-sektorów</h1>

<P>
Gdy ju¿ choæ ¶rednio znacie asemblera, to po pewnym czasie pojawiaj± siê pytania
 (mog± one byæ spowodowane tym, co us³yszeli¶cie lub Wasz± w³asn± ciekawo¶ci±):</P>
<OL>
 <LI>Co siê dzieje, gdy ma zostaæ uruchomiony jest system operacyjny?</LI>
 <LI>Sk±d <acronym lang="en" title="Basic Input/Output System">BIOS</acronym>
 	ma wiedzieæ, któr± czê¶æ systemu uruchomiæ?</LI>
 <LI>Jak BIOS odró¿nia systemy operacyjne, aby móc je uruchomiæ?</LI>
</OL>
<P>Odpowied¼ na pytanie 2 brzmi: nie wie. Odpowied¼ na pytanie 3 brzmi: wcale. Wszystkie Wasze
w±tpliwo¶ci rozwieje odpowied¼ na pytanie 1.</P>

<P>
Gdy zakoñczy³ siê POST (<span lang="en">Power-On Self Test</span>), wykrywanie dysków i innych urz±dzeñ,
BIOS
przystêpuje do czytania pierwszych sektorów tych urz±dzeñ, na których ma byæ szukany system
operacyjny (u mnie jest ustawiona kolejno¶æ: <acronym lang="en"
title="Compact Disc Read-Only Memory">CD-ROM</acronym>,
 stacja dyskietek, dysk twardy).<BR>
Gdy znajdzie sektor odpowiednio zaznaczony: bajt nr 510 = 55h i bajt 511 = AAh
(pamiêtajmy, ¿e 1 sektor ma 512 bajtów, a liczymy od zera), to wczytuje go pod adres
bezwzglêdny 07C00h i uruchamia kod w nim zawarty (po prostu wykonuje skok pod ten adres). Nie nale¿y
jednak polegaæ na tym, ¿e segment kodu CS = 0, a adres instrukcji IP=7C00h (choæ najczê¶ciej tak jest).
</P>
<P>
 To w³a¶nie <span lang="en">boot</span>-sektor jest odpowiedzialny za ³adowanie odpowiednich czê¶ci w³a¶ciwego systemu
operacyjnego. Na komputerach z wieloma systemami operacyjnymi sprawa te¿ nie jest tak
bardzo skomplikowana. Pierwszy sektor dysku twardego, zwany <span lang="en">Master Boot Record</span>
 (MBR), zawiera program ³aduj±cy (<span lang="en">Boot Manager</span>,
  jak LILO czy GRUB), który z kolei uruchamia <span lang="en">boot</span>-sektor wybranego systemu operacyjnego.
</P>
<P>
My oczywi¶cie nie bêdziemy operowaæ na dyskach twardych, gdy¿ by³oby to niebezpieczne. Z
dyskietkami za¶ mo¿na eksperymentowaæ do woli...<BR>
A instrukcja jest
prosta: umieszczamy nasz programik w pierwszym sektorze dyskietki, zaznaczamy go
odpowiednimi ostatnimi bajtami i tyle. No w³a¶nie... niby proste, ale jak o tym pomy¶leæ
to ani to pierwsze, ani to drugie nie jest spraw± banaln±.
</P>
<P>
Do zapisania naszego <span lang="en">boot</span>sektorka na dyskietkê mo¿emy oczywi¶cie u¿yæ
 <q>gotowców</q> - programów typu <q lang="en">rawwrite</q> itp.
Ma to pewne zalety - program by³ ju¿ u¿ywany przez du¿± liczbê osób, jest sprawdzony i dzia³a.<BR>
Ale co¶ by by³o nie tak, gdybym w kursie programowania w asemblerze kaza³ Wam u¿ywaæ
cudzych programów. Do napisania swojego w³asnego programu zapisuj±cego dany plik w pierwszym
sektorze dyskietki w zupe³no¶ci wystarczy Wam wiedza uzyskana po przeczytaniu czê¶ci mojego
kursu po¶wiêconej operacjom na plikach wraz z t± krótk± informacj± ze
<A HREF="http://www-2.cs.cmu.edu/afs/cs.cmu.edu/user/ralf/pub/WWW/files.html" hreflang="en"
>Spisu Przerwañ Ralfa <span lang="en">Brown</span>'a</A>:</P>
	<BR><a href="#boot_tut01" tabindex="1" class="bezdruk">(przeskocz opis int 13h, ah=3)</a>
<PRE lang="en" title="int 13h, ah=3">
	INT 13 - DISK - WRITE DISK SECTOR(S)
	        AH = 03h
	        AL = number of sectors to write (must be nonzero)
	        CH = low eight bits of cylinder number
	        CL = sector number 1-63 (bits 0-5)
             		high two bits of cylinder (bits 6-7, hard disk only)
        	DH = head number
        	DL = drive number (bit 7 set for hard disk)
        	ES:BX -> data buffer
	Return: CF set on error
	        CF clear if successful</PRE>

<P>Jak widaæ, sprawa ju¿ staje siê prosta. Oczywi¶cie, AL=1 (bo zapisujemy 1 sektor), DX=0 (bo
stacja ma 2 g³owice, a pierwsza ma numer 0, za¶ numer dysku 0 wskazuje stacjê A:), CX=1 (bo
numery sektorów zaczynaj± siê od 1, a zapisujemy w pierwszym cylindrze, który ma numer 0).<BR>
Schemat dzia³ania jest taki:</P>
<UL>
 <LI>Otwórz plik zawieraj±cy skompilowany <span lang="en">boot</span>sektor</LI>
 <LI>Przeczytaj z niego 512 bajtów (do zadeklarowanej tablicy w pamiêci)</LI>
 <LI>Zamknij plik</LI>
 <LI>Zapisz odczytane dane na dyskietce, korzystaj±c z int 13h</LI>
</UL>
<P>Sprawa jest tak prosta, ¿e tym razem nie podam <q>gotowca</q>.</P>

<P>
Gdy ju¿ mamy program zapisuj±cy <span lang="en">boot</span>sektor na dyskietkê, trzeba siê postaraæ o to, aby
nasz programik (który ma staæ siê tym <span lang="en">boot</span>sektorem) mia³ dok³adnie 512 bajtów i aby 2 ostatnie
jego bajty to 55h, AAh.<BR>
Oczywi¶cie, nie bêdziemy rêcznie dok³adaæ tylu bajtów, ile trzeba, aby dope³niæ nasz program
do tych 512. Zrobi to za nas kompilator. Wystarczy po ca³ym kodzie i wszystkich danych, na
szarym koñcu, umie¶ciæ takie co¶ (NASM/FASM):</P>
	<BR><a href="#boot_tut02" class="bezdruk">(przeskocz tworzenie sygnatury)</a>
<PRE>
		times 510 - ($ - start) db 0
		dw 0aa55h</PRE>

<P>Dla TASMa powinno to wygl±daæ mniej-wiêcej tak:</P>
<PRE>
		db 510 - ($ - offset start) dup (0)
		dw 0aa55h
	end start</PRE>

<P><a name="boot_tut02" id="boot_tut02">To wyra¿enie mówi tyle</a>:
 od bie¿±cej pozycji w kodzie odejmij pozycjê pocz±tku kodu (tym
samym obliczaj±c d³ugo¶æ ca³ego kodu), otrzyman± liczbê odejmij od 510 - i do³ó¿ tyle
w³a¶nie bajtów zerowych. Gdy ju¿ mamy program d³ugo¶ci 510 bajtów, to dok³adamy jeszcze
znacznik i wszystko jest dobrze.</P>
<P>
Jest jednak jeszcze jedna sprawa, o której nie wspomnia³em - ustawienie DS i warto¶ci <q>org</q>
dla naszego kodu. Otó¿, je¶li stwierdzimy, ¿e nasz kod powinien zaczynaæ siê od offsetu
0 w naszym segmencie, to ustawmy sobie <q>org 0</q> i DS=07C0h (tak, liczba zer siê zgadza), ale
mo¿emy te¿ mieæ <q>org 7C00h</q> i DS=0. ¯adne z tych nie wp³ywa w ¿aden sposób na d³ugo¶æ
otrzymanego programu, a nale¿y o to zadbaæ, gdy¿ nie mamy gwarancji, ¿e DS bêdzie pokazywa³
na nasze dane po uruchomieniu <span lang="en">boot</span>sektora.
</P>
<P>
Teraz, uzbrojeni w niezbêdn± wiedzê, zasiadamy do pisania kodu naszego <span lang="en">boot</span>sektora. Nie
musi to byæ co¶ wielkiego - tutaj poka¿ê co¶, co w lewym górnym rogu ekranu poka¿e cyfrê jeden
(o bezpo¶redniej manipulacji ekranem mo¿ecie przeczytaæ w moim <a href="tryb_txt.htm"
hreflang="pl">artykule o bezpo¶rednim dostêpie do ekranu</a>) i po naci¶niêciu
dowolnego klawisza zresetuje komputer (na jeden ze sposobów podanych w <a href="pwr_tut.htm" hreflang="pl"
>artykule o zarz±dzaniu zasilaniem</a>).
</P>
<P>Oto nasz kod (<acronym title="Netwide Assembler" lang="en">NASM</acronym>):</P>
	<BR><a href="#boot_tut03" class="bezdruk">(przeskocz przyk³adowy <span lang="en">boot</span>sektor)</a>
<PRE>
	; nasm -o boot.bin -f bin boot.asm

	org 7c00h			; lub &nbsp; &nbsp; &quot;org 0&quot;

	start:
		mov	ax, 0b800h
		mov	es, ax		; ES = segment pamiêci ekranu

		mov	byte [es:0], &quot;1&quot; ; piszemy &quot;1&quot;

		xor	ah, ah
		int	16h		; czekamy na klawisz

		mov	bx, 40h
		mov	ds, bx
		mov	word [ds:72h], 1234h	; 40h:72h = 1234h -
						; wybieramy gor±cy reset

		jmp	0ffffh:0000h		; reset

	times 510 - ($ - start) db 0		; dope³nienie do 510 bajtów
	dw 0aa55h				; znacznik</PRE>

<P><a name="boot_tut03" id="boot_tut03">Nie by³o to d³ugie ani trudne</a>, prawda?
 Rzecz jasna, nie mo¿na w <span lang="en">boot</span>sektorach u¿ywaæ ¿adnych
przerwañ systemowych, na przyk³ad <acronym lang="en" title="Disk Operating System">DOS</acronym>-owego int 21h,
 bo ¿aden system po prostu nie jest uruchomiony i za³adowany.
Tak napisany programik kompilujemy do formatu binarnego. W
<acronym title="Turbo Assembler">TASM</acronym>-ie kompilacja wygl±da³aby jako¶ tak
(po dodaniu w programie dyrektyw <code>.model tiny</code>, <code>.code</code>,
<code>.8086</code> i <code>end start</code>):</P>
<PRE title="kompilacja TASM">
	tasm <span lang="en">boot</span>sec1.asm
	tlink <span lang="en">boot</span>sec1.obj,<span lang="en">boot</span>sec1.bin /t</PRE>

<P>Po kompilacji umieszczamy go na dyskietce przy u¿yciu programu napisanego ju¿ przez nas
wcze¶niej. Resetujemy komputer (i upewniamy siê, ¿e BIOS spróbuje uruchomiæ system z
dyskietki), wk³adamy dyskietkê i.... cieszymy siê swoim dzie³em (co prawda ta jedynka
bêdzie ma³o widoczna, ale rzeczywi¶cie znajduje siê na ekranie).</P>

<P>
Zauwa¿cie te¿, ¿e ani DOS ani <span lang="en">Windows</span>
 nie rozpoznaje ju¿ naszej dyskietki, mimo i¿ przedtem by³a
sformatowana. Dzieje siê tak dlatego, ¿e w <span lang="en">boot</span>sektorze umieszczane s± informacje o dysku.<BR>
<span lang="en">Boot</span>sektor typu FAT12 (DOSowy/Windowsowy) powinien siê zaczynaæ mniej-wiêcej tak:</P>
	<BR><a href="#boot_tut04" class="bezdruk">(przeskocz systemowy obszar <span lang="en">boot</span>sektora)</a>
<PRE title="obszar bootsektora u¿ywany przez system">
	org 7c00h			; lub org 0, oczywi¶cie

	start:
		jmp short kod
		nop

		db &quot;        &quot;	; nazwa OS i wersja OEM (8B)
		dw 512		; bajtów/sektor (2B)
		db 1		; sektory/jednostkê alokacji (1B)
		dw 1		; zarezerwowane sektory (2B)
		db 2		; liczba tablic alokacji (1B)
		dw 224		; liczba pozycji w katalogu g³ównym (2B)
				; 224 to typowa warto¶æ
		dw 2880		; liczba sektorów (2B)
		db 0f0h		; Media Descriptor Byte (1B)
		dw 9		; sektory/FAT (2B)
		dw 18		; sektory/¶cie¿kê (2B)
		dw 2		; liczba g³owic (2B)
		dd 0		; liczba ukrytych sektorów (4B)
		dd 0		; liczba sektorów (czê¶æ 2),
				; je¶li wcze¶niej by³o 0 (4B)
		db 0		; numer dysku (1B)
		db 0		; zarezerwowane (1B)
		db 0		; rozszerzona sygnatura bloku ³aduj±cego
		dd 0bbbbddddh	; numer seryjny dysku (4B)
		db &quot;           &quot;; etykieta (11B)
		db &quot;FAT 12  &quot;	; typ FAT (8B), zwykle  &quot;FAT 12  &quot;

	kod:
		; tutaj dopiero kod bootsektora</PRE>

<P><a name="boot_tut04" id="boot_tut04">Ta porcja danych oczywi¶cie uszczupla</a>
 ilo¶æ kodu, któr± mo¿na umie¶ciæ w <span lang="en">boot</span>sektorze. Nie jest to
jednak du¿y problem, gdy¿ i tak jedyn± rol± wiêkszo¶ci <span lang="en">boot</span>sektorów jest uruchomienie
innych programów (<span lang="en">second stage bootloaders</span>), które dopiero zajmuj± siê ³adowaniem
w³a¶ciwego systemu.</P>

<P>
Jeszcze ciekawostka: co wypisuje BIOS, gdy dysk jest niew³a¶ciwy (bez systemu)?<BR>
Otó¿ - nic! BIOS bardzo chêtnie przeszed³by do kolejnego urz±dzenia.<BR>
Dlaczego wiêc tego nie robi i sk±d ten napis o niew³a¶ciwym dysku systemowym??<BR>
Odpowied¼ jest prosta - sformatowana dyskietka posiada <span lang="en">boot</span>sektor!<BR>
Dla BIOSu jest wszystko OK, uruchamia wiêc ten <span lang="en">boot</span>sektor. Dopiero ten wypisuje informacjê
o niew³a¶ciwym dysku, czeka na naci¶niêcie klawisza, po czym uruchamia int 19h. O tym, co
robi przerwanie 19h mo¿ecie przeczytaæ w <a href="pwr_tut.htm" hreflang="pl">artykule o resetowaniu</a>.</P>
<P>
Mi³ego <span lang="en">boot</span>owania systemu!</P>
<P>
P.S. Je¶li nie chcecie przy najdrobniejszej zmianie kodu resetowaæ komputera, mo¿ecie poszukaæ
w Internecie programów, które symuluj± procesor (w tym fazê ³adowania systemu).
Jednym z takich programów jest <A HREF="http://bochs.sourceforge.net/" hreflang="en">Bochs</a>.</P>







<Br>
<hr>
<h1 class="nag">Co dalej?</h1>

<P>
Mimo i¿ <span lang="en">boot</span>sektor jest ograniczony do 512 bajtów, to mo¿e w do¶æ
 ³atwy sposób pos³u¿yæ do wczytania do pamiêci o wiele wiêkszych programów. Wystarczy u¿yæ
 funkcji czytania sektorów:</P>
	<BR><a href="#boot_tut05" class="bezdruk">(przeskocz opis int 13h, ah=2)</a>
<PRE lang="en" title="int 13h, ah=2">
	INT 13 - DISK - READ SECTOR(S) INTO MEMORY
		AH = 02h
		AL = number of sectors to read (must be nonzero)
		CH = low eight bits of cylinder number
		CL = sector number 1-63 (bits 0-5)
		     high two bits of cylinder (bits 6-7, hard disk only)
		DH = head number
		DL = drive number (bit 7 set for hard disk)
		ES:BX -> data buffer
	Return: CF set on error
		CF clear if successful</PRE>

<P><a name="boot_tut05" id="boot_tut05">Jak widaæ, poza warto¶ci± rejestru AH</a>,
 jej parametry nie ró¿ni± siê od parametrów funkcji zapisu sektorów.<br>
Wystarczy wiêc wybraæ nieu¿ywany segment pamiêci, na przyk³ad ES=8000h i pocz±wszy od offsetu BX=0,
 czytaæ sektory zawieraj±ce nasz kod, zwiêkszaj±c BX o 512 za ka¿dym razem. Kod do za³adowania
 nie musi byæ oczywi¶cie w postaci pliku na dyskietce, to by tylko utrudni³o pracê (gdy¿ trzeba
 wtedy czytaæ tablicê plików FAT).
 Naj³atwiej za³adowaæ kod tym samym sposobem, co
 <span lang="en">boot</span>sektor, ale oczywi¶cie do innych sektorów.
 Polecam zacz±æ od sektora dziesi±tego lub wy¿ej, gdy¿
 zapisanie tam danych nie zama¿e tablicy FAT i przy próbie odczytu zawarto¶ci dyskietki
 przez system nie pojawi± siê ¿adne dziwne obiekty.</P>
<P>
Po za³adowaniu ca³ego potrzebnego kodu do pamiêci przez <span lang="en">boot</span>sektor,
 wystarczy wykonaæ skok:</P>
<pre>	jmp	8000h:0000h</pre>
<P>Wtedy kontrolê przejmuje kod wczytany z dyskietki.</P>
<P>
Ale jest jeden kruczek - trzeba wiedzieæ, jakie numery cylindra, g³owicy i sektora podaæ
 do funkcji czytaj±ce sektory, ¿eby rzeczywi¶cie odczyta³a te w³a¶ciwe.<br>
Struktura standardowej dyskietki jest nastêpuj±ca: 512 bajtów na sektor, 18 sektorów na ¶cie¿kê,
 2 ¶cie¿ki na cylinder (bo s± dwie strony dyskietki, co daje 36 sektorów na cylinder),
 80 cylindrów na g³owicê. Razem 2880 sektorów po 512 bajtów, czyli 1.474.560 bajtów.</P>
<P>
Maj±c numer sektora (bo wiemy, pod jakimi sektorami zapisali¶my swój kod na dyskietce),
 odejmujemy od niego 1 (tak by zawsze wszystkie numery sektorów zaczyna³y siê od zera),
 po czym dzielimy go przez 36. Uzyskany iloraz to numer cylindra (rejestr CH),
 reszta za¶ oznacza numer sektora w tym¿e cylindrze (rejestr CL). Je¶li ta reszta
 jest wiêksza b±d¼ równa 18, nale¿y wybraæ g³owicê numer 1 (rejestr DH), za¶ od numeru
 sektora (rejestr CL) odj±æ 18. W przeciwnym przypadku nale¿y wybraæ g³owicê numer 0 i nie robiæ nic
 z numerem sektora.</P>
<P>W ten sposób otrzymujemy wszystkie niezbêdne dane i mo¿emy bez przeszkód w pêtli czytaæ kolejne
 sektory zawieraj±ce nasz kod.</P>
<P>Ca³± tê procedurê ilustruje ten przyk³adowy kod:</P>
	<BR><a href="#boot_tut06" class="bezdruk">(przeskocz procedurê czytania sektorów)</a>
<pre title="procedura czytania sektorów">
secrd:
;wej¶cie: ax=sektor, es:bx wskazuje na dane

	dec ax		; z numerów 1-36 na 0-35
	mov cl,36	; liczba sektorów na cylinder = 36
	xor dx,dx	; zak³adamy na pocz±tek: g³owica 0, dysk 0 (a:)
	div cl		; AX (numer sektora) dzielimy przez 36
	mov ch,al	; AL=cylinder, AH=przesuniêcie wzglêdem
			;	pocz±tku cylindra, czyli sektor
	cmp ah,18	; czy numer sektora mniejszy od 18?
	jb .sec_ok	; je¶li tak, to nie robimy nic
	sub ah,18	; je¶li nie, to odejmujemy 18
	inc dh		; i zmieniamy g³owicê
.sec_ok:
	mov cl, ah	; CL = numer sektora
	mov ax,0201h	; odczytaj 1 sektor
	inc cl		; zwiêksz z powrotem z zakresu 0-17 do 1-18

	push dx		; niektóre biosy niszcz± DX, nie ustawiaj±
			;	flagi CF, lub zeruj± flagê IF
	stc
	int 13h		; wykonaj czytanie
	sti
	pop dx</pre>






<br><br>
<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="../index.htm" name="boot_tut06" id="boot_tut06">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>


</BODY></HTML>
