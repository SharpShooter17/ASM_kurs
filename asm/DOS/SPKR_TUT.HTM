<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: DOS: Programowanie g³o¶niczka </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="PC Speaker - programowanie">
<META NAME="Keywords" CONTENT="PC Speaker, g³o¶niczek, asm, assembler, asembler">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Sun, Jul 10 2016 10:55:49 GMT">
</HEAD><BODY>

<h1 class="nag">Programowanie g³o¶niczka w asemblerze</h1>


<P>
Czy nie my¶licie czasem, jakby to by³o, gdyby mo¿na by³o wzbogaciæ swój
program oprócz efektu wizualnego, tak¿e o efekt d¼wiêkowy?<BR>
Programowanie kart d¼wiêkowych (zw³aszcza tych nowoczesnych) mo¿e sprawiaæ
niema³e k³opoty. Stary, poczciwy <span lang="en">PC-Speaker</span> jest jednak urz±dzeniem wzglêdnie
prostym w programowaniu i to w³a¶nie tutaj udowodniê. Najpierw troszkê teorii, potem - do dzie³a!
</P>
<P>
Sporo urz±dzeñ w komputerze ma w³asne porty, przez które mo¿na siê
z nimi komunikowaæ. Jednak g³o¶niczek komputerowy nie ma w³asnego
portu.<BR>
 Jest tak przede wszystkim ze wzglêdu na oszczêdno¶ci w budowie
pierwszych PC-tów. Zamiast daæ osobny port na g³o¶nik, firmy
produkuj±ce komputery wcisnê³y go <q>pod opiekê</q> dwóch innych urz±dzeñ:</P>
<UL>
 <LI>czasomierza systemowego, który pos³u¿y nam do wytworzenia impulsów
  odpowiedniej czêstotliwo¶ci<BR><BR></LI>
 <LI>kontrolera klawiatury, który kontroluje, czy jest otwarty <q>kana³</q> z
  czasomierza do g³o¶niczka, czyli czy mo¿na bêdzie wysy³aæ informacje.<BR><BR></LI>
</UL>
<P>Podstawowe porty czasomierza to porty od 40h do 43h (ca³y zakres to
40h - 5fh, <q>h</q> oznacza <q>szesnastkowo</q>), kontrolera klawiatury za¶ - 60h do 64h
(ca³y zakres: 60h - 6fh).<BR>
 Nie bêdziemy ich jednak wszystkich u¿ywaæ. Bêd± na interesowaæ tylko
porty 42h, 43h i 61h.</P>


<P> Zacznijmy wiêc co¶ pisaæ:</P>
<PRE>	in al,61h
	or al,3
	out 61h,al</PRE>

<P> Co zrobili¶my? W spisie portów
<A HREF="http://www-2.cs.cmu.edu/afs/cs.cmu.edu/user/ralf/pub/WWW/files.html"
 hreflang="en">Listy Przerwañ Ralfa <span lang="en">Brown</span>'a</A> czytamy:<BR></P>
	<BR><a href="#spkr_tut01" tabindex="1" class="bezdruk">(przeskocz port 61h)</a>
<PRE lang="en" title="port 61h">
	0061  R-  KB controller port B control register (ISA, EISA)
	0061  -W  KB controller port B (ISA, EISA)

	(R - czytanie (read) , W - pisanie (write))</PRE>

<P><a name="spkr_tut01" id="spkr_tut01">oraz</a>:</P>
	<BR><a href="#spkr_tut02" class="bezdruk">(przeskocz opis portu 61h)</a>
<PRE lang="en" title="opis portu 61h">
	Bitfields for KB controller port B (system control port) [output]:
	Bit(s)  Description     (Table P0392)
	 7      pulse to 1 for IRQ1 reset (PC,XT)
	 6-4    reserved
	 3      I/O channel parity check disable
	 2      RAM parity check disable
	 1      speaker data enable
	 0      timer 2 gate to speaker enable</PRE>

<P>
 <a name="spkr_tut02" id="spkr_tut02">Komenda <CODE>IN AL,61h</CODE></a>
  czyta bie¿±cy status kontrolera, <CODE>OR AL,3</CODE> ustawia
(w³±cza) bity 0 (w³±czenie bramki do g³o¶niczka) oraz 1 (w³±czenie
mo¿liwo¶ci wysy³ania danych do g³o¶niczka), <CODE>OUT 61h,AL</CODE> zapisuje
nowy status do kontrolera.</P>

<P>G³o¶niczek jest w³±czony. Trzeba mu podaæ jaki¶ sygna³. Do tego pos³u¿y
nam czasomierz. W spisie portów czytamy:</P>
	<BR><a href="#spkr_tut03" class="bezdruk">(przeskocz opis portów 42h i 43h)</a>
<PRE lang="en" title="porty 42h i 43">
	0042  RW  PIT  counter 2, cassette &amp; speaker

	0043  RW  PIT  mode port, control word register for counters 0-2
	    Once a control word has been written (43h), it must be followed
	    immediately by performing the corresponding action to the counter
	    registers (40h-42h), else the system may hang!!</PRE>


<P>
<a name="spkr_tut03" id="spkr_tut03">Do portów tych nie bêdziemy wysy³aæ</a> jednak
czêstotliwo¶ci, któr± chcemy uzyskaæ. Czasomierz pracuje na czêstotliwo¶ci 1193181 (1234DDh)
<abbr title="Hertz">Hz</abbr> i to tê warto¶æ dzielimy przez ¿±dan± czêstotliwo¶æ, a wynik wysy³amy
do odpowiednich portów.</P>

<P>Piszmy wiêc:</P>
	<BR><a href="#spkr_tut04" class="bezdruk">(przeskocz w³±czanie g³o¶niczka)</a>
<PRE title="w³±czenie g³o¶niczka na nutê A">
	mov bx,440h	; Standardowy d¼wiêk A, 440 Hz
	mov dx,12h	; górna czê¶æ liczby 1234dd
	mov ax,34ddh	; dolna czê¶æ liczby 1234dd
	div bx		; ax = warto¶æ do wys³ania

	pushf		; zachowaj flagi
	push ax		; zachowaj warto¶æ do wys³ania
	cli		; wy³±cz przerwania
	mov al,0b6h
	out 43h,al	; wy¶lij komendê

	pop ax
	out 42h,al	; wy¶lij pierwsz± po³owê licznika
	mov al,ah
	out 42h,al	; wy¶lij drug± po³owê licznika
	popf		; przywróæ stan flagi przerwañ
	</PRE>

<P>
 <a name="spkr_tut04" id="spkr_tut04">No i co my tutaj znowu zrobili¶my?</a><BR>
 4 pierwsze komendy to oczywi¶cie uzyskanie warto¶ci do wys³ania na port,
ale reszta?<BR>
<P>Najpierw: 0b6h = 1011 0110<BR><br>

Bity 7 i 6 = 10 = wybierz (standardowo niezajêty) czasomierz nr 2
   (³±cznie s± 3: zegar czasu rzeczywistego, czasomierz od¶wie¿ania
     pamiêci RAM i ten trzeci, nieu¿ywany)<BR>
Bity 5 i 4 = 11 = zapisujemy do czasomierza najpierw m³odsze bity (0-7)
     warto¶ci, potem starsze (8-15)<BR>
Bity 3-1   = 011 = wybierz tryb nr 3, czyli generator fali kwadratowej<BR>
Bit 0      = 0   = licznik binarny 16-bitowy.<BR>

</P>
<P>Zgodnie z tym, najpierw wysy³amy m³odszy bajt, AL a potem starszy, AH.</P>

<P>
 Skoro na port mo¿na wys³aæ najwiêksz± warto¶æ 0ffffh (teoretycznie
najwiêksza jest 10000h, obcinana do 0000h), to jakiej odpowiada to
czêstotliwo¶ci?<BR>
 1234dd / 10000h to ok. 12h, czyli 18. A dok³adniej jest to co¶ oko³o
18,2 Hz - standardowa czêstotliwo¶æ zegara w komputerze (aby
odmierzyæ 1 sekundê trzeba ok 18 tykniêæ tego zegara)</P>

 <P>Nasz g³o¶niczek ju¿ gra. Teraz trzeba sprawiæ, bo to troszkê potrwa³o.
Pomocne bêdzie przerwanie 15h, funkcja 86h:</P>
<PRE>	mov cx,0fh
	mov dx,4240h
	mov ah,86h
	int 15h			; pauza o d³ugo¶ci CX:DX mikrosekund</PRE>

<P>
 I d¼wiêk trwa 1 sekundê (F4240h = 1.000.000). Teraz trzeba go
wy³±czyæ. Nic prostszego. Po prostu zamkniemy przej¶cie miêdzy
czasomierzem a g³o¶niczkiem:</P>
<PRE>	in al,61h
	and al,not 3		; zerujemy bity 0 i 1
				; NASM:  &quot;and al,~3&quot;
	out 61h,al</PRE>

<P>
Mam nadziejê, ¿e poda³em wystarczaj±co informacji, aby¶cie samodzielnie zaczêli programowaæ
g³o¶niczek. Je¶li mi siê nie uda³o, to zawsze mo¿ecie skorzystaæ z gotowej procedury z mojej
biblioteki.
</P>
<P>
To ju¿ koniec. Mi³ej zabawy!</P>

<br><br>
<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
