<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: DOS, czê¶æ 5 - Koprocesor </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Prev"     hreflang="pl" lang="en" href="a_kurs04.htm">
<link rel="Next"     hreflang="pl" lang="en" href="a_kurs06.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, FPU, NPX, NPU, ONP, RPN, float,
	koprocesor, st(0), finit, BCD">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Sun, Jul 10 2016 10:55:47 GMT">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler?<BR>
	<h1 class="nag">Czê¶æ 5 - Koprocesor, czyli jak liczyæ na u³amkach.
	 Odwrotna Notacja Polska</h1></div>

<P>Jak zapewne wiêkszo¶æ wie, koprocesor (FPU = Floating Point Unit, NPX = Numerical Processor
eXtension) s³u¿y do wykonywania dzia³añ matematycznych. Podstawowy procesor te¿ oczywi¶cie
wykonuje dzia³ania matematyczne (dodawanie, mno¿enie, ...) ale tylko na liczbach ca³kowitych.
Z czasem jednak przysz³a potrzeba wykonywania obliczeñ na liczbach nieca³kowitych, czyli u³amkach
(liczbach zmiennoprzecinkowych). Dlatego firmy produkuj±ce procesory zaczê³y je wyposa¿aæ
w³a¶nie w uk³ady wspomagaj±ce pracê na u³amkach. Do procesorów 8086, 80286, 80386 by³y do³±czane
jako osobne uk³ady koprocesory: 8087, 80287, 80387 (80187 nie wprowadzi³ ¿adnych istotnych
nowo¶ci. By³a to przeróbka 8087, a mo¿e nawet by³ to po prostu ten sam uk³ad). Procesory
486SX mia³y jeszcze oddzielny koprocesor (80387) a od 486DX (w ka¿dym razie u Intela)
koprocesor by³ ju¿ na jednym chipie z procesorem. I tak jest do dzi¶.</P>

<P>Ale do¶æ wstêpu. Pora na szczegó³y.</P>

<HR>
<h2 class="nag">Typy danych</h2>

<P>Zanim zaczniemy cokolwiek robiæ, trzeba wiedzieæ, na czym
ten ca³y koprocesor operuje.<BR>
Oprócz liczb ca³kowitych, FPU operuje na liczbach u³amkowych ró¿nej precyzji:</P>
<UL>
 <LI>Pojedyncza precyzja. Liczby takie zajmuj± po 32 bity (4 bajty) i ich warto¶æ maksymalna
	wynosi ok. 10<SUP>39</SUP> (10^39). Znane s± programistom jêzyka C jako <q lang="en">float</q>.</LI>
 <LI>Podwójna precyzja. 64 bity (8 bajtów), max = ok. 10<SUP>409</SUP> (10^409). W jêzyku C s± znane
	jako <q lang="en">double</q></LI>
 <LI>Rozszerzona precyzja. 80 bitów (10 bajtów), max = ok. 10<SUP>4930</SUP> (10^4930). W jêzyku C s± to
	<q lang="en">long double</q></LI>
</UL>
<P>Jak widaæ, ilo¶ci bitów s± oczywi¶cie skoñczone. Wiêc nie ka¿d± liczbê rzeczywist± da siê
dok³adnie zapisaæ w postaci binarnej. Na przyk³ad, jedna dziesi±ta (0.1) zapisana dwójkowo jest
u³amkiem nieskoñczonym okresowym! Poza tym, to, czego nas uczyli na matematyce, na przyk³ad oczywista
równo¶æ: a+(b-a)=b nie musi byæ prawd± w ¶wiecie u³amków w procesorze ze wzglêdu na brak
precyzji!
</P>
<P>
Poza u³amkami, FPU umie operowaæ na BCD (<span lang="en">binary coded decimal</span>).
 W takich liczbach 1 bajt dzieli siê
na 2 czê¶ci po 4 bity, z których ka¿da mo¿e mieæ warto¶æ 0-9. Ca³y bajt reprezentuje wiêc liczby
od 0 do 99, w których cyfra jedno¶ci jest w m³odszych 4 bitach a cyfra dziesi±tek - w starszych
4 bitach.</P>
<P>
Szczegó³ami zapisu liczb u³amkowych nie bêdziemy siê tutaj zajmowaæ. Polecam, tak jak poprzednio:
<A class="intel_link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" tabindex="1" hreflang="en">strony Intela</A>
i <A class="amd_link" href="http://developer.amd.com/Resources/documentation/guides/Pages/default.aspx" hreflang="en">strony <acronym title="Advanced Micro Devices" lang="en">AMD</acronym></A>,
gdzie znajduje siê te¿ kompletny opis wszystkich instrukcji procesora i koprocesora.</P>




<BR><HR>
<h2 class="nag">Rejestry koprocesora</h2>
<P>
Po zapoznaniu siê z typami (a przede wszystkim z rozmiarami) liczb u³amkowych, powstaje pytanie:
gdzie koprocesor przechowuje takie ilo¶ci danych?<BR>
FPU ma specjalnie do tego celu przeznaczonych 8 rejestrów, po 80 bitów ka¿dy. W operacjach
wewnêtrznych (bez pobierania lub zapisywania danych do pamiêci) FPU zawsze u¿ywa
rozszerzonej precyzji.</P>
<P> Rejestry danych nazwano st(0), st(1), ... , st(7) (NASM: st0 ... st7). Nie dzia³aj± jednak
one tak, jak zwyk³e rejestry, lecz jak ... stos! To znaczy, ¿e dowolnie dostêpna jest tylko
warto¶æ ostatnio po³o¿ona na stosie czyli wierzcho³ek stosu, w tym przypadku: st(0). Znaczy to,
¿e do pamiêci (FPU operuje tylko na w³asnych rejestrach lub pamiêci - nie mo¿e u¿ywaæ rejestrów
ogólnego przeznaczenia na przyk³ad EAX itp.) mo¿e byæ zapisana tylko warto¶æ z st(0), a ka¿da warto¶æ
pobierana z pamiêci idzie do st(0) a stare st(0) przesuwa siê do st(1) itd. ka¿dy rejestr
przesuwa siê o 1 dalej. Je¿eli brakuje na to miejsca, to FPU mo¿e wygenerowaæ przerwanie
(wyj±tek) a rejestry danych bêd± prawdopodobnie zawieraæ ¶mieci.</P>
<P>Operowanie na rejestrach FPU bêdzie wymaga³o nieco wiêcej uwagi ni¿ na zwyk³ych, ale i do tego
mo¿na siê przyzwyczaiæ.</P>





<BR><HR>
<h2 class="nag">Instrukcje koprocesora</h2>
<P>
Zacznijmy od omówienia kilku podstawowych instrukcji. Przez [mem] bêdê nazywa³ dane bêd±ce
w pamiêci (32-, 64- lub 80-bitowe, <q>int</q> oznacza liczbê ca³kowit±), <q>st</q> jest czêstym skrótem
od <q>st(0)</q>. Je¿eli komenda koñczy siê na P to oznacza, ¿e zdejmuje dane raz ze stosu, PP
oznacza, ¿e zdejmuje 2 razy: st(0) i st(1).</P>
<OL>
 <LI>Instrukcje przemieszczenia danych:
  <UL>
   <LI><code>FLD/FILD [mem]</code> - za³aduj liczbê rzeczywist±/ca³kowit± z pamiêci. Dla liczby rzeczywistej
	jest to 32, 64 lub 80 bitów. Dla ca³kowitej - 16, 32 lub 64 bity.</LI>
   <LI><code>FST [mem32/64/80]</code> - do pamiêci idzie liczba ze st(0).</LI>
   <LI><code>FSTP [mem32/64/80]</code> - zapisz st(0) w pamiêci i zdejmij je ze stosu. Znaczy
	 to tyle, ¿e st(1) o ile istnieje, staje siê st(0) itd. ka¿dy rejestr cofa siê o 1.</LI>
   <LI><code>FIST [mem16/32]</code> - ewentualnie obciêt± do ca³kowitej liczbê z st(0) zapisz do pamiêci.</LI>
   <LI><code>FISTP [mem16/32/64]</code> - jak wy¿ej, tylko ze zdjêciem ze stosu.</LI>
   <LI><code>FXCH st(i)</code> - zamieñ st(0) z st(i).</LI>
  </UL><BR></LI>
 <LI>Instrukcje ³adowania sta³ych
  <UL>
   <LI><code>FLDZ</code> - za³aduj zero. st(0) = 0.0</LI>
   <LI><code>FLD1</code> - za³aduj 1. st(0) = 1.0</LI>
   <LI><code>FLDPI</code> - za³aduj pi.</LI>
   <LI><code>FLDL2T</code> - za³aduj log2(10)</LI>
   <LI><code>FLDL2E</code> - za³aduj log2(e)</LI>
   <LI><code>FLDLG2</code> - za³aduj log(2)=log10(2)</LI>
   <LI><code>FLDLN2</code> - za³aduj ln(2)</LI>
  </UL><BR></LI>
 <LI>Dzia³ania matematyczne:
  <UL>
   <LI>dodawanie: <code>FADD</code>, sk³adnia identyczna jak w odejmowaniu prostym<BR><BR>
   <LI>odejmowanie:<BR>
     <UL>
	<LI><code>FSUB [mem32/64]</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := st-[mem] </LI>
	<LI><code>FSUB st(0),st(i)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := st-st(i)</LI>
	<LI><code>FSUB st(i),st(0)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(i) := st(i)-st(0)</LI>
	<LI><code>FSUBP st(i), st(0)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(i) := st(i)-st(0) i zdejmij</LI>
	<LI><code>FSUBP</code> (bez argumentów) = <code>FSUBP st(1),st(0)</code></LI>
	<LI><code>FISUB [mem16/32int]</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := st-[mem]</LI>
     </UL>
	<BR></LI>
   <LI>odejmowanie odwrotne:<BR>
     <UL>
	<LI><code>FSUBR [mem32/64]</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := [mem]-st(0)</LI>
	<LI><code>FSUBR st(0),st(i)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := st(i)-st(0)</LI>
	<LI><code>FSUBR st(i),st(0)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(i) := st(0)-st(i)</LI>
	<LI><code>FSUBRP st(i),st(0)</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(i) := st(0)-st(i) i zdejmij</LI>
	<LI><code>FSUBRP</code> (bez argumentów) = <code>FSUBRP st(1),st(0)</code></LI>
	<LI><code>FISUBR [mem16/32int]</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st := [mem]-st</LI>
     </UL>
	<BR></LI>
   <LI>mno¿enie: <code>FMUL</code>, sk³adnia identyczna jak w odejmowaniu prostym.<BR><BR></LI>
   <LI>dzielenie: <code>FDIV</code>, sk³adnia identyczna jak w odejmowaniu prostym.</LI>
   <LI>dzielenie odwrotne: <code>FDIVR</code>, sk³adnia identyczna jak w odejmowaniu odwrotnym.<BR><BR></LI>
   <LI>warto¶æ bezwzglêdna: <code>FABS</code> (bez argumentów) zastêpuje st(0) jego warto¶ci± bezwzglêdn±.</LI>
   <LI>zmiana znaku: <code>FCHS</code>: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(0) := -st(0).</LI>
   <LI>pierwiastek kwadratowy: <code>FSQRT</code>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(0) := SQRT[ st(0) ]</LI>
   <LI>reszty z dzielenia: <code>FPREM</code>, <code>FPREM1</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(0) := st(0) mod st(1).</LI>
   <LI>zaokr±glanie do liczby ca³kowitej: <code>FRNDINT</code>: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;st(0) := (int)st(0).</LI>
  </UL>
  <BR></LI>
 <LI>Komendy porównania:<BR>
     - <code>FCOM/FCOMP/FCOMPP</code>, <code>FUCOM/FUCOMP/FUCOMPP</code>, <code>FICOM/FICOMP</code>,
	<code>FCOMI/FCOMIP</code>, <code>FUCOMI/FUCOMIP</code>, <code>FTST</code>, <code>FXAM</code>.<BR>
	<P>Tutaj trzeba trochê omówiæ sytuacjê. FPU oprócz rejestrów danych zawiera tak¿e rejestr
	kontrolny (16 bitów) i rejestr stanu (16 bitów).<BR> W rejestrze stanu s± 4 bity nazwane
	C0, C1, C2 i C3. To one wskazuj± wynik ostatniego porównania, a uk³ad ich jest taki sam,
	jak flag procesora, co pozwala na ich szybkie przeniesienie do flag procesora.
 	Aby odczytaæ wynik porównania, nale¿y zrobiæ takie co¶:</P>
	<PRE>
	fcom
	fstsw	ax	; tylko od 386. Inaczej:
			; fstsw word ptr [zmienna] / mov ax,[zmienna]
	sahf		; AH -&gt; flagi</PRE>
	<P>i u¿ywaæ normalnych komend JE, JB itp.</P>
     <UL>
	<LI><code>FCOM st(n)/[mem]</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) z st(n)
		(lub zmienn± w pamiêci) bez zdejmowania st(0) ze stosu FPU</LI>
	<LI><code>FCOMP st(n)/[mem]</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) z st(n)
		(lub zmienn± w pamiêci) i zdejmij st(0)</LI>
	<LI><code>FCOMPP</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) z st(1) i
		zdejmij oba ze stosu</LI>
	<LI><code>FICOM [mem]</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) ze
		zmienn± ca³kowit± 16- lub 32-bitow± w pamiêci</LI>
	<LI><code>FICOMP [mem]</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) ze
		zmienn± ca³kowit± 16- lub 32-bitow± w pamiêci, zdejmij st(0)</LI>
	<LI><code>FCOMI st(0), st(n)</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) z st(n) i ustaw flagi
		 <em class="wazne">procesora</em>, nie tylko FPU</LI>
	<LI><code>FCOMIP st(0), st(n)</code> - &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; porównaj st(0) z st(n) i ustaw flagi
		 <em class="wazne">procesora</em>, nie tylko FPU, zdejmij st(0)</LI>
     </UL>
	<P>Komendy koñcz±ce siê na I lub IP zapisuj± swój wynik bezpo¶rednio do flag procesora. Mo¿na tych
	flag od razu u¿ywaæ (<code>JZ</code>, <code>JA</code>, ...). Te komendy s± dostêpne tylko od 386.</P>

	<P><code>FTST</code> porównuje st(0) z zerem.</P>
	<P><code>FXAM</code> bada, co jest w st(0) - prawid³owa liczba, b³±d (NaN =
	<span lang="en">Not a Number</span>), czy 0.</P>
	</LI>
  <LI>Instrukcje trygonometryczne:<BR>
     <UL>
	<LI><code>FSIN</code> - st(0) := sinus [st(0)]</LI>
	<LI><code>FCOS</code> - st(0) := kosinus [st(0)]</LI>
	<LI><code>FSINCOS</code> - st(0) := kosinus [st(0)], st(1) := sinus [st(0)]</LI>
	<LI><code>FPTAN</code> - <span lang="en">partial tangent</span> = tangens st(0) := tg [st(0)]</LI>
	<LI><code>FPATAN</code> - <span lang="en">arcus</span> tangens st(0) := arctg [st(0)]</LI>
     </UL>
    <BR></LI>
  <LI>Logarytmiczne, wyk³adnicze:<BR>
   <UL>
    <LI><code>FYL2X</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(1) := st(1)*log2[st(0)] i zdejmij</LI>
    <LI><code>FYL2XPI</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(1) := st(1)*log2[ st(0) + 1.0 ] i zdejmij </LI>
    <LI><code>F2XM1</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; st(0) := 2^[st(0)] - 1</LI>
   </UL><BR></LI>
  <LI>Instrukcje kontrolne:
   <UL>
    <LI><code><span class="b">FINIT/FNINIT</span></code> - inicjalizacja FPU. Litera N po F oznacza,
    	 aby nie braæ po uwagê potencjalnych nieza³atwionych wyj±tków.</LI>
    <LI><code>FLDCW</code>, <code>FSTCW/FNSTCW</code> - <span lang="en">Load/Store control word</span>
    	 - zapisuje 16 kontrolnych bitów do pamiêci,
	gdzie mo¿na je zmieniaæ na przyk³ad aby zmieniæ sposób zaokr±glania liczb.</LI>
    <LI><code>FSTSW/FNSTSW</code> - zapisz do pamiêci (lub rejestru AX) s³owo statusu, czyli stan FPU</LI>
    <LI><code>FCLEX/FNCLEX</code> - wyczy¶æ wyj±tki</LI>
    <LI><code>FLDENV</code>, <code>FSTENV/FNSTENV</code> - wczytaj/zapisz ¶rodowisko (rejestry stanu,
	kontrolny i kilka innych, bez rejestrów danych). Wymaga 14 albo 28 bajtów pamiêci, w zale¿no¶ci
	 od trybu pracy procesora (rzeczywisty - DOS lub chroniony - <span lang="en">Windows</span>/Linux).</LI>
    <LI><code>FRSTOR</code>, <code>FSAVE/FNSAVE</code> - jak wy¿ej, tylko ¿e z rejestrami danych. Wymaga 94
	lub 108 bajtów w pamiêci, zale¿nie od trybu procesora.</LI>
    <LI><code>FINCSTP</code>, <code>FDECSTP</code> - zwiêksz/zmniejsz wska¼nik stosu - przesuñ st(0)
	na st(7), st(1) na st(0) itd. oraz w drug± stronê, odpowiednio.</LI>
    <LI><code>FFREE</code> - zwolnij podany rejestr danych</LI>
    <LI><code>FNOP</code> - no operation. Nic nie robi, ale zabiera czas.</LI>
    <LI><code>WAIT/FWAIT</code> - czekaj, a¿ FPU skoñczy pracê. U¿ywane do synchronizacji z CPU.</LI>
   </UL><BR><BR></LI>
</OL>






<HR>
<h2 class="nag">Przyk³ady</h2>

<P>Do¶æ ju¿ teorii, pora na przyk³ady. Programiki te wymy¶li³em pisz±c ten kurs.
</P>
<P>Przyk³ad 1 (bêdzie to program typu .exe, bo dodamy moj± bibliotekê do wy¶wietlania wyników):</P>

<BR><a href="#a_kurs0501" class="bezdruk">(przeskocz program wy¶wietlaj±cy czêstotliwo¶æ zegara)</a>
<PRE title="program wy¶wietlaj±cy czêstotliwo¶æ zegara">
; TASM:
; z wy¶wietlaniem:
;   tasm naszplik.asm
;   tlink naszplik.obj bibl\lib\bibldos.lib
; bez wy¶wietlania:
;   tasm naszplik.asm
;   tlink naszplik.obj

.model small
.stack 400h			; stos dla programu .exe
.data

dzielna		DQ 1234DDh	; 4013 91a6 e800 0000 0000
dzielnik	DQ 10000h
iloraz		DT ?

.code

; je¶li nie chcesz wy¶wietlania, usuñ tê linijkê ni¿ej:
 include incl\std_bibl.inc

start:
	mov	ax, @data
	mov	ds, ax
	mov	es, ax		; konieczne w programie typu .exe !
				; ¯ycie przestaje byæ
				; wygodne. DOS ju¿ nam nie ustawi
				; DS=ES=CS. A nasze dane s± w
				; segmencie kodu, stad ustawiamy DS=CS
				; W programie typu .com to na pewno
				; nie zaszkodzi.

	finit			; zawsze o tym pamiêtaj !

	fild	qword ptr [dzielna]	; ³adujemy dzieln±. st(0) = 1234DD
	fild	qword ptr [dzielnik]	; ³adujemy dzielnik. st(0) = 10000h,
					; st(1) = 1234DD
	fdivp				; dzielimy. st(1) := st(1)/st(0) i
					; zdejmij. st(0) ~= 18.2
	fstp	tbyte ptr [iloraz]	; zapisujemy st(0) do pamiêci i
					; zdejmujemy ze stosu

; je¶li nie chcesz wy¶wietlania, usuñ te 3 linijki ni¿ej:
	mov	di, offset iloraz ; DI=adres zmiennej zawieraj±cej wynik
	piszd80			  ; wy¶wietl wynik
	nwln			  ; przejd¼ do nowej linii

	mov	ax, 4c00h
	int	21h

end start</PRE>
<Hr>

<P><a name="a_kurs0501" id="a_kurs0501">Teraz wersja dla NASMa</a>. O tym, jak NASMem zrobiæ program typu
.exe napisane jest w jego <A HREF="http://sourceforge.net/projects/nasm" hreflang="en">dokumentacji</a>.
 Wymaga to przede wszystkim stworzenia w³asnego segmentu
stosu i nakierowanie na niego rejestrów SS:SP. Trzeba mieæ te¿ odpowiedni linker, na przyk³ad VAL.
Mo¿na jednak u¿yæ jednego z plików do³±czonych do mojej biblioteki i tak te¿ zrobimy.</P>

	<BR><a href="#a_kurs0502" class="bezdruk">(przeskocz ten program w wersji NASMa)</a>
<PRE title="program wy¶wietlaj±cy czêstotliwo¶æ zegara, wersja NASM">
; NASM:
; z wy¶wietlaniem:
;   nasm -f obj -o fpu1.obj fpu1.asm
;   val fpu1.obj,fpu1.exe,,bibl\lib\bibldos.lib,
; bez wy¶wietlania:
;   nasm -f obj -o fpu1.obj fpu1.asm
;   val fpu1.obj,fpu1.exe,,,

; czê¶ciowa zgodno¶æ z TASMem:
%include &quot;bibl\incl\dosbios\nasm\do_nasma.inc&quot;

; je¶li nie chcesz wy¶wietlania, usuñ tê linijkê ni¿ej:
%include &quot;bibl\incl\dosbios\nasm\std_bibl.inc&quot;

.model small
.stack 400h
.code

..start:
	mov	ax, cs
	mov	ds, ax
	mov	es, ax		; konieczne w programie typu .exe !
				; ¯ycie przestaje byæ
				; wygodne. DOS ju¿ nam nie ustawi DS=ES=CS.
				; A nasze dane s± w
				; segmencie kodu, st±d ustawiamy DS=CS.
				; W programie typu .com to na pewno nie
				; zaszkodzi.

	finit			; zawsze o tym pamiêtaj !

	fild	dword [dzielna]	; ³adujemy dzieln±. st(0) = 1234DD
	fild	dword [dzielnik]; ³adujemy dzielnik. st(0) = 10000h,
				; st(1) = 1234DD
	fdivp	st1, st0	; dzielimy. st(1) := st(1)/st(0) i
				; zdejmij. st(0) ~= 18.2
				; FASM: fdivp st(1)

	fstp	tword [iloraz]	; zapisujemy st(0) do pamiêci i zdejmujemy
				; ze stosu

; je¶li nie chcesz wy¶wietlania, usuñ te 3 linijki ni¿ej:
	mov	di, iloraz
	piszd80			; wy¶wietl wynik
	nwln			; przejd¼ do nowego wiersza

	mov	ax, 4c00h
	int	21h

align 8				; NASM w tym miejscu dorobi kilka NOPów
				; (instrukcji nic nie robi±cych, ale
				; zabieraj±cych czas), aby adres dzieli³ siê
				; przez 8 (patrz dalej).

dzielna		dd 1234ddh	; 4013 91a6 e800 0000 0000
dzielnik	dd 10000h

iloraz		dt 0.0</PRE>

<hr>
<P><a name="a_kurs0502" id="a_kurs0502">Wersja dla FASMa</a>:</P>
	<BR><a href="#a_kurs0503" class="bezdruk">(przeskocz ten sam program w wersji FASMa)</a>

<PRE title="program wy¶wietlaj±cy czêstotliwo¶æ zegara, wersja FASM">
; FASM:
; z wy¶wietlaniem (stary format biblioteki - OMF):
;   fasm fpu1.asm fpu1.obj
;   alink fpu1.obj  bibl\lib\bibldos.lib -c- -entry _start -oEXE -m-
; z wy¶wietlaniem (nowy format biblioteki - COFF):
;   fasm fpu1.asm fpu1.obj
;   ld -s -o fpu1.exe fpu1.obj bibl\lib\bibldos.a
; bez wy¶wietlania:
;   fasm fpu1.asm fpu1.exe

; je¶li chcesz wy¶wietlanie (stary format biblioteki - OMF):
format coff
public _start
public start
include &quot;bibl\incl\dosbios\fasm\std_bibl.inc&quot;
use16

; je¶li chcesz wy¶wietlanie (nowy format biblioteki - COFF):
;format coff
;public _start
;public start
;include &quot;bibl\incl\dosbios\fasm32\std_bibl.inc&quot;

; je¶li nie chcesz wy¶wietlania:
;format MZ
;entry kod:_start
;stack 400h
;segment kod

start:
_start:
	; wy³±czyæ trzy poni¿sze linie w przypadku FASMa z nowym formatem
	; biblioteki (32-bitowy COFF nie pozwala na manipulacjê segmentami)
	mov	ax, cs
	mov	ds, ax
	mov	es, ax		; konieczne w programie typu .exe !
				; ¯ycie przestaje byæ
				; wygodne. DOS ju¿ nam nie ustawi DS=ES=CS.
				; A nasze dane s± w
				; segmencie kodu, st±d ustawiamy DS=CS.
				; W programie typu .com to na pewno nie
				; zaszkodzi.

	finit			; zawsze o tym pamiêtaj !

	fild	dword [dzielna]	; ³adujemy dzieln±. st(0) = 1234DD
	fild	dword [dzielnik]; ³adujemy dzielnik. st(0) = 10000h,
				; st(1) = 1234DD
	fdivp			; dzielimy. st(1) := st(1)/st(0) i
				; zdejmij. st(0) ~= 18.2

	fstp	tword [iloraz]	; zapisujemy st(0) do pamiêci i zdejmujemy
				; ze stosu

; je¶li nie chcesz wy¶wietlania, usuñ te 3 linijki ni¿ej:
	mov	edi, iloraz
	piszd80			; wy¶wietl wynik
	nwln			; przejd¼ do nowego wiersza

	mov	ax, 4c00h
	int	21h

dzielna		dd 1234ddh	; 4013 91a6 e800 0000 0000
dzielnik	dd 10000h

iloraz		dt 0.0</PRE>


<P><a name="a_kurs0503" id="a_kurs0503">Ten przyk³ad do zmiennej</a> <q>iloraz</q> wstawia czêstotliwo¶æ zegara
 komputerowego (ok. 18,2 Hz).
Nale¿y zwróciæ uwagê na zaznaczanie rozmiarów zmiennych (dword/qword/tbyte ptr).</P>
<P>Dyrektywa ALIGN
ustawia kolejn± zmienn±/etykietê tak, ¿e jej adres dzieli siê przez 8 (qword = 8 bajtów). Dziêki
temu, operacje na pamiêci s± szybsze (na przyk³ad dla zmiennej 8-bajtowej zamiast 3 razy pobieraæ po 4 bajty,
bo akurat tak siê zdarzy³o, ¿e mia³a jaki¶ nieparzysty adres, pobiera siê 2x4 bajty). Rzecz jasna, skoro
zmienna <q>dzielna</q> (i <q>dzielnik</q>) ma 4 bajty, to adresy zmiennych
 <q>dzielnik</q> i <q>iloraz</q> te¿ bêd± podzielne przez 4.<BR>
 Ci±g cyfr po ¶redniku to u³amkowa reprezentacja dzielnej. Skomplikowane,
prawda? Dlatego nie chcia³em tego omawiaæ.</P>

<hr>
<P>Przyk³ad 2: czy sinus liczby pi rzeczywi¶cie jest równy 0 (w komputerze)?</P>
	<BR><a href="#a_kurs0504" class="bezdruk">(przeskocz program z sinusem)</a>
<PRE title="program warto¶æ sinusa z liczby pi">
.model tiny
.code
;.386				; odkomentowaæ, je¿eli .387 sprawia problemy
.387

org 100h
start:
	finit			; zawsze o tym pamiêtaj !

	fldpi			; wczytujemy PI
	fsin			; obliczamy sin(PI)
	ftst			; porównujemy st(0) z zerem.
	fstsw ax		; zapisujemy rejestr stanu bezpo¶rednio w AX.
				; Dlatego by³o .387

	sahf			; AH idzie do flag
	mov ah,9		; AH=9, flagi niezmienione
	je jest_zero		; st(0) = 0? Je¶li tak, to wypisz, ¿e jest
	mov dx,offset nie_zero	; zmieniæ DX na EDX, je¿eli sprawia problemy
	jmp short pisz
jest_zero:
	mov dx,offset zero	; DX/EDX jak wy¿ej
pisz:
	int 21h			; wypisz jedn± z wiadomo¶ci.

	mov ax,4c00h
	int 21h

nie_zero	db	&quot;Sin(PI) != 0.$&quot;
zero		db	&quot;Sin(PI) = 0$&quot;

end start</PRE>

<hr>
<P><a name="a_kurs0504" id="a_kurs0504">Wersja dla NASMa i FASMa</a>:</P>
	<BR><a href="#a_kurs0505" class="bezdruk">(przeskocz wersjê NASM/FASM programu z sinusem)</a>

<PRE title="program warto¶æ sinusa z liczby pi, wersja NASM/FASM">
org 100h

start:
	finit			; zawsze o tym pamiêtaj !

	fldpi			; wczytujemy PI
	fsin			; obliczamy sin(PI)
	ftst			; porównujemy st(0) z zerem.
	fstsw ax		; zapisujemy rejestr stanu bezpo¶rednio w AX.
				; Dlatego by³o .387

	sahf			; AH idzie do flag
	mov ah,9		; AH=9, flagi niezmienione
	je jest_zero		; st(0) = 0? Je¶li tak, to wypisz, ¿e jest
	mov dx,nie_zero
	jmp short pisz
jest_zero:
	mov dx,zero
pisz:
	int 21h			; wypisz jedn± z wiadomo¶ci.

	mov ax,4c00h
	int 21h

nie_zero	db	&quot;Sin(PI) != 0$&quot;
zero		db	&quot;Sin(PI) = 0$&quot;</PRE>


<hr>
<P><a name="a_kurs0505" id="a_kurs0505">Przyk³ad 3</a>: czy pierwiastek z 256 rzeczywi¶cie jest równy 16,
 czy 200 jest kwadratem liczby ca³kowitej (komentarze do .386/.387 jak wy¿ej)?</P>
	<BR><a href="#a_kurs0506" class="bezdruk">(przeskocz ten przyk³ad)</a>

<PRE title="program obliczaj±cy pierwiastek z 256 i z 200">
.model tiny
.code
.386
.387

org 100h			; program typu .com

start:
	finit			; zawsze o tym pamiêtaj !

	mov ax,cs
	mov ds,ax		; konieczne w programie typu .exe !
				; ¯ycie przestaje byæ
				; wygodne. DOS ju¿ nam nie ustawi DS=ES=CS.
				; A nasze dane s± w
				; segmencie kodu, st±d ustawiamy DS=CS.

	fild word ptr [dwa_pie_sze]	; st(0) = 256
	fsqrt				; st(0) = sqrt(256)
	fild word ptr [szesnascie]	; st(0) = 16, st(1) = sqrt(256)
	fcompp				; porównaj st(0) i st(1), zdejmij oba
					; st: [pusty]
	fstsw ax
	sahf

	mov ah,9
	je tak256
	mov dx,offset nie_256
	jmp short pisz_256
tak256:
	mov dx,offset tak_256
pisz_256:
	int 21h				; wypisz stosown± wiadomo¶æ

			; do zapisu stanu stosu, czyli rejestrów danych FPU
			; mo¿na u¿ywaæ takiego schematu zapisu,
			; który jest krótszy:
			; st:  (0),  (1),  (2),  ... , (7)

	fild word ptr [dwiescie]	; st: 200
	fsqrt				; st: sqrt(200)
	fld st(0)			; do st(0) wczytaj st(0).
					; st: sqrt(200), sqrt(200)
	frndint				; zaokr±glij do liczby ca³kowitej.
					; st:  (int)sqrt(200), sqrt(200)
	fcompp				; porównaj i zdejmij oba.
	fstsw ax
	sahf

	mov ah,9
	je tak200
	mov dx,offset nie_200
	jmp short pisz_200
tak200:
	mov dx,offset tak_200
pisz_200:
	int 21h				; wypisz stosown± wiadomo¶æ


	mov ax,4c00h
	int 21h

dwa_pie_sze	dw	256
dwiescie	dw	200
szesnascie	dw	16

nie_256	db	&quot;SQRT(256) != 16$&quot;
tak_256	db	&quot;SQRT(256) = 16$&quot;
nie_200	db	&quot;Liczba 200 nie jest kwadratem liczby calkowitej$&quot;
tak_200	db	&quot;Liczba 200 jest kwadratem liczby calkowitej$&quot;
end start</PRE>

<hr>
<P><a name="a_kurs0506" id="a_kurs0506">Teraz dla NASMa i FASMa</a>:</P>
	<BR><a href="#a_kurs0507" class="bezdruk">(przeskocz ten sam przyk³ad w wersji NASM/FASM)</a>

<PRE title="wersja NASM/FASM programu obliczaj±cy pierwiastek z 256 i z 200">
org 100h			; program typu .com

start:
	finit			; zawsze o tym pamiêtaj !

	mov ax,cs
	mov ds,ax		; konieczne w programie typu .exe !
				; ¯ycie przestaje byæ
				; wygodne. DOS ju¿ nam nie ustawi DS=ES=CS.
				; A nasze dane s± w
				; segmencie kodu, st±d ustawiamy DS=CS.
				; W programie typu .com to na pewno nie
				; zaszkodzi.

	fild word  [dwa_pie_sze]	; st(0) = 256
	fsqrt				; st(0) = sqrt(256)
	fild word [szesnascie]	; st(0) = 16, st(1) = sqrt(256)
	fcompp			; porównaj st(0) i st(1) i zdejmij oba
					; st: [pusty]
	fstsw ax
	sahf

	mov ah,9
	je tak256
	mov dx, nie_256
	jmp short pisz_256
tak256:
	mov dx,tak_256
pisz_256:
	int 21h				; wypisz stosown± wiadomo¶æ

			; do zapisu stanu stosu, czyli rejestrów danych FPU
			; mo¿na u¿ywaæ takiego schematu zapisu,
			; który jest krótszy:
			; st:  (0),  (1),  (2),  ... , (7)

	fild word [dwiescie]		; st: 200
	fsqrt				; st: sqrt(200)
	fld st0				; do st(0) wczytaj st(0).
					; st: sqrt(200), sqrt(200)
	frndint				; zaokr±glij do liczby ca³kowitej.
					; st:  (int)sqrt(200), sqrt(200)
	fcompp				; porównaj i zdejmij oba.
	fstsw ax
	sahf

	mov ah,9
	je tak200
	mov dx,nie_200
	jmp short pisz_200
tak200:
	mov dx,tak_200
pisz_200:
	int 21h				; wypisz stosown± wiadomo¶æ


	mov ax,4c00h
	int 21h

dwa_pie_sze	dw	256
dwiescie	dw	200
szesnascie	dw	16

nie_256	db	&quot;SQRT(256) != 16$&quot;
tak_256	db	&quot;SQRT(256) = 16$&quot;
nie_200	db	&quot;Liczba 200 nie jest kwadratem liczby calkowitej$&quot;
tak_200	db	&quot;Liczba 200 jest kwadratem liczby calkowitej$&quot;</PRE>

<P><a name="a_kurs0507" id="a_kurs0507">Dwa ostatnie programiki</a> zbi³em w jeden i przetestowa³em.
 Wysz³o, ¿e sinus PI jest ró¿ny od zera, reszta by³a prawid³owa.</P>

<P>
Oczywi¶cie, w tych przyk³adach nie u¿y³em wszystkich instrukcji koprocesora (nawet spo¶ród tych,
które wymieni³em). Mam jednak nadziejê, ¿e te proste programy rozja¶ni± nieco sposób
pos³ugiwania siê koprocesorem.
</P>





<HR>
<h2 class="nag">Odwrotna Notacja Polska (Reverse Polish Notation, RPN)</h2>

<P>£adnie brzmi, prawda? Ale co to takiego?</P>
<P>Otó¿, bardzo dawno temu pewien polski matematyk, Jan £ukasiewicz,
wymy¶li³ taki sposób zapisywania dzia³añ, ¿e nie trzeba w nim u¿ywaæ nawiasów. By³a to notacja polska.
Sposób ten zosta³ potem dopracowany przez Charlesa Hamblina na potrzeby informatyki - w ten sposób
powsta³a <a href="http://pl.wikipedia.org/wiki/Odwrotna_notacja_polska" hreflang="pl">Odwrotna Notacja
Polska</a>.</P>
<P>W zapisie tym argumenty dzia³ania zapisuje przed symbolem
tego dzia³ania. Dla jasno¶ci podam teraz kilka przyk³adów:</P>

	<BR><a href="#a_kurs0508" class="bezdruk">(przeskocz przyk³ady na ONP)</a>
<PRE title="zamiana zapisu dzia³ania na postaæ ONP">
   Zapis tradycyjny		     ONP
	a+b			a b +
	a+b+c			a b + c +  ; ab+ stanowi pierwszy argument
					   ; drugiego dodawania
	c+b+a			c b + a +
	(a+b)*c			a b + c *
	c*(a+b)			c a b + *
	(a+b)*c+d		a b + c * d +
	(a+b)*c+d*a		a b + c * d a * +
	(a+b)*c+d*(a+c)		a b + c * d a c + * +
	(a+b)*c+(a+c)*d		a b + c * a c + d * +
	(2+5)/7+3/5		2 5 + 7 / 3 5 / +</PRE>

<P><a name="a_kurs0508" id="a_kurs0508">Ale po co to komu i dlaczego</a> mówiê o tym akurat w tej czê¶ci?<BR>
Powód jest prosty: jak siê dobrze przyjrzeæ zapisowi dzia³ania w ONP, to mo¿na zobaczyæ, ¿e mówi
on o kolejno¶ci dzia³añ, jakie nale¿y wykonaæ na koprocesorze. Omówimy to na przyk³adzie:</P>

	<BR><a href="#a_kurs0509" class="bezdruk">(przeskocz ilustracjê relacji miêdzy ONP a koprocesorem)</a>
<PRE title="ilustracja relacji miêdzy ONP a koprocesorem">
	Zapis tradycyjny (jeden z powy¿szych przyk³adów):
		(a+b)*c+(a+c)*d

	Zapis w ONP:
		a b + c * a c + d * +

	Uproszczony kod programu:

	fld	[a]
	fld	[b]
	faddp			; NASM: faddp st1, st0
	fld	[c]
	fmulp			; NASM: fmulp st1, st0
	fld	[a]
	fld	[c]
	faddp			; NASM: faddp st1, st0
	fld	[d]
	fmulp			; NASM: fmulp st1, st0
	faddp			; NASM: faddp st1, st0

	Teraz st0 jest równe warto¶ci ca³ego wyra¿enia.</PRE>

<P><a name="a_kurs0509" id="a_kurs0509">Jak widaæ, ONP znacznie upraszcza</a> przet³umaczenie
wyra¿enia na kod programu. Jednak,
kod nie jest optymalny. Mo¿na by³oby na przyk³ad zachowaæ warto¶ci zmiennych a i c na stosie
i wtedy nie musieliby¶my ci±gle pobieraæ ich z pamiêci. Dlatego w krytycznych sekcjach kodu
stosowanie zasad ONP nie jest zalecane. Ale w wiêkszo¶ci przypadków Odwrotna Notacja Polska
sprawuje siê dobrze i uwalnia programistów od obowi±zku zgadywania kiedy i jakie dzia³anie
wykonaæ.</P>
<P>Pamiêtajcie tylko, ¿e <em class="wazne">stos koprocesora mo¿e pomie¶ciæ tylko 8 liczb</em>!</P>

<P>
Nastêpnym razem o SIMD.
</P>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="a_kurs04.htm">Poprzednia czê¶æ kursu</a> (Alt+3)<BR>
<a accesskey="4" hreflang="pl" href="a_kurs06.htm">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

<BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Napisz program, który sprawdzi (wy¶wietli stosown± informacjê), czy liczba PI dzielona
	przez sam± siebie daje dok³adne 1.0<BR><BR></LI>
 <LI>Napisz program obliczaj±cy (nie wy¶wietlaj±cy) warto¶æ 10*PI.
	Potem sprawd¼, czy sinus tej liczby jest zerem.<BR><BR></LI>
 <LI>Napisz program mówi±cy, która z tych liczb jest wiêksza: PI czy log2(10).<BR><BR></LI>
 <LI>Napisz program sprawdzaj±cy, czy 10*PI - PI - PI - PI - PI - PI = 5*PI.<BR><BR></LI>
 <LI>Zamieñ na ONP:<BR>
	a/c/d + b/c/d<BR>
	a/(c*d) + b/(c*d)<BR>
	(a+b)/c/d<BR>
	(a+b)/(c*d)<BR>
	<BR></LI>
 <LI>Zamieñ z ONP na zapis tradycyjny (daszek ^ oznacza potêgowanie):<BR>
	ab*cd*e/-<BR>
	a5/c7/ed-9/*+<BR>
	a3+b/de+6^-<BR>
	dc-7b*2^/
	</LI>
</OL>

</BODY></HTML>

