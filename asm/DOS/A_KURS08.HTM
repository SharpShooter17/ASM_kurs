<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: DOS, czê¶æ 8 - Zaawansowane programy </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Prev"     hreflang="pl" lang="en" href="a_kurs07.htm">
<link rel="Next"     hreflang="pl" lang="en" href="a_kurs09.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Sun, Jul 10 2016 10:55:48 GMT">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler?<BR>
	<h1 class="nag">Czê¶æ 8 - Zaawansowane programy, czyli zobaczmy,
	 co ten jêzyk naprawdê potrafi</h1></div>

<P>
No có¿, nie jeste¶my ju¿ amatorami i przysz³a pora, aby przyjrzeæ siê temu, w czym asembler
wprost b³yszczy: algorytmy intensywne obliczeniowo. Specjalnie na potrzeby tego kursu
napisa³em nastêpuj±cy programik. Zaprezentujê w nim kilka sztuczek i poka¿ê, do jakich rozmiarów
(tutaj: 2 instrukcje) mo¿na ¶cisn±æ g³ówn± pêtlê programu.<BR>
Oto ten programik:</P>
	<BR><a href="#a_kurs0801" tabindex="1" class="bezdruk">(przeskocz program obliczaj±cy sumê liczb)</a>
<PRE title="program obliczaj±cy sumê liczb od 1 do n">
; Program licz±cy sumê liczb od 1 do liczby wpisanej z klawiatury
;
; Autor: Bogdan D.
;
; kompilacja NASM:
;   nasm -O999 -o ciag_ar.obj -f obj ciag_ar.asm
;   alink ciag_ar.obj  bibl\lib\bibldos.lib -c- -oEXE -m-
; kompilacja FASM (stary format biblioteki - OMF):
;   fasm ciag_ar.asm ciag_ar.obj
;   alink ciag_ar.obj  bibl\lib\bibldos.lib -c- -entry _start -oEXE -m-
; kompilacja FASM (nowy format biblioteki - COFF):
;   fasm ciag_ar.asm ciag_ar.obj
;   ld -s -o ciag_ar.exe ciag_ar.obj bibl\lib\bibldos.a



%include &quot;bibl\incl\dosbios\nasm\std_bibl.inc&quot;
%include &quot;bibl\incl\dosbios\nasm\do_nasma.inc&quot;

.stack 400h

section .text

; FASM (stary format biblioteki - OMF):
; format coff
; include &quot;bibl\incl\dosbios\fasm\std_bibl.inc&quot;
; use16
; public start
; public _start

; FASM (nowy format biblioteki - COFF):
; format coff
; include &quot;bibl\incl\dosbios\fasm32\std_bibl.inc&quot;
; public start
; public _start

start:
_start:
..start:
	pisz
	db	&quot;Program liczy sume liczb od 1 do podanej liczby.&quot;,cr,lf
	db	&quot;Podaj liczbe calkowita: &quot;,0

	we32e		; pobieramy z klawiatury liczbê do rejestru EAX
	jnc	liczba_ok	; flaga CF=1 oznacza b³±d


blad:
	pisz
	db	cr, lf, &quot;Zla liczba!&quot;,0

	wyjscie 1			; mov ax, 4c01h / int 21h

liczba_ok:
	test	eax, eax		; je¶li EAX=0, to te¿ b³±d
	jz	blad

	mov	ebx, eax		; zachowaj liczbê. EBX=n
	xor	edx, edx		; EDX = nasza suma
	mov	ecx, 1

petla:
	add	edx, eax		; dodaj liczbê do sumy
	sub	eax, ecx		; odejmij 1 od liczby
	jnz	petla			; liczba ró¿na od zera?
					; to jeszcze raz dodajemy

	pisz
	db	cr, lf, &quot;Wynik z sumowania 1+2+3+...+n= &quot;,0

	mov	eax, edx		; EAX = wynik
	pisz32e				; wypisz EAX

	mov	eax, ebx		; przywrócenie liczby
	add	eax, 1			; EAX = n+1
	mul	ebx			; EDX:EAX = EAX*EBX = n*(n+1)

	shr	edx, 1
	rcr	eax, 1			; EDX:EAX = EDX:EAX/2

	pisz
	db	cr, lf, &quot;Wynik ze wzoru: n(n+1)/2= &quot;,0

	pisz64		; wypisuje na ekranie 64-bitow± liczbê ca³kowit±
			; z EDX:EAX


	wyjscie 0			; mov ax, 4c00h / int 21h</PRE>

<P><a name="a_kurs0801" id="a_kurs0801">Jak widaæ, nie jest on ogromny</a>, a jednak spe³nia swoje zadanie.
 Teraz przeanalizujemy ten krótki programik:</P>
<UL>
 <LI>Komentarz nag³ówkowy.
  <P>Mówi, co program robi oraz kto jest jego autorem. Mo¿e zawieraæ informacje o wersji programu,
  o niestandardowym sposobie kompilacji/uruchomienia i wiele innych szczegó³ów.</P></LI>

 <LI>pisz, we32e, pisz32e oraz pisz64.
  <P>To s± makra uruchamiaj±ce procedury z mojej biblioteki. U¿ywam ich, bo s± sprawdzone i nie
  muszê ci±gle umieszczaæ kodu tych procedur w programie.</P></LI>

 <LI>Makro <q>wyjscie</q> zawiera w sobie kod wyj¶cia z programu, napisany obok.<BR><BR></LI>

 <LI><CODE>test rej, rej / jz ... / jnz ...</CODE>
   <P>Instrukcja <code>TEST</code> jest szybsza ni¿ <CODE>CMP rej, 0</CODE> i nie zmienia zawarto¶ci rejestru, w
   przeciwieñstwie do <code>OR</code>. Jest to najszybszy sposób na sprawdzenie,
   czy warto¶æ rejestru wynosi 0.
   </P></LI>

 <LI>Pêtla g³ówna.
   <P>Jak widaæ, najpierw do sumy dodajemy n, potem n-1, potem n-2, i na koñcu 1. Umo¿liwi³o to
   znaczne skrócenie kodu pêtli, a wiêc zwiêkszenie jej szybko¶ci. Napisanie <CODE>SUB EAX, ECX</CODE>
   zamiast <CODE>SUB EAX, 1</CODE> skraca rozmiar instrukcji i powoduje jej przyspieszenie,
   gdy¿ dziêki temu w samej pêtli procesor operuje ju¿ tylko na rejestrach.</P></LI>

 <LI><CODE>SHR EDX, 1 / RCR EAX, 1</CODE>
   <P>Wynik musimy podzieliæ przez 2, zgodnie ze wzorem.
   Niestety, nie ma instrukcji <CODE>SHR</CODE> dla 64 bitów. Wiêc trzeba ten brak jako¶ obej¶æ.
   Najpierw, <CODE>SHR EDX, 1</CODE> dzieli EDX przez 2, a bit 0 l±duje we fladze CF. Teraz,
   <CODE>RCR EAX, 1</CODE> (<span lang="en">rotate THROUGH CARRY</span>)
    warto¶æ CF (czyli stary bit 0 EDX) umie¶ci w bicie 31 EAX. I o to chodzi³o!</P></LI>
</UL>

<hr>
<P>Poni¿szy programik te¿ napisa³em dla tego kursu. Ma on pokazaæ z³o¿one sposoby adresowania oraz
instrukcje warunkowego przesuniêcia (<code>CMOV..</code>):</P>
	<BR><a href="#a_kurs0802" class="bezdruk">(przeskocz program z macierz±)</a>

<PRE title="program znajduj±cy najwiêkszy i namniejszy element macierzy">
; Program wczytuje od u¿ytkownika macierz 3x3, po czym znajduje
; element najwiêkszy i najmniejszy
;
; Autor: Bogdan D.
;
; kompilacja:
;   nasm -O999 -o macierze.obj -f obj macierze.asm
;   alink macierze.obj  bibl\lib\bibldos.lib -c- -oEXE -m-
; kompilacja FASM (stary format biblioteki - OMF):
;   fasm macierze.asm macierze.obj
;   alink macierze.obj  bibl\lib\bibldos.lib -c- -entry _start -oEXE -m-
; kompilacja FASM (nowy format biblioteki - COFF):
;   fasm macierze.asm macierze.obj
;   ld -s -o macierze.exe macierze.obj bibl\lib\bibldos.a

%include &quot;bibl\incl\dosbios\nasm\std_bibl.inc&quot;
%include &quot;bibl\incl\dosbios\nasm\do_nasma.inc&quot;

%define rozmiar 3

.stack 400h

section .text

; FASM (stary format biblioteki - OMF):
; format coff
; include &quot;bibl\incl\dosbios\fasm\std_bibl.inc&quot;
; use16
; rozmiar = 3
; public start
; public _start

; FASM (nowy format biblioteki - COFF):
; format coff
; include &quot;bibl\incl\dosbios\fasm32\std_bibl.inc&quot;
; rozmiar = 3
; public start
; public _start

start:
_start:
..start:
	; wy³±czyæ dwie poni¿sze linie w przypadku FASMa z nowym formatem
	; biblioteki (32-bitowy COFF nie pozwala na manipulacjê segmentami)
	mov	ax, cs
	mov	ds, ax	; DS musi byæ = CS, bo inaczej zapisywaliby¶my
			; nie tam, gdzie trzeba, a macierz jest w
			; segmencie kodu.

	pisz
	db	&quot;Prosze podac 9 elementow macierzy,&quot;
	db	cr,lf,&quot; a ja znajde najwiekszy i najmniejszy.&quot;,0

	xor	edx, edx			; ECX = 0
	mov	ebx, macierz

petla_wczyt:
	pisz
	db	cr, lf, &quot;Prosze podac element nr &quot;, 0
	mov	eax, edx
	add	eax, 1
	pisz32e				; wypisz numer elementu

	mov	ax, (0eh &lt;&lt; 8) | &quot;:&quot;		; wypisz dwukropek
; FASM:
;	mov	ax, (0eh shl 8) or &quot;:&quot;

	int	10h
	mov	al, spc			; wypisz spacjê
	int	10h

	we32e				; wczytaj element
	jc	blad
	mov	[ebx+4*edx], eax	; umie¶æ w macierzy

	add	edx, 1			; zwiêksz licznik elementów
					; i równocze¶nie pozycjê w macierzy

	cmp	edx, rozmiar*rozmiar
	jb	petla_wczyt

	jmp	wczyt_gotowe

blad:
	pisz
	db	cr, lf, &quot;Zla liczba!&quot;,0

	wyjscie 1


wczyt_gotowe:
					; EBP = max, EDI = min

	mov	ebp, [ebx]
	mov	edi, [ebx]		; pierwszy element
	mov	edx, 1
	mov	eax, 1
	mov	esi, rozmiar*rozmiar

znajdz_max_min:
	mov	ecx, [ ebx + 4*edx ]
	cmp	ebp, ecx	; EBP &lt; macierz[edx] ?
	cmovb	ebp, ecx	; je¶li tak, to EBP = macierz[edx]

	cmp	edi, ecx	; EDI &gt; macierz[edx] ?
	cmova	edi, ecx	; je¶li tak, to EDI = macierz[edx]

	add	edx, eax
	cmp	edx, esi
	jb	znajdz_max_min

	pisz
	db	cr, lf, &quot;Najwiekszy element: &quot;,0
	mov	eax, ebp
	pisz32e

	pisz
	db	cr, lf, &quot;Najmniejszy element: &quot;,0
	mov	eax, edi
	pisz32e


	wyjscie 0



macierz:	times	rozmiar*rozmiar		dd 0</PRE>

<P><a name="a_kurs0802" id="a_kurs0802">Przypatrzmy siê teraz miejscom</a>, gdzie mo¿na
zw±tpiæ w swoje umiejêtno¶ci:</P>
<UL>
 <LI><CODE>mov	ax, (0eh &lt;&lt; 8) | &quot;:&quot;</CODE>
  <P>Znaki <q>&lt;&lt;</q> odpowiadaj± instrukcji <CODE>SHL</CODE>, a znak <q>|</q>
  	 odpowiada instrukcji <CODE>OR</CODE>. Mamy wiêc: <code>0eh shl 8</code>,
  czyli 0e00h. Robimy <code>OR</code> z dwukropkiem (3ah) i mamy AX=0e3ah. Uruchamiaj±c przerwanie 10h,
  na ekranie otrzymujemy dwukropek.</P></LI>

 <LI><CODE>mov	[ebx+4*edx], eax</CODE>
  <P>EBX = adres macierzy. EDX = 0, 1, 2, ..., rozmiar*rozmiar=9. Elementy macierzy maj± rozmiar po
  4 bajty ka¿dy, st±d EDX mno¿ymy przez 4. Innymi s³owy, pierwszy EAX idzie do [ebx+4*0]=[ebx],
  drugi do [ebx+4] (na 2 miejsce macierzy), trzeci do [ebx+8] itd.</P></LI>

 <LI>Fragment kodu:<BR>
  <PRE>
	mov	ecx, [ ebx + 4*edx ]
	cmp	ebp, ecx	; EBP &lt; macierz[edx] ?
	cmovb	ebp, ecx	; je¶li tak, to EBP = macierz[edx]

	cmp	edi, ecx	; EDI &gt; macierz[edx] ?
	cmova	edi, ecx	; je¶li tak, to EDI = macierz[edx]

	add	edx, eax
	cmp	edx, esi
	jb	znajdz_max_min   </PRE>
  <P>Najpierw, do ECX idzie aktualny element. Potem porównujemy EBX z tym elementem i, gdy EBP &lt; ECX,
  kopiujemy ECX do EBP. Do tego w³a¶nie s³u¿y instrukcja <CODE>CMOVB</CODE>
   (<span lang="en">Conditional MOVe if Below</span>).
  Instrukcje z rodziny <code>(F)CMOV</code> umo¿liwiaj± pozbywanie siê skoków warunkowych,
  które obni¿aj± wydajno¶æ kodu.<BR>
  Podobnie, porównujemy EDI=min z ECX.<BR>
  Potem zwiêkszamy EDX o 1 i sprawdzamy, czy nie przeszli¶my przez ka¿dy element macierzy.
  </P></LI>
</UL>
<P>Powy¿szy program trudno nazwaæ <q>intensywnym obliczeniowo</q>, bo ograniczy³em rozmiar macierzy do
3x3. Ale to by³ tylko przyk³ad. Prawdziwe programy mog± operowaæ na macierzach zawieraj±cych
miliony elementów. Podobny program napisany w HLLu jak C czy Pascal po prostu zaliczy³by siê na
¶mieræ.
</P>
<hr>
<P>Teraz poka¿ê program, który ewoluowa³ od nieoptymalnej formy (zawieraj±cej na przyk³ad wiêcej skoków
warunkowych w g³ównej pêtli oraz inne nieoptymalne instrukcje) do czego¶ takiego:</P>
	<BR><a href="#a_kurs0803" class="bezdruk">(przeskocz program znajduj±cy liczby magiczne)</a>
<PRE title="program znajduj±cy liczby magiczne">
; L_mag.asm
;
; Program wyszukuje liczby, które s± sum± swoich dzielników
;
; Autor: Bogdan D.
; kontakt: bogdandr (at) op (dot) pl
;
; nasm -O999 -o l_mag.com -f bin l_mag.asm
; fasm l_mag.asm l_mag.com


org 100h

start:
	mov	ax,cs
	mov	ebx,1			; liczba pocz±tkowa

	mov	ebp,1
	mov	ds,ax

align 16
start2:
	mov	esi,ebx			; ESI = liczba

	mov	ecx,ebp			; EBP = 1
	shr	esi,1			; zachowanie po³owy liczby

	xor	edi,edi			; suma dzielników=0

align 16
petla:
	xor	edx,edx			; dla dzielenia
	nop
	cmp	ecx,esi			; czy ECX (dzielnik)&gt;liczba/2?
	mov	eax,ebx			; przywrócenie liczby do dzielenia
	nop
	ja	dalej2			; Je¶li ECX &gt; ESI, to koniec
					; dzielenia tej liczby

	nop
	div	ecx			; EAX = EDX:EAX / ECX, EDX=reszta

	nop
	nop
	add	ecx,ebp			; zwiêkszamy dzielnik o 1
	nop

	test	edx,edx			; czy ECX jest dzielnikiem?
					; (czy EDX=reszta=0?)
	nop
	nop
	jnz	petla			; nie? Dzielimy przez nastêpn± liczbê

					; tak?
	lea	edi,[edi+ecx-1]		; dodajemy dzielnik do sumy, nie
					; sprawdzamy na przepe³nienie.
					; ECX-1 bo dodali¶my EBP=1 do
					; ECX po DIV.

	jmp	short petla		; dzielimy przez kolejn± liczbê
	ud2


align 16
dalej2:
	cmp	ebx,edi			; czy to ta liczba?
					; (czy liczba=suma dzielników)
	mov	ah,9
	mov	edx,jest
	jne	nie			; nie

	int	21h			; tak - napis &nbsp;&quot;znaleziono&nbsp;&quot;

	mov	eax,ebx
	call	pl			; wypisujemy liczbê

align 16
nie:
	mov	ah,1
	int	16h
	nop
	jnz	klaw

	cmp	ebx,0ffffffffh		; czy ju¿ koniec zakresu?
	nop
	je	koniec			; tak

	add	ebx,ebp			; nie, zwiêkszamy liczbê badan± o
					; jeden i od pocz±tku
	nop
	jmp	short start2
	ud2


align 16
klaw:
	xor	ah,ah
	int	16h
koniec:
	mov	ah,9
	mov	edx,meta
	nop
	int	21h			; napis &nbsp;&quot;koniec&nbsp;&quot;

	mov	eax,ebx
	call	pl		; wypisujemy ostatni± sprawdzon± liczbê
spr:					; czekamy na klawisz
	mov	ah,1
	nop
	int	16h
	jz	spr

	xor	ah,ah
	int	16h

	mov	ax,4c00h
	int	21h
	ud2

align 16
pc:					; wypisuje cyfrê w AL
	mov	ah,0eh
	push	ebp
	or	al,30h
	int	10h
	pop	ebp
	ret
	ud2

align 16
pl:				; wypisuje liczbê dziesiêciocyfrow± w EAX
	mov	ecx,1000000000
	xor	edx,edx
	div	ecx
	call	pc

	mov	eax,edx
	mov	ecx,100000000
	xor	edx,edx
	div	ecx
	call	pc

	mov	eax,edx
	mov	ecx,10000000
	xor	edx,edx
	div	ecx
	call	pc

	mov	eax,edx
	mov	ecx,1000000
	xor	edx,edx
	div	ecx
	call	pc

	mov	eax,edx
	mov	ecx,100000
	xor	edx,edx
	div	ecx
	call	pc

	mov	eax,edx
	mov	ecx,10000
	xor	edx,edx
	div	ecx
	call	pc

	mov	eax,edx
	xor	edx,edx
	mov	ecx,1000
	div	ecx
	call	pc

	mov	eax,edx
	mov	cl,100
	div	cl
	mov	ch,ah
	call	pc

	mov	al,ch
	xor	ah,ah
	mov	cl,10
	div	cl
	mov	ch,ah
	call	pc

	mov	al,ch
	call	pc
	ret
	ud2

align 4
jest	db	10,13,&quot;Znaleziono: $&quot;
meta	db	10,13,&quot;Koniec. ostatnia liczba: $&quot;</PRE>

<P><a name="a_kurs0803" id="a_kurs0803">A oto analiza</a>:</P>
<UL>
 <LI>Pêtla g³ówna:
	<P>Dziel EBX przez kolejne przypuszczalne dzielniki. Je¶li trafisz na prawdziwy dzielnik
	(reszta=EDX=0), to dodaj go do sumy, która jest w EDI.<BR>
	Unika³em ustawiania obok siebie takich instrukcji, które zale¿± od siebie, jak na przyk³ad
	<CODE>CMP / JA</CODE> czy <CODE>DIV / ADD</CODE>
	</P></LI>

 <LI>Nie za du¿o tych <CODE>NOP</CODE>ów?
	<P>Nie. Zamiast czekaæ na wynik poprzednich instrukcji, procesor zajmuje siê... robieniem
	niczego. Ale jednak siê zajmuje. Wspó³czesne procesory potrafi± wykonywaæ wiele
	niezale¿nych instrukcji praktycznie równolegle. Wiêc w czasie, jak procesor czeka na
	wykonanie poprzednich instrukcji, mo¿e równolegle wykonywaæ NOPy. Zwiêksza to
	przepustowo¶æ, utrzymuje uk³ady dekoduj±ce w ci±g³ej pracy, kolejka instrukcji
	oczekuj±cych na wykonanie nie jest pusta.
	</P></LI>

 <LI>Co robi instrukcja <CODE>lea edi,[edi+ecx-1]</CODE> ?
	<P>LEA - <span lang="en">Load Effective Address</span>. Do rejestru EDI za³aduj
	ADRES (elementu, którego) ADRES
	wynosi EDI+ECX-1. Czyli, w paskalowej sk³adni: EDI := EDI+ECX-1. Do EDI dodajemy
	znaleziony dzielnik. Musimy odj±æ 1, bo wcze¶niej (po dzieleniu) zwiêkszyli¶my ECX o 1.
	</P></LI>

 <LI>Co robi instrukcja <CODE>UD2</CODE> i czemu jest umieszczona po instrukcjach JMP ?
	<P>Ta instrukcja (<span lang="en">UnDefined opcode</span> 2) wywo³uje wyj±tek wykonania nieprawid³owej
	instrukcji przez procesor. Umie¶ci³em j± w takich miejscach, ¿eby nigdy nie by³a
	wykonana.<BR>
	Po co ona w ogóle jest w tym programie w takich miejscach?<BR>
	Ma ona interesuj±c± w³a¶ciwo¶æ: powstrzymuje jednostki dekoduj±ce instrukcje od dalszej
	pracy. Po co dekodowaæ instrukcje, które i tak nie bêd± wykonane (bo by³y po skoku
	bezwarunkowym) ? Strata czasu.
	</P></LI>

 <LI>Po co ci±gle <CODE><span lang="en">align</span> 16</CODE> ?
	<P>Te dyrektywy s± tylko przed etykietami, które s± celem skoku. Ustawianie kodu od
	adresu, który dzieli siê przez 16 mo¿e u³atwiæ procesorowi umieszczenie go w ca³ej jednej
	linii pamiêci podrêcznej (cache). Mniej instrukcji musi byæ pobieranych z pamiêci
	(bo te, które s± najczê¶ciej wykonywane ju¿ s± w cache), wiêc szybko¶æ dekodowania
	wzrasta. Uk³adania kodu i danych zwiêksza ogóln± wydajno¶æ programu
	</P></LI>

</UL>
<hr>
<P>O tych wszystkich sztuczkach, które tu zastosowa³em, mo¿na przeczytaæ w podrêcznikach dotycz±cych
optymalizacji programów, wydanych zarówno przez Intel, jak i AMD (u AMD s± te¿ wymienione
sztuczki, których mo¿na u¿yæ do optymalizacji programów napisanych w jêzyku C).<BR>
Podajê adresy (te same co zwykle):
<A class="amd_link" href="http://developer.amd.com/Resources/documentation/guides/Pages/default.aspx" hreflang="en"><acronym title="Advanced Micro Devices" lang="en">AMD</acronym></A>,
<A class="intel_link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" hreflang="en">Intel</A>.

</P>
<P>¯yczê ciekawej lektury i mi³ej zabawy.</P>

<br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="a_kurs07.htm">Poprzednia czê¶æ kursu</a> (Alt+3)<BR>
<a accesskey="4" hreflang="pl" href="a_kurs09.htm">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

<BR><BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
 <LI>Napisz program obliczaj±cy Najwiêkszy Wspólny Dzielnik i Najmniejsz± Wspóln± Wielokrotno¶æ
	dwóch liczb wiedz±c, ¿e:<BR>
	NWD(a,b) = NWD(b, reszta z dzielenia a przez b) i NWD(n,0)=n (algorytm Euklidesa)<BR>
	NWW(a,b) = a*b / NWD(a,b)
	<BR><BR></LI>
 <LI>Napisz program rozk³adaj±cy dan± liczbê na czynniki pierwsze (liczba mo¿e byæ umieszczona
	w kodzie programu).</LI>
</OL>
</BODY></HTML>
