<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: DOS, czê¶æ 9 - Narzêdzia </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Prev"     hreflang="pl" lang="en" href="a_kurs08.htm">
<link rel="Next"     hreflang="pl" lang="en" href="a_kurs10.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Keywords" CONTENT="kurs, asm, asembler, assembler, debugger, debug,
	Turbo Debugger, CodeView, TRW, Insight, GoBug, OllyDbg, IDE, make">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite">
<meta http-equiv="Last-Modified" content="Sun, Jul 10 2016 10:55:48 GMT">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler?<BR>
	<h1 class="nag">Czê¶æ 9 - Narzêdzia programisty, czyli co mo¿e
	 nam pomagaæ w programowaniu</h1></div>

<BR>
<HR>
<h2 class="nag">Debugery</h2>

	<BR><a href="#ide" tabindex="1" class="bezdruk">(przeskocz debugery)</a>
<P>

Wszystkim siê mo¿e zdarzyæ, ¿e nieustanne, wielogodzinne gapienie siê w kod programu nic nie
daje i program ci±gle nie chce nam dzia³aæ. Wtedy z pomoc± przychodz± debugery. W tej czê¶ci
zaprezentujê kilka wartych uwagi programów tego typu. Nie bêdê szczegó³owo mówi³, jak ich u¿ywaæ, bo
zwykle posiadaj± albo menu, albo dokumentacjê czy inn± pomoc.
</P>
<P>
<em class="wazne">UWAGA:</em> Niektóre debugery mog± wp³ywaæ na warto¶ci widziane w rejestrach. Mo¿e
siê tak staæ na przyk³ad wtedy, gdy przerwanie, które wywo³ujemy, jest wewnêtrznie wykorzystywane przez debuger.
W szczególno¶ci, mo¿e to mieæ miejsce w przypadku <span class="b">Turbo Debuggera</span>
i funkcji <code>3Fh</code> i <code>40h</code> przerwania
<acronym lang="en" title="Disk Operating System">DOS</acronym>-a (<code>int 21h</code>).
</P>

<P>Debuggery programów DOS-owych:</P>
	<BR><a href="#a_kurs0901" class="bezdruk">(przeskocz DOSowe debugery)</a>
<OL>
 <LI><span lang="en">Watcom Debugger</span> (WD).
	<P>Rozpowszechniany z pakietem <a href="http://www.openwatcom.org" hreflang="en" lang="en"
	>OpenWatcom</a>, WD jest najlepszym z darmowych debugerów. Umo¿liwia wy¶wietlanie rejestrów
	procesora, flag, koprocesora, <acronym title="MultiMedia Extension" lang="en">MMX</acronym>
	i <acronym title="Streaming SIMD Extension" lang="en">SSE</acronym>,
	¶ledzenie wartosci zmiennych, stawianie
	pu³apek (<span lang="en">breakpoint</span>, klawisz F9), podgl±d wyj¶cia programu
	(klawisz F4), wykonywanie do kursora i wiele innych dzia³añ. Posiada obs³ugê myszy.
	Pozwala debugowaæ wszystko, co mo¿e byæ wytworzone przez pakiet
	<span lang="en">OpenWatcom</span> - .com, .exe (MZ i LE) i wiele innych.
 	</P></li>

 <LI><span lang="en">Turbo Debugger</span> (TD) firmy Borland.
	<P>Jeden z najlepszych dostêpnych. Niestety, nie darmowy.
	Umo¿liwia wy¶wietlanie rejestrów 16/32-bit, rejestrów
	koprocesora, stosu i pewnych regionów pamiêci (standardowo DS:0000) oraz flag i
	daje mo¿liwo¶æ modyfikacji ich wszystkich. Mo¿na obserwowaæ zmienne oraz to, co siê
	dzieje na ekranie poza debuggerem.
	Gdy testowa³em program dzia³aj±cy w trybie graficznym, to po ka¿dej komendzie monitor
	prze³±cza³ siê w ten tryb, po czym wraca³ do debuggera, co umo¿liwia podgl±danie
	naprawdê ka¿dego kroku. Niestety, zrobienie czegokolwiek poza przej¶ciem do kolejnej
	instrukcji wymaga³o przej¶cia w tryb pe³nego ekranu, gdy¿ okienko w
	<span lang="en">Windows</span> nie za bardzo by³o potem od¶wie¿ane...<BR>
	Niestety, TD nie ma on pojêcia o technologiach takich, jak
	MMX czy SSE (jest po prostu za stary).
	Posiada wiele opcji debugowania: <span lang="en">trace-over, step-into, execute-to,
	 animate</span>, ...<BR>
	Nadaje siê do plików .com/.exe (najnowsza wersja 5.5 obs³uguje tylko pliki 32-bitowe).
	Mo¿na go ¶ci±gn±æ ze stron Borlanda po zarejestrowaniu siê.
	</P></LI>

 <LI>D86.
	<P>Darmowy obs³uguje tylko procesory 16-bitowe (brak rozszerzonych rejestrów), ale mo¿na
	podgl±daæ rejestry, flagi, pamiêæ i koprocesor. D86 jest rozprowadzany razem z A86,
	darmowym kompilatorem jêzyka asembler, i rozpoznaje symbole (nazwy zmiennych itp.),
	które A86 umieszcza w plikach .sym, co u³atwia proces debugowania.<BR>
	Posiada pe³n± dokumentacjê. Pomoc w sprawie klawiszy jest w ka¿dej chwili dostêpna pod
	kombinacj± klawiszy Alt-F10.<BR>
	Niestety, mia³em problem z przegl±daniem aplikacji graficznej: po uruchomieniu trybu
	graficznego nie mog³em wróciæ do ekranu debuggera i musia³em poczekaæ, a¿ program siê
	zakoñczy. D86 zna instrukcje koprocesora.<BR>
	P³atna wersja, D386, zna MMX, SSE i 3DNow!.
	</P></LI>

 <LI><span lang="en">Codeview</span> (CV) firmy <span lang="en">Microsoft</span>.
	<P>Moje do¶wiadczenie z tym debuggerem jest krótkie, gdy¿ nie spe³ni³ on wszystkich moich
	oczekiwañ. Po uruchomieniu od razu trzeba otworzyæ jaki¶ program (i z tego co pamiêtam,
	aby otworzyæ inny program, trzeba wyj¶æ z ca³ego debuggera. Te programy, które
	chcia³em otworzyæ, CV otwiera³ tak d³ugo, ¿e mo¿na by³o pomy¶leæ, ¿e komputer siê
	zawiesi³...<BR>
	Nawet chyba nie jest rozprowadzany osobno, tylko razem z
	<acronym title="Microsoft Macro asembler" lang="en">MASM</acronym>em (za darmo).
	Trzeba przej¶æ d³ugi proces instalacji, ustawiaæ zmienne ¶rodowiska, ...
	</P></LI>

 <LI><span lang="en">Insight</span>
	<P>Natrafi³em na niego, gdy szuka³em czego¶ (nowszego), co mog³o by zast±piæ Turbo
	Debuggera. Wygl±dem nawet przypomina TD, ale ma kilka wad. Pierwsz± jest brak
	rozpoznawania instrukcji koprocesora (wszystkie dekoduje jako ESC + co¶ tam). O MMX
	nie ma co my¶leæ. Drug± wad±, któr± znalaz³em jest to, ¿e po wej¶ciu w tryb graficzny
	okienko <q lang="en">Tryb MS-DOS</q> z debuggerem przestaje siê od¶wie¿aæ i
	trzeba siê prze³±czyæ na pe³ny ekran.<BR>
	Ale jako-tako, dzia³a. Posiada opcje <span lang="en">step-over, trace-into, animate</span>.
	Mo¿na zmieniaæ warto¶ci rejestrów.
	</P></LI>

 <LI><span lang="en">Advanced Fullscreen Debugger</span>
	<P>Nawet ³adne narzêdzie. Pozwala w jednej chwili ogl±daæ kod, stos, rejestry i 2 bloki
	pamiêci (standardowo ustawiane na DS:0000). Obs³uga jest prosta: na dole ekranu jest
	pokazane, co robi± klawisze funkcyjne, ale mo¿na te¿ wpisywaæ komendy. Bardzo pomocne
	jest to, ¿e po wpisaniu pierwszej literki pojawiaj± siê dostêpne komendy zaczynaj±ce siê
	od niej. Niestety, ma te dwa problemy, które ma <span lang="en">Insight</span>: po uruchomieniu trybu
	graficznego okienku z debuggerem przestaje byæ od¶wie¿ane (trzeba siê prze³±czyæ na
	pe³ny ekran) i nie rozpoznaje instrukcji koprocesora.
	</P></LI>

  <LI>TRW2000
	<P>Umie debugowaæ programy typu .com i .exe. Jednak co¶ jest nie tak z obs³ug± myszy a
	praca z nim nie jest zbyt wygodna.
	Strona domowa TRW: <A HREF="http://www.hktk.com/soft/soft_tools/trw_1.html" hreflang="en"
	>www.hktk.com/soft/soft_tools/trw_1.html</A>
	</P></LI>
</OL>

<P>
<a name="a_kurs0901" id="a_kurs0901">Debuggery programów dla <span lang="en">Windows</span></a>:</P>
	<BR><a href="#a_kurs0902" class="bezdruk">(przeskocz <span lang="en">windows</span>owe debuggery)</a>
<OL>
 <LI>GoBug
	<P>Czê¶æ pakietu GoDevTools (<A HREF="http://www.godevtool.com/" hreflang="en">www.godevtool.com</a>).
	Poza nim s± m.in kompilator jêzyka asembler oraz
	<span lang="en">resource compiler</span>.
	 Wszystko to przydaæ siê mo¿e przy pisaniu programów dla <span lang="en">Windows</span>.
	Ja osobi¶cie u¿ywam
	<acronym title="Flat asembler" lang="en">FASM</acronym>a,
	 ale moim debuggerem jest w³a¶nie <span lang="en">GoBug</span>.
	 Ma mi³y dla oka
	wygl±d, zna rejestry
	<acronym title="Floaing-Point Unit" lang="en">FPU</acronym>, MMX.
	 Wy¶wietla kod programu, stan rejestrów, oraz stos
	wzglêdem ESP oraz EBP. Obs³uguje wieloprocesowo¶æ oraz symbole u¿yte w kodzie, o ile
	znajdzie odpowiedni plik z nimi. Po przytrzymaniu prawego klawisza myszki na
	instrukcji pojawiaj± siê bajty zapisane szesnastkowo, które siê na tê instrukcjê
	sk³adaj±.<BR>
	<span lang="en">GoBug</span> rozpoznaje uruchomienia procedur <span lang="en">Windows</span>-owych
	 z bibliotek <acronym title="Dynamic Link Library" lang="en">DLL</acronym>.<BR>
	Dobre narzêdzie.
	</P></LI>

 <LI><span lang="en">Olly Debugger</span>
	<P>Mo¿na go za darmo ¶ci±gn±æ z jego strony domowej: <A HREF="http://ollydbg.de/" hreflang="en"
	>ollydbg.de</A>. Wygl±da bardziej <q>profesjonalnie</q> ni¿ <span lang="en">GoBug</span> i
	podobnie jak on, rozpoznaje uruchomienia procedur systemowych. Stos jest wy¶wietlany
	tylko wzglêdem ESP. Wy¶wietla rejestry i flagi. Stara siê ³±czyæ umieszczanie parametrów
	na stosie z uruchomieniem procedury, ale nie zawsze to wychodzi. Przewijaj±c okienko z
	kodem niektóre instrukcje mog± siê nagle zmieniaæ. Obs³uga jest wed³ug mnie trudniejsza.
	Czcionka instrukcji jest mniejsza, co jeszcze bardziej utrudnia ich rozczytanie.
	Bardziej nie wnika³em w jego obs³ugê.<BR>
	W tej chwili bardziej polecam <span lang="en">GoBug</span> ni¿ <span lang="en">OllyDbg</span>.
	</P></LI>
</OL>


<P>
<a name="a_kurs0902" id="a_kurs0902">Wiem, ¿e nie wszyscy od razu z entuzjazmem</a> rzuc± siê do ¶ci±gania
 i testowania przedstawionych wy¿ej programów i do debugowania w³asnych.<BR>
Niektórzy mog± uwa¿aæ, ¿e
debugger nie jest im potrzebny. Mo¿e i tak byæ, ale nie zawsze i nie u wszystkich. Czasem
(zwykle po d³ugim sterczeniu przed ekranem) przychodzi chêæ do u¿ycia czego¶, co tak
bardzo mo¿e u³atwiæ nam wszystkim ¿ycie.<BR>
Pomy¶lcie, ¿e gdyby nie by³o debuggerów, znajdowanie b³êdów w programie musieliby¶my pozostawiæ
naszej nie zawsze wyæwiczonej wyobra¼ni. Dlatego zachêcam Was do korzystania z programów tego
typu (tylko tych posiadanych legalnie, oczywi¶cie).
</P>





<BR><BR>
<HR>
<h2 class="nag"><a name="ide" id="ide">¦rodowiska programowania</a>, edytory i disasemblery/hex-edytory</h2>

	<BR><a href="#make" class="bezdruk">(przeskocz ten dzia³)</a>

<P>¦rodowisko programowania (<span lang="en">Integrated Development Environment</span>, IDE) to,
 jak wszyscy wiemy,
program, który umo¿liwia edycjê kodu, jego kompilacjê i uruchamianie programu wynikowego.
Znanych jest wiele IDE dla jêzyków wysokiego poziomu, ale jêzyk asembler te¿ ma kilka
swoich:</P>
	<BR><a href="#ide1" class="bezdruk">(przeskocz ¶rodowiska)</a>

<UL>
 <LI>RadASM - <A HREF="http://radasm.visualasembler.com/" hreflang="en"
 	>radasm.visualasembler.com</a> -
 	 ¶rodowisko programistyczne obs³uguj±ce wiele kompilatorów (MASM,
 	 <acronym title="Turbo Assembler">TASM</acronym>,
 	 <acronym title="Netwide asembler" lang="en">NASM</acronym>,
 	 <acronym title="High-Level asembler" lang="en">HLA</acronym>).

  </LI>
 <LI>NasmIDE: <A HREF="http://uk.geocities.com/rob_anderton/" hreflang="en">uk.geocities.com/rob_anderton</a>
   </LI>
 <LI>TasmIDE: <A HREF="http://creamelana.tripod.com/Tasm/TasmIDE.htm" hreflang="en"
 	>creamelana.tripod.com/Tasm/TasmIDE.htm</a>
 <LI>¦rodowisko dla FASMa (wbudowane w kompilator w wersji GUI):
	<A HREF="http://www.flatasembler.net" hreflang="en">flatasembler.net</A>
	oraz Fresh:
	<A HREF="http://fresh.flatasembler.net/" hreflang="en" lang="en">fresh.flatasembler.net</a>
	</LI>

 <LI>WinAsm Studio: <A HREF="http://code4u.net/winasm/" hreflang="en" lang="en">code4u.net/winasm</A></LI>

 <LI>AsmEdit: <A HREF="http://asmedit.massmind.org/" hreflang="en">asmedit.massmind.org</a> (dla MASMa)
	</LI>
</UL>

<P><a name="ide1" id="ide1">Je¶li mimo tego kto¶ nie chce</a> lub nie lubi u¿ywaæ IDE,
 zawsze mo¿e skorzystaæ z którego¶ ze
zwyk³ych edytorów. Przedstawione poni¿ej propozycje to co prawda nie musz± byæ edytorami
napisanymi specjalnie do programowania w asemblerze, ale mo¿e co¶ Wam przypadnie do gustu:</P>

	<BR><a href="#ide2" class="bezdruk">(przeskocz edytory)</a>
<UL>
 <LI><span lang="en">Programmer's File Editor</span>: <A HREF="http://www.movsd.com/tools.htm" hreflang="en"
 	>www.movsd.com/tools.htm</A></LI>
 <LI><span lang="en">Quick Editor</span>: <A HREF="http://www.movsd.com/qed.htm" hreflang="en" lang="en">www.movsd.com/qed.htm</A></LI>
 <LI><span lang="en">The Gun</span>: <A HREF="http://www.movsd.com/thegun.htm" hreflang="en" lang="en">www.movsd.com/thegun.htm</A></LI>
 <LI>HTE: <A HREF="http://hte.sourceforge.net/" hreflang="en">hte.sf.net</A></LI>
</UL>

<P><a name="ide2" id="ide2">Je¶li nie podoba siê Wam ¿aden</a> z wymienionych, to mo¿ecie wej¶æ na stronê
<A HREF="http://www.thefreecountry.com/programming/editors.shtml" hreflang="en"
><span lang="en">The Free Country.com</span> - edytory</A>, gdzie przedstawionych jest
wiele edytorów dla programistów.</P>

<P>
Kolejn± przydatn± rzecz± mo¿e okazaæ siê disasembler lub hex-edytor. Jest to program, który
podobnie jak debugger czyta plik i ewentualnie t³umaczy zawarte w nim bajty na instrukcje asemblera,
jednak bez mo¿liwo¶ci uruchomienia czytanego programu.<BR>
Disasemblery mog± byæ przydatne w wielu sytuacjach, na przyk³ad gdy chcemy modyfikowaæ pojedyncze
bajty po kompilacji programu, zobaczyæ adresy zmiennych, itp.<BR>
Oto kilka przyk³adów programów tego typu:</P>

	<BR><a href="#make" class="bezdruk">(przeskocz hex-edytory)</a>
<UL>
 <LI>XEdit: <A HREF="http://www.ircdb.org" hreflang="en">www.ircdb.org</A></LI>
 <LI>b2hedit: <A HREF="http://www.movsd.com/tools.htm" hreflang="en">www.movsd.com/tools.htm</A></LI>
 <LI>Biew: <A HREF="http://biew.sourceforge.net/en/biew.html" hreflang="en">biew.sf.net</a>
	</LI>
</UL>

<P>I ponownie, je¶li nie spodoba siê Wam ¿aden z wymienionych, to mo¿ecie wej¶æ na stronê
<A HREF="http://www.thefreecountry.com/programming/disasemblers.shtml" hreflang="en"
><span lang="en">The Free Country.com</span> - disasemblery</a>, aby poszukaæ w¶ród pokazanych
tam programów czego¶ dla siebie.</P>






<HR>
<h2 class="nag"><a name="make" id="make">Programy typu <span lang="en">MAKE</span></a></h2>

<P>
Programy typu <span lang="en">MAKE</span> (na przyk³ad GNU MAKE) s³u¿± do automatyzacji budowania du¿ych
 i ma³ych projektów.
Taki program dzia³a do¶æ prosto: uruchamiamy go, a on szuka pliku o nazwie <q lang="en">Makefile</q> w
bie¿±cym katalogu i wykonuje komendy w nim zawarte. Teraz zajmiemy siê omówieniem podstaw
sk³adni pliku <q lang="en">Makefile</q>.</P>
<P>
W pliku takim s± zadania do wykonania. Nazwa zadania zaczyna siê w pierwszej kolumnie, koñczy
dwukropkiem. Po dwukropku s± podane nazwy zadañ (lub plików) , od wykonania których zale¿y wykonanie
tego zadania. W kolejnych wierszach s± komendy s³u¿±ce do wykonania danego zadania.<BR>
<em class="wazne">UWAGA:</em> komendy <em class="wazne">NIE MOG¡</em>
 zaczynaæ siê od pierwszej kolumny!
 Nale¿y je pisaæ je po jednym tabulatorze (ale nie wolno zamiast tabulatora stawiaæ o¶miu spacji).<BR>
Aby wykonaæ dane zadanie, wydajemy komendê <code><span lang="en">make</span> nazwa_zadania</code>.
 Je¶li nie podamy nazwy zadania
(co jest czêsto spotykane), wykonywane jest zadanie o nazwie <q lang="en">all</q> (wszystko).</P>

<P>A teraz krótki przyk³ad:</P>
	<BR><a href="#make1" class="bezdruk">(przeskocz przyk³ad)</a>
<PRE title="prosty Makefile">
all:	kompilacja linkowanie
	echo &quot;Wszystko zakonczone pomyslnie&quot;

kompilacja:
	nasm -O999 -f obj -o plik1.obj plik1.asm
	nasm -O999 -f obj -o plik2.obj plik2.asm
	nasm -O999 -f obj -o plik3.obj plik3.asm

	tasm /z /m plik4.asm
	tasm /z /m plik5.asm
	tasm /z /m plik6.asm

linkowanie: plik1.obj plik2.obj plik3.obj plik4.obj plik5.obj plik6.obj
	alink -o wynik.exe plik1.obj plik2.obj plik3.obj plik4.obj \
		 plik5.obj plik6.obj -c- -oEXE -m-

help:
	echo &quot;Wpisz make bez argumentow&quot;</PRE>

<P><a name="make1" id="make1">Ale <span lang="en">MAKE</span> jest m±drzejszy</a>, ni¿ mo¿e siê to wydawaæ!<BR>
Mianowicie, je¶li stwierdzi, ¿e wynik.exe zosta³ stworzony PÓ¬NIEJ ni¿ pliki .obj podane w
linii zale¿no¶ci, to nie wykona bloku <q>linkowanie</q>, bo nie ma to sensu skoro program wynikowy
i tak jest aktualny. <span lang="en">MAKE</span> robi tylko to, co
trzeba. Oczywi¶cie, niezale¿nie od <q>wieku</q> plików .obj, dzia³ <q>kompilacja</q> i tak zostanie
wykonany (bo nie ma zale¿no¶ci, wiêc <span lang="en">MAKE</span> nie bêdzie sprawdza³ wieku plików).
</P>
<P>Znak odwrotnego uko¶nika <q>\</q> powoduje zrozumienie, ¿e nastêpna linia jest kontynuacj± bie¿±cej,
znak krzy¿yka <q>#</q> powoduje traktowanie reszty linijki jako komentarza.</P>
<P>
Je¶li w czasie wykonywanie któregokolwiek z poleceñ w bloku wyst±pi b³±d (¶ci¶le mówi±c, to
gdy b³±d zwróci wykonywane polecenie, jak u nas TASM czy NASM), to <span lang="en">MAKE</span>
 <em class="wazne">natychmiast przerywa
dzia³anie</em> z informacj± o b³êdzie i nie wykona ¿adnych dalszych poleceñ (pamiêtajcie wiêc
o umieszczeniu w zmiennej ¶rodowiskowej <span lang="en">PATH</span> ¶cie¿ki do kompilatorów).
</P>
<P>
W powy¿szym pliku widaæ jeszcze jedno: zmiana nazwy którego¶ z plików lub jakie¶ opcji sprawi,
¿e trzeba j± bêdzie zmieniaæ wielokrotnie, w wielu miejscach pliku. Bardzo niewygodne w
utrzymaniu, prawda?<BR>
Na szczê¶cie z pomoc± przychodz± nam ... zmienne, które mo¿emy deklarowaæ w <q lang="en">Makefile</q>
 i które zrozumie program <span lang="en">MAKE</span>.<BR>
Sk³adnia deklaracji zmiennej jest wyj±tkowo prosta i wygl±da tak:</P>
<PRE>		NAZWA_ZMIENNEJ = wartosc</PRE>
<P>A u¿ycie:</P>
<PRE>		$(NAZWA_ZMIENNEJ)</PRE>

<P>Polecam nazwy zmiennych pisaæ wielkimi literami w celu odró¿nienia ich od innych elementów. Pole
warto¶ci zmiennej mo¿e zawieraæ dowolny ci±g znaków.</P>
<P>
Je¶li chcemy, aby tre¶æ polecenia NIE pojawia³a siê na ekranie, do nazwy tego polecenia
dopisujemy z przodu znak ma³pki <q>@</q>, na przyk³ad</P>
<PRE>		@echo &quot;Wszystko zakonczone pomyslnie&quot;</PRE>

<P>Uzbrojeni w te informacje, przepisujemy nasz wcze¶niejszy <q lang="en">Makefile</q>:</P>
	<BR><a href="#make2" class="bezdruk">(przeskocz drugi przyk³ad)</a>
<PRE title="bardziej rozbudowany Makefile">
# Mój pierwszy Makefile

NASM	    = nasm     # ale mo¿na tu w przysz³o¶ci wpisaæ pe³n± ¶cie¿kê
NASM_OPCJE  = -O999 -f obj

TASM	    = tasm
TASM_OPCJE  = /z /m

ALINK	    = alink
ALINK_OPCJE = -c- -oEXE -m-

PLIKI_OBJ   = plik1.obj plik2.obj plik3.obj plik4.obj plik5.obj plik6.obj
PROGRAM	    = wynik.exe

all:	kompilacja linkowanie
	@echo &quot;Wszystko zakonczone pomyslnie&quot;

kompilacja:
	$(NASM) $(NASM_OPCJE) -o plik1.obj plik1.asm
	$(NASM) $(NASM_OPCJE) -o plik2.obj plik2.asm
	$(NASM) $(NASM_OPCJE) -o plik3.obj plik3.asm

	$(TASM) $(TASM_OPCJE) plik4.asm
	$(TASM) $(TASM_OPCJE) plik5.asm
	$(TASM) $(TASM_OPCJE) plik6.asm

linkowanie:	$(PLIKI_OBJ)
	$(ALINK) -o $(PROGRAM) $(PLIKI_OBJ) $(ALINK_OPCJE)

help:
	@echo &quot;Wpisz make bez argumentow&quot;</PRE>

<P><a name="make2" id="make2">Oczywi¶cie, w koñcowym <q lang="en">Makefile</q></a> nale¿y
napisaæ takie regu³ki, które pozwol± na ewentualn± kompilacjê pojedynczych plików, na przyk³ad</P>
<PRE title="regu³ki do kompilacji pojedynczych plików">
plik1.obj:	plik1.asm plik1.inc
	$(NASM) $(NASM_OPCJE) -o plik1.obj plik1.asm</PRE>
<P>
Choæ na razie byæ mo¿e niepotrzebna, umiejêtno¶æ pisania plików <q lang="en">Makefile</q>
mo¿e siê przydaæ ju¿
przy projektach zawieraj±cych tylko kilka modu³ów (bo nikt nigdy nie pamiêta, które pliki s±
aktualne, a które nie).<BR>
O tym, ile <q lang="en">Makefile</q> mo¿e zaoszczêdziæ czasu przekona³em siê sam, pisz±c swoj± bibliotekê -
kiedy¶ kompilowa³em ka¿dy modu³ z osobna, teraz wydajê jedno jedyne polecenie <code lang="en">make</code> i
wszystko siê samo robi. <q lang="en">Makefile</q> z biblioteki jest spakowany razem z ni± i mo¿ecie go sobie
zobaczyæ.
</P>

<br>
<div class="bezdruk">
<a accesskey="3" hreflang="pl" href="a_kurs08.htm">Poprzednia czê¶æ kursu</a> (Alt+3)<BR>
<a accesskey="4" hreflang="pl" href="a_kurs10.htm">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>


</BODY></HTML>
