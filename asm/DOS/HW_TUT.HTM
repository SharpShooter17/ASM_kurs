<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: DOS: Wykrywanie sprzêtu </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<META NAME="Author" CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Wykrywanie sprzêtu">
<META NAME="Keywords" CONTENT="asm, assembler, asembler, DOS, sprzêt, hardware, LPT, COM, RAM">
<META NAME="Language" CONTENT="pl">
<META NAME="Generator" CONTENT="KWrite/Kate; www.kate-editor.org">
<meta http-equiv="Last-Modified" content="Sun, Jul 10 2016 10:55:49 GMT">
</HEAD><BODY>

<h1 class="nag">Wykrywanie sprzêtu</h1>

<P>
Niektóre programy nie tylko zajmuj± siê przetwarzaniem danych, ale musz± te¿ wspó³pracowaæ
ze sprzêtem, na przyk³ad wykorzystaæ port szeregowy czy równoleg³y do przesy³ania danych
(czy to na drukarkê, czy do innego urz±dzenia). W tym artykule poka¿ê, jak wykrywaæ
czê¶æ urz±dzeñ zainstalowanych w komputerze. Dobrze mieæ <A
HREF="http://www-2.cs.cmu.edu/afs/cs.cmu.edu/user/ralf/pub/WWW/files.html" hreflang="en"
>spis przerwañ Ralfa <span lang="en">Brown</span>'a</a> pod rêk±.</P>





<BR><HR>
<h2 class="nag">Wykrywanie ilo¶ci zainstalowanej pamiêci <acronym lang="en"
	title="Random Access Memory">RAM</acronym></h2>

	<BR><a href="#hw_tut01" tabindex="1" class="bezdruk">(przeskocz wykrywanie pamiêci)</a>
<P>
<em class="wazne">UWAGA</em>: NIE nale¿y badaæ pamiêci RAM, zapisuj±c do niej
okre¶lone bity pod ka¿dy mo¿liwy adres i sprawdzaj±c, czy uda siê odczytaæ te same bity
(brak pamiêci sygnalizowany jest odczytaniem FF). Czê¶æ urz±dzeñ w komputerze (zw³aszcza PCI)
jest mapowana do pamiêci i zapisywanie do pewnych obszarów jest równoznaczne z zapisywaniem
do tych urz±dzeñ, co mo¿e je powa¿nie uszkodziæ!
</P>
<P>
Do odkrycia zainstalowanej ilo¶ci pamiêci RAM mo¿na skorzystaæ z nastêpuj±cych funkcji
<acronym lang="en" title="Basic Input/Output System">BIOS</acronym>u:
int 15h z EAX=0e820h, int 15h z EAX=0000E820h oraz int 12h (najlepiej w tej kolejno¶ci).
</P>
<P>
Pierwsza z nich korzysta z 32-bitowych rejestrów, wiêc dopiero od procesora 386 mo¿na
sprawdzaæ, czy jest dostêpna. Kolejne uruchomienia tej funkcji zwracaj± informacje o
kolejnych obszarach pamiêci i ich typie, tworz±c tym samym BIOSow± mapê pamiêci.
Ta funkcja przyjmuje nastêpuj±ce argumenty:</P>
<ul>
 <li>EAX = 0000E820h</li>
 <li>EDX = 534D4150h (sta³a)</li>
 <li>ES:DI - adres bufora o nastêpuj±cej strukturze:<br>
  <ul>
   <li>8 bajtów na adres obszaru pamiêci</li>
   <li>8 bajtów na d³ugo¶æ tego obszaru pamiêci</li>
   <li>4 bajty na typ obszaru pamiêci</li>
  </ul></li>
 <li>ECX - d³ugo¶æ bufora spod ES:DI w bajtach (minimum to 20)</li>
 <li>EBX = adres pocz±tkowy, od którego BIOS ma zacz±æ sprawdzanie. Na pocz±tku jest to zero.</li>
</ul>
<P>Je¶li wywo³anie siê powiedzie, funkcja zwraca, co nastêpuje:</P>
<ul>
 <li>flaga CF=0</li>
 <li>wskazany bufor zostaje wype³niony danymi</li>
 <li>EBX = nastêpny adres, sk±d kopiowaæ (podajemy go w EBX jako pocz±tkowy do kolejnego wywo³ania)
  lub 00000000h je¶li koniec</li>
 <li>ECX = d³ugo¶æ zwróconych informacji w bajtach</li>
</ul>
<P>W przypadku niepowodzenia flaga CF=1. Przyk³adowe wywo³anie wygl±da tak:</P>
<pre>
	mov	ax, cs
	mov	es, ax		; je¶li bufor jest w sekcji kodu
	mov	eax, 0e820h
	mov	edx, 534D4150h
	xor	ebx, ebx
	mov	ecx, 20
	mov	di, bufor
	int	15h
	jc	blad

	; tu operujemy na danych

blad:
...

bufor:
b_adres		dd 0, 0
b_dlugosc	dd 0, 0
b_typ		dd 0</pre>

<P>
Druga funkcja nie przyjmuje ¿adnych argumentów (poza numerem funkcji w AX) i zwraca ilo¶æ
pamiêci rozszerzonej od 1 MB do 16 MB, w kilobajtach, w AX. Je¶li wywo³anie siê nie powiedzie,
flaga CF=1. Przyk³adowe wywo³anie wygl±da tak:</P>
<pre>
	mov	ax, 0E801h
	int	15h
	jc	blad

	; tu operujemy na danych

blad:
</pre>

<P>
Trzecia funkcja (przerwanie int 12h) w ogóle nie przyjmuje ¿adnych argumentów,
a zwraca liczbê kilobajtów ci±g³ej pamiêci od bezwzglêdnego adresu 00000h.</P>






<BR><HR>
<h2 class="nag"><a name="hw_tut01" id="hw_tut01">Wykrywanie portów szeregowych
	i równoleg³ych</a></h2>

	<BR><a href="#hw_tut02" class="bezdruk">(przeskocz wykrywanie portów)</a>
<P>
Wykrywanie portów, o których wie BIOS, jest bardzo ³atwe. Wystarczy zajrzeæ do BDA
(<span lang="en">BIOS Data Area</span>), czyli segmentu numer 40h, zawieraj±cego dane BIOSu.<br>
Adresy kolejnych portów szeregowych (maksymalnie czterech) jako 16-bitowe s³owa
mo¿na znale¼æ pod adresami 0040h:0000h, 0040h:0002h, 0040h:0004h, 0040h:0006h (choæ ten
ostatni adres mo¿e s³u¿yæ do innych celów na nowszych komputerach), za¶ adresy
kolejnych portów równoleg³ych (maksymalnie czterech) jako 16-bitowe s³owa znajduj± siê pod
adresami 0040h:0008h, 0040h:000Ah, 0040h:000Ch, 0040h:000Eh.
</P>
<P>
Je¶li dodatkowo chcecie wykryæ rodzaj portu szeregowego, polecam kod darmowego sterownika
myszy dla DOSa - <a href="http://cutemouse.sourceforge.net/"
hreflang="en" lang="en">CuteMouse</a> (a szczególnie plik comtest.asm).
 Sterownik jest napisany w asemblerze i mo¿na
go pobraæ oraz obejrzeæ jego kod ¼ród³owy za darmo.
</P>
<P>
Wykryæ rodzaj portów równoleg³ych mo¿na za pomoc± uk³adów nimi steruj±cych, na przyk³ad
<q lang="en">Intel 82091AA Advanced Integrated Peripheral</q> (porty 22h-23h). Kod dla
tego uk³adu mo¿e wygl±daæ nastêpuj±co:</P>
<pre>
	mov	al, 20h		; numer rejestru, który chcemy odczytaæ
	out	22h, al		; wysy³amy go na port adresu
	out	0edh, al	; opó¼nienie
	in	al, 23h		; odczytujemy dane z portu danych</pre>

<P>Informacje o portach równoleg³ych znajduj± siê w bitach 5 i 6 odczytanego bajtu.
Je¶li bity te maj± warto¶æ 0, to porty równoleg³e pracuj± w trybie zgodno¶ci z ISA,
je¶li 1 - w trybie zgodno¶ci z PS/2, je¶li 2 - w trybie
<acronym lang="en" title="Enhanced Parallel Port">EPP</acronym>, je¶li 3 - w trybie
<acronym lang="en" title="Enhanced Capability Port">ECP</acronym>.</P>






<BR><HR>
<h2 class="nag"><a name="hw_tut02" id="hw_tut02">Wykrywanie karty d¼wiêkowej AdLib</a></h2>

	<BR><a href="#hw_tut03" class="bezdruk">(przeskocz wykrywanie AdLib)</a>
<P>
Karta ta ma dwa podstawowe porty: port adresu i stanu - 388h (do odczytu i zapisu)
oraz port danych - 389h (tylko do zapisu). By zapisaæ co¶ do jednego z 244 rejestru
karty, wysy³amy jego numer na port 388h, po czym wysy³amy dane na port 389h.
Algorytm wykrywania karty sk³ada siê z nastêpuj±cych kroków (¼ród³o:
<cite lang="en">Programming the AdLib/Sound Blaster FM Music Chips, Version 2.0 (24 Feb 1992),
Copyright &copy; 1991, 1992 by Jeffrey S. Lee</cite>):</P>
<ol>
 <li>wyzerowanie obu czasomierzy poprzez zapisanie 60h do rejestru 4.</li>
 <li>w³±czenie przerwañ, zapisuj±c 80h do rejestru 4. UWAGA: to musi byæ krok oddzielny od
 	pierwszego</li>
 <li>odczytanie stanu karty (port 388h) i zachowanie wyniku</li>
 <li>zapisanie FFh do rejestru 2 (czasomierz 1)</li>
 <li>uruchomienie czasomierza 1 poprzez zapisanie 21h do rejestru 4. Czasomierz 1 bêdzie
 	zwiêksza³ warto¶æ zapisan± do rejestru 2 o 1 co ka¿de 80 mikrosekund.</li>
 <li>odczekanie co najmniej 80 mikrosekund</li>
 <li>odczytanie stanu karty (port 388h) i zachowanie wyniku</li>
 <li>wyzerowanie czasomierzy i przerwañ (krok 1 i 2)</li>
 <li>wyniki kroków 3 i 7 ANDowaæ bitowo z warto¶ci± E0h. Wynikiem z kroku 3 powinna byæ warto¶æ
 	0, a z kroku 7 - C0h. Je¶li obie siê zgadzaj±, w komputerze zainstalowana jest
 	karta AdLib.</li>
</ol>
<P>Miêdzy ka¿dym zapisem do portu adresu i wys³aniem danych nale¿y odczekaæ 12 cykli karty.
Po zapisaniu danych nale¿y odczekaæ 84 cykle karty, zanim jakakolwiek kolejna operacja
bêdzie mog³a zostaæ wykonana. Ale ¿e wygodniej jest operowaæ w jêzyku operacji ni¿ cykli
procesora karty, te czasy oczekiwania wynosz± odpowiednio: 6 i 35 razy czas potrzebny na
odczytanie portu adresu. Ja w razie czego u¿yjê odpowiednio: 10 i 40 operacji.</P>
<P>
Do wykrywania karty AdLib mo¿e pos³u¿yæ wiêc nastêpuj±cy kod:</P>
<pre>
	pisz_adlib 4, 60h
	pisz_adlib 4, 80h

	mov	dx, 388h
	in	al, dx
	mov	bl, al		; zachowanie stanu w kroku 3

	pisz_adlib 2, 0FFh
	pisz_adlib 4, 21h

	mov	ah, 86h
	xor	cx, cx
	mov	dx, 100
	int	15h		; wykonanie pauzy na 100 mikrosekund
	jc	blad

	mov	dx, 388h
	in	al, dx
	mov	bh, al		; zachowanie stanu w kroku 7

	pisz_adlib 4, 60h
	pisz_adlib 4, 80h

	and	bx, 0E0E0h
	cmp	bx, 0C000h	; sprawdzenie obu wyników (kroki 3 i 7) na raz
	je	jest_adlib

	; tu nie ma AdLib</pre>

<P>gdzie makro <code>pisz_adlib</code> wygl±da tak:</P>

<pre>
%imacro pisz_adlib 2	; %1 - numer rejestru, %2 - dane do wys³ania
	mov	dx, 388h
	mov	al, %1
	out	dx, al
	mov	cx, 10
%%loop1:		; opó¼nienie pierwsze
	in	al, dx
	loop	%%loop1
	inc	dx	; port 389h
	mov	al, %2
	out	dx, al
	dec	dx
	mov	cx, 40
%%loop2:		; opó¼nienie drugie
	in	al, dx
	loop	%%loop2
%endm</pre>







<BR><HR>
<h2 class="nag"><a name="hw_tut03" id="hw_tut03">Wykrywanie karty d¼wiêkowej
	<span lang="en">SoundBlaster</span></a></h2>

	<BR><a href="#hw_tut04" class="bezdruk">(przeskocz wykrywanie SB)</a>
<P>
Karta SoundBlaster mo¿e byæ zaprogramowana do korzystania z ró¿nych portów podstawowych.
Najczê¶ciej spotykana warto¶æ to 220h, ale mo¿liwe s± te¿ miêdzy innymi 210h, 230h,
240h, 250h, 260h i 280h. Struktura jest podobna, jak w karcie AdLib: zak³adaj±c, ¿e
port bazowy to 220h, to dla lewego kana³u portem adresu jest 220h, a portem danych - 221h,
za¶ dla prawego - odpowiednio 222h i 223h. Porty karty AdLib - 388h i 389h - s³u¿± do operacji na
obu kana³ach.</P>
<P>
Wykrywanie tej karty przebiega tak samo, jak dla karty AdLib (procedura 9 kroków powy¿ej),
ale skoro porty bazowe mog± byæ ró¿ne, proponujê nastêpuj±c± modyfikacjê makra do wysy³ania danych:</P>
<pre>
%imacro pisz_sb 3	; %1 - port bazowy, %2 - numer rejestru, %3 - dane
	mov	dx, %1
	mov	al, %2
	out	dx, al
	mov	cx, 6
%%loop1: 		; opó¼nienie pierwsze
	in	al, dx
	loop	%%loop1
	inc	dx	; port danych
	mov	al, %3
	out	dx, al
	dec	dx
	mov	cx, 35
%%loop2: 		; opó¼nienie drugie
	in	al, dx
	loop	%%loop2

%endm</pre>








<BR><HR>
<h2 class="nag"><a name="hw_tut04" id="hw_tut04">Wykrywanie zainstalowanych dysków twardych</a></h2>

	<BR><a href="#hw_tut05" class="bezdruk">(przeskocz wykrywanie dysków)</a>
<P>
Je¶li BIOS wykryje jakie¶ dyski twarde, ich liczbê wpisuje do komórki pamiêci pod adresem
0040h:007Eh (1 bajt).<br>
Zakresy portów kontrolerów dysków twardych to:
01F0h-01F7h (pierwszy kontroler), 0170h-0177h (drugi). S± jeszcze 2 kontrolery, opisane
jako EIDE: 01E8h-01EFh (trzeci kontroler) i 168h-016Fh (czwarty).
</P>
<P>
Ka¿dy kontroler mo¿e obs³u¿yæ dwa dyski - <span lang="en">Master</span> i <span lang="en">Slave</span>.
Wyboru dysku, na którym wykonywane s± operacje, dokonuje siê, zapisuj±c do portu baza+6 (gdzie baza
to 01F0h, 0170h, 01E8h lub 168h). Bity 7 i 5 musz± byæ równe 1, a bitem czwartym wybiera siê
dysk (0=pierwszy, 1=drugi).</P>
<P>
 Komendy wysy³a siê do portu baza+7, a dane (po 512 bajtów)
odczytuje siê z portu bazowego. Przed wys³aniem komend nale¿y sprawdziæ, czy kontroler lub
dysk nie s± zajête. Robi siê to odczytuj±c port stanu, bêd±cy zarazem portem komend (czyli baza+7).
Bit 7 mówi, czy kontroler jest zajêty (powinien byæ równy zero), bit 6 - czy dysk jest gotowy
do operacji (powinien byæ równy 1), bit 4 - czy dysk przeszed³ na w³a¶ciw± pozycjê (powinien
byæ równy 1). Reszta bitów jest nieistotna, je¶li chodzi o wysy³anie komend.<br>
Portu statusu mo¿na u¿yæ te¿, obok portu baza+1, do wykrywania b³êdów.
</P>
<P>
Mo¿emy ju¿ wiêc napisaæ taki oto kod:</P>
<pre>
	mov	dx, 1f7h
spr_dysk:
	in	al, dx
	cmp	al, 50h		; dysk gotowy, kontroler niezajêty
	jnz	spr_dysk</pre>

<P>Gdy dysk jest gotów na przyjmowanie komend, mo¿na zacz±æ wysy³aæ nasze ¿±dania. Najpierw
ustawiamy, do którego dysku bêdziemy chcieli wysy³aæ dane:</P>

<pre>
	mov	dx, 1f6h
	mov	al, 10100000b	; bit 4 = 0, wiec pierwszy dysk
	out	dx, al</pre>

<P>Po tym, w razie czego, sprawdzamy ponownie gotowo¶æ dysku poprzednim kodem. Je¶li dysk jest
gotów, wysy³amy komendê:</P>

<pre>
	mov	dx, 1f7h
	mov	al, 0ech	; kod rozkazu identyfikacji
	out	dx, al</pre>

<P>Przed odczytaniem danych musimy jednak sprawdziæ nie tylko, czy dysk ju¿ jest gotów (czy
skoñczy³ przetwarzaæ ¿±danie), ale te¿ to, czy dane ju¿ s± gotowe do odebrania. Sprawdzamy to
podobnie, jak poprzednio, zamieniaj±c tylko 50h na 58h (co dodatkowo sprawdza, czy
bufor sektorów dysku wymaga obs³ugi - czyli czy s± ju¿ dla nas dane):</P>

<pre>
	mov	dx, 1f7h
spr_dysk:
	in	al, dx
	cmp	al, 58h		; dysk gotowy, kontroler niezajêty, s± dane
	jnz	spr_dysk</pre>

<P>Po sprawdzeniu, ¿e dane s± dostêpne, odbieramy je, lecz w nietypowy sposób: zamiast
odbieraæ po jednym bajcie, odbieramy pod dwa na raz, do rejestru AX, po czym zamieniamy
jego po³ówki miejscami. Jest to zwi±zane ze sposobem wysy³ania danych przez dysk. Kod wygl±da
tak:</P>

<pre>
	mov	cx, 512/2	; tyle s³ów do przeczytania
	mov	dx, 1f0h	; st±d czytaæ
	xor	di, di		; wska¼nik do bufora
czytaj:
	in	ax, dx		; wczytaj 2 bajty z portu DX
	xchg	al, ah		; zamieñ po³ówki miejscami
	mov	[bufor+di], ax	; zapisz wynik do bufora
	add	di, 2		; przejd¼ na kolejn± pozycjê w buforze
	loop	czytaj
        ...
bufor:		times 513 db 0	; do¶æ, by pomie¶ciæ 1 sektor</pre>

<P>Dysk zwraca nam 512 bajtów. Model dysku znajdziecie pod adresem 14h w buforze, ma
on d³ugo¶æ 10 s³ów (20 bajtów). Numer seryjny jest pod adresem 36h  w buforze, ma
on d³ugo¶æ 20 s³ów (40 bajtów). W obu tych przypadkach, je¶li pierwszym s³owem
pod wskazanym adresem jest zero, to dysk nie poda³ tych informacji.
</P>
<P>
Pozyskanie tych informacji od napêdów optycznych (CD, DVD) ró¿ni siê tylko kodem
operacji - zamiast ECh jest to A1h.</P>







<BR><HR>
<h2 class="nag"><a name="hw_tut05" id="hw_tut05">Wykrywanie napêdów dyskietek</a></h2>

	<BR><a href="#hw_tut06" class="bezdruk">(przeskocz wykrywanie napêdów dyskietek)</a>
<P>
Wykrywanie typów napêdów dyskietek jest znacznie prostsze ni¿ w przypadku dysków twardych.
W czasie uruchamiania komputera, BIOS wyszukuje napêdy dyskietek i wpisuje je do CMOSu,
sk±d mo¿na je ³atwo odczytaæ. Ze te informacje odpowiada bajt numer 10h. Odczytanie go wygl±da
tak:</P>

<pre>
	mov	al, 10h		; numer bajtu do odczytania
	out	70h, al		; port adresu CMOSu
	out	0edh, al	; opó¼nienie
	in	al, 71h		; odczytanie warto¶ci z portu danych CMOSu</pre>

<P>Starsze 4 bity odczytanego bajtu odpowiadaj± pierwszemu napêdowi, m³odsze - drugiemu.
I tak: warto¶æ 0 oznacza brak danego
napêdu,  01h - 5,25 cala 360 kB, 02h - 5,25 cala 1,2 MB, 03h - 3,5 cala 720 kB,
04h - 3,5 cala 1,44 MB, 05h - 3,5 cala 2,88 MB.</P>







<BR><HR>
<h2 class="nag"><a name="hw_tut06" id="hw_tut06">Wykrywanie myszy</a></h2>

	<BR><a href="#hw_tut07" class="bezdruk">(przeskocz wykrywanie myszy)</a>
<P>
Ogólnie wykrywanie myszy jako urz±dzenia mo¿e byæ do¶æ skomplikowane, nie tylko ze
wzglêdu na ró¿norodno¶æ z³±czy (szeregowa, PS/2, <acronym lang="en"
title="Universal Serial Bus">USB</acronym>), ale tak¿e ze wzglêdu na
ró¿norodno¶æ protoko³ów komunikacji z myszami. Wszystko to na szczê¶cie jest
zawarte w otwartym sterowniku myszy dla DOSa - <a href="http://cutemouse.sourceforge.net/"
hreflang="en" lang="en">CuteMouse</a>. Sterownik jest napisany w asemblerze i mo¿na
go pobraæ oraz obejrzeæ jego kod ¼ród³owy za darmo.
</P>
<P>
Je¶li wystarczy Wam wiedzieæ, czy jest za³adowany jakikolwiek sterownik do myszy
(co wskazywa³oby na istnienie myszy), wystarczy taki oto kod:</P>

<pre>
	xor	ax, ax
	mov	es, ax
	les	di, [es:33h &lt;&lt; 2]	; sprawd¼, czy wektor przerwania
					; sterownika myszy nie jest zerem
	mov	ax, es
	or	ax, di
	jz	brak_myszy

	mov	al, [es:di]
	cmp	al, 0cfh		; sprawd¼, czy procedura obs³ugi
					; przerwania myszy nie sk³ada siê
					; wy³±cznie z instrukcji iret
	je	brak_myszy

	xor	ax, ax
	int	33h			; sprawd¼, czy sterownik zg³asza mysz
	test	ax, ax
	jz	brak_myszy</pre>

<br><br>
<div class="bezdruk">
<A accesskey="1" hreflang="pl" href="../index.htm" name="hw_tut07" id="hw_tut07"
	>Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

</BODY></HTML>
