<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<HTML lang="pl">
<HEAD>
<META HTTP-EQUIV="Content-Type"       CONTENT="text/html; charset=ISO-8859-2">
<META HTTP-EQUIV="Content-Language"   CONTENT="pl">
<META http-equiv="Content-Style-Type" content="text/css">
<META HTTP-EQUIV="X-Frame-Options"    CONTENT="DENY">
<LINK rel="stylesheet" href="../asm.css" type="text/css">

<TITLE> Asembler: DOS, czê¶æ 1 - Podstawy </TITLE>
<link rel="Start"    hreflang="pl" lang="en" href="../index.htm">
<link rel="Next"     hreflang="pl" lang="en" href="a_kurs02.htm">
<link rel="Contents" hreflang="pl" lang="en" href="../index.htm">

<META NAME="Author"      CONTENT="Bogdan D.">
<META NAME="Description" CONTENT="Kurs jêzyka asembler">
<META NAME="Language"    CONTENT="pl">
<META NAME="Generator"   CONTENT="KWrite">
<META NAME="Keywords"    CONTENT="kurs, asm, asembler, assembler, rejestry, program, kompilatory,
	system dwójkowy, system szesnastkowy, bit, bajt, binarny, hex, org, nasm, tasm, fasm">
<meta http-equiv="Last-Modified" content="Sun, Jul 10 2016 10:55:47 GMT">
</HEAD><BODY>

<div class="c">Jak pisaæ programy w jêzyku asembler?<BR>
	<h1 class="nag">Czê¶æ 1 - Podstawy, czyli czym to siê je</h1></div>

<P>
Wyobra¼cie sobie, jakby to by³o móc programowaæ maszynê bezpo¶rednio, czyli <q>rozmawiaæ</q> z
procesorem bez po¶rednictwa struktur wysokiego poziomu, na przyk³ad takich jak spotykamy w jêzyku C.
Bezpo¶rednie operowanie na procesorze umo¿liwia przecie¿ pe³n± kontrolê jego dzia³añ! Bez
zbêdnych instrukcji i innych <q>¶mieci</q> spowalniaj±cych nasze programy.
</P>
<P>
Czy ju¿ czujecie chêæ pisania najkrótszych i najszybszych programów na ¶wiecie?<BR>
Programów, których czasem w ogóle NIE MO¯NA napisaæ w innych jêzykach? Brzmi wspaniale, prawda?
</P>
<P>
Tylko pomy¶lcie o tym, co powiedzieliby znajomi, gdyby¶cie siê im pochwalili. Widzicie ju¿ te
ich zdumione miny?
</P>
<P>
Mi³a perspektywa, prawda? No, ale do¶æ ju¿ gadania. Zabierajmy siê do rzeczy!
</P>

<BR>Zacznijmy od krótkiego wprowadzenia:<BR><HR>
<h2 class="nag">Niedziesiêtne systemy liczenia</h2>
  <OL>
   <LI>Dwójkowy (binarny)
	<P>
    Najprostszy dla komputera, gdzie co¶ jest albo w³±czone, albo wy³±czone. System ten operuje na
    liczbach zwanych <span class="b">bitami</span> (bit = <span lang="en">binary digit</span>
     = cyfra dwójkowa).
    Bit przyjmuje jedn± z dwóch warto¶ci: 0 lub 1.<BR>
    Na <span class="b">bajt</span> sk³ada siê 8 bitów. Jednym bajtem mo¿na przedstawiæ wiêc
     2^8=256 mo¿liwo¶ci.</P>
	<P>
    Przeliczenie liczby zapisanej w systemie dwójkowym na dziesiêtny jest proste. Podobnie
	jak w systemie dziesiêtnym, ka¿d± cyfrê mno¿ymy przez odpowiedni± potêgê podstawy
	(podstawa wynosi 2 w systemie dwójkowym, 10 w systemie dziesiêtnym).</P>
	<P>
    Oto przyk³ad (niech daszek ^ oznacza potêgowanie):<BR>
	 1010 1001 dwójkowo =<BR>
	 1*(2^7) + 0*(2^6) + 1*(2^5) + 0*(2^4) + 1*(2^3) + 0*(2^2) + 0*(2^1) + 1*(2^0) = <BR>
	 128 + 32 + 8 + 1 =<BR>
	 169 dziesiêtnie (lub <q>dec</q>, od <q><span lang="en">decimal</span></q>).</P>

    Dzia³anie odwrotne te¿ nie jest trudne: nasz± liczbê dzielimy ci±gle (do chwili
	uzyskania ilorazu równego 0) przez 2, po czym zapisujemy reszty z dzielenia wspak:
	<BR><a href="#a_kurs0101" tabindex="1" class="bezdruk">(przeskocz konwersjê liczby dziesiêtnej na dwójkow±)</a>
 <PRE title="dziesiêtny na binarny" class="asciiart">
	169	|
	 84	| 1
	 42	| 0
	 21	| 0
	 10	| 1
	  5	| 0
	  2	| 1
	  1	| 0
	  0	| 1</PRE>
	  <a name="a_kurs0101" id="a_kurs0101">Wspak dostajemy</a>: 1010 1001, czyli wyj¶ciow± liczbê.
	<BR><BR></LI>




   <LI>Szesnastkowy (heksadecymalny, w skrócie hex)
	<P>
    Jako ¿e system dwójkowy ma mniej cyfr ni¿ dziesiêtny, do przedstawienia wzglêdnie ma³ych
    liczb trzeba u¿yæ du¿o zer i jedynek. Jako ¿e bajt ma 8 bitów, podzielono go na dwie równe,
    czterobitowe czê¶ci. Teraz bajt mo¿na ju¿ reprezentowaæ dwoma znakami, a nie o¶mioma. Na ka¿dy
    taki znak sk³ada siê 2^4=16 mo¿liwo¶ci. St±d wziê³a siê nazwa <q>szesnastkowy</q>.<BR>
    Powsta³ jednak problem: cyfr jest tylko 10, a trzeba mieæ 16. Co zrobiæ?<BR>
    Postanowiono liczbom 10-15 przyporz±dkowaæ odpowiednio znaki A-F.<BR>
    Na przyk³ad<BR>
    Liczba 255 dziesiêtnie = 1111 1111 binarnie = FF szesnastkowo (1111 bin = 15 dec = F hex)<BR>
    Liczba 150 dziesiêtnie = 1001 0110 binarnie = 96 szesnastkowo.
	</P>
	<P>

   Nale¿y zauwa¿yæ ¶cis³y zwi±zek miêdzy systemem dwójkowym i szesnastkowym:
	1 cyfra szesnastkowa to 4 bity, co umo¿liwia b³yskawiczne przeliczanie miêdzy obydwoma
	systemami: wystarczy <q>t³umaczyæ</q> po 4 bity (1 cyfrê hex) na raz i zrobione.
	</P>
	<P>
    Przeliczenie liczby zapisanej w systemie szesnastkowym na dziesiêtny jest równie proste,
	jak t³umaczenie z dwójkowego na dziesiêtny. Ka¿d± cyfrê mno¿ymy przez odpowiedni±
	 potêgê podstawy (podstawa wynosi 16 w systemie szesnastkowym).
	</P>
	<P>
    Oto przyk³ad:<BR>
	 10A szesnastkowo =<BR>
	 1*16^2 + 0*16^1 + A*16^0 =<BR>
	 256 + 0 + 10 =<BR>
	 266 dziesiêtnie.</P>

    Dzia³anie odwrotne te¿ nie jest trudne: nasz± liczbê dzielimy ci±gle (do chwili
	uzyskania ilorazu=0) przez 16, po czym zapisujemy reszty z dzielenia wspak:
	<BR><a href="#a_kurs0102" class="bezdruk">(przeskocz konwersjê liczby dziesiêtnej na szesnastkow±)</a>
 <PRE title="dziesiêtny na szesnastkowy" class="asciiart">
	 266	|
	 16	| 10
	  1	| 0
	  0	| 1</PRE>
	  <a name="a_kurs0102" id="a_kurs0102">Wspak dostajemy kolejno</a>: 1, 0 i 10, czyli 10A, czyli wyj¶ciow± liczbê.<BR><BR>

	Podczas pisania programów, liczby w systemie szesnastkowym oznacza siê przez dodanie
	na koñcu litery <span class="b">h</span> (lub z przodu <span class="b">0x</span>),
	a liczby w systemie dwójkowym - przez dodanie litery <span class="b">b</span>.<BR>
	 Tak wiêc, 101 oznacza dziesiêtn± liczbê o warto¶ci 101, 101b oznacza liczbê 101 w
	systemie dwójkowym (czyli 5 w systemie dziesiêtnym), a 101h lub 0x101 oznacza liczbê
	101 w systemie szesnastkowym (czyli 257 dziesiêtnie).
     </LI></OL>
<BR><HR>
<h2 class="nag">Jêzyk asembler i rejestry procesora</h2>
<P>
 Co to w ogóle jest asembler?</P>
<P>
   Asembler jest to jêzyk programowania, nale¿±cy do jêzyków niskiego poziomu.
   Znaczy to tyle, ¿e jednej komendzie asemblera odpowiada dok³adnie jeden rozkaz procesora.
   Asembler operuje na rejestrach procesora.</P>

<P>   A co to jest rejestr procesora?</P>
<P>
   Rejestr procesora to zespó³ uk³adów elektronicznych, mog±cy przechowywaæ informacje (taka
   w³asna pamiêæ wewnêtrzna procesora).</P>
<P>
   Zaraz podam Wam podstawowe rejestry, na których
   bêdziemy operowaæ. Wiem, ¿e ich liczba mo¿e przeraziæ, ale od razu mówiê, aby¶cie
    <em class="wazne">NIE uczyli
   siê tego wszystkiego na pamiêæ</em>! Najlepiej zrobicie, czytaj±c poni¿sz± listê tylko 2 razy, a
   potem wracali do niej, gdy jakikolwiek rejestr pojawi siê w programach, które
   bêdê pó¼niej prezentowa³ w ramach tego kursu.<BR>

   Oto lista interesuj±cych nas rejestrów:</P>
 <OL>
   <LI> ogólnego u¿ytku:<BR><BR>
    <UL>
     <LI>akumulator:<BR>
     			 RAX (64 bity) = EAX (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EAX (32 bity) = AX (m³odsze 16 bitów) + starsze 16 bitów,<BR>
                     AX = AH (starsze 8 bitów) + AL (m³odsze 8 bitów)<BR>
	Rejestr ten najczê¶ciej s³u¿y do wykonywania dzia³añ matematycznych, ale czêsto w tym
	rejestrze lub jego czê¶ci (AX lub AH) bêdziemy mówiæ systemowi operacyjnemu i
	<acronym lang="en" title="Basic Input/Output System">BIOS</acronym>-owi,
	co od niego chcemy.
	<BR><BR></LI>

     <LI>rejestr bazowy:<BR>
     			 RBX (64 bity) = EBX (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EBX (32 bity) = BX (m³odsze 16 bitów) + starsze 16 bitów,<BR>
                 BX = BH (starsze 8 bitów) + BL (m³odsze 8 bitów)<BR>
	Ten rejestr jest u¿ywany na przyk³ad przy dostêpie do tablic.
	<BR><BR></LI>

     <LI>licznik:<BR>
     			 RCX (64 bity) = ECX (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 ECX (32 bity) = CX (m³odsze 16 bitów) + starsze 16 bitów,<BR>
                  CX = CH (starsze 8 bitów) + CL (m³odsze 8 bitów)<BR>
	Tego rejestru u¿ywamy na przyk³ad do okre¶lania ilo¶ci powtórzeñ pêtli.
	<BR><BR></LI>

     <LI>rejestr danych:<BR>
     			 RDX (64 bity) = EDX (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EDX (32 bity) = DX (m³odsze 16 bitów) + starsze 16 bitów,<BR>
                         DX = DH (starsze 8 bitów) + DL (m³odsze 8 bitów)<BR>
	W tym rejestrze przechowujemy adresy ró¿nych zmiennych. Jak wkrótce zobaczymy, do tego
	rejestru bêdziemy wpisywaæ adres napisu, który bêdziemy chcieli wy¶wietliæ.
	<BR><BR></LI>

     <LI>rejestry dostêpne <span class="b">tylko w trybie 64-bitowym</span>:<BR>
     	<UL>
	 <LI>8 rejestrów 8-bitowych: R8B, R9B, ..., R15B (lub R8L, R9L, ..., R15L)</LI>
	 <LI>8 rejestrów 16-bitowych: R8W, R9W, ..., R15W</LI>
	 <LI>8 rejestrów 32-bitowych: R8D, R9D, ..., R15D</LI>
	 <LI>8 rejestrów 64-bitowych: R8, R9, ..., R15</LI>
	</UL><BR><BR></LI>


     <LI>rejestry indeksowe:
      <UL>
       <LI>indeks ¼ród³owy:<BR>
       			 RSI (64 bity) = ESI (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 ESI (32 bity) = SI (m³odsze 16 bitów) + starsze 16 bitów,<BR>
			 SI (16 bitów) = SIL (m³odsze 8 bitów) + starsze 8 bitów <span class="b">(tylko tryb 64-bit)</span> <BR><BR></LI>
       <LI>indeks docelowy:<BR>
       			 RDI (64 bity) = EDI (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EDI (32 bity) = DI (m³odsze 16 bitów) + starsze 16 bitów,<BR>
			 DI (16 bitów) = DIL (m³odsze 8 bitów) + starsze 8 bitów <span class="b">(tylko tryb 64-bit)</span> </LI>
      </UL>
	Rejestry indeksowe najczê¶ciej s³u¿± do operacji na d³ugich ³añcuchach danych, w tym
	napisach i tablicach.
	<BR><BR></LI>
     <LI>rejestry wska¼nikowe:
      <UL>
       <LI>wska¼nik bazowy:<BR>
       			 RBP (64 bity) = EBP (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EBP (32 bity) = BP (m³odsze 16 bitów) + starsze 16 bitów.<BR>
			 BP (16 bitów) = BPL (m³odsze 8 bitów) + starsze 8 bitów <span class="b">(tylko tryb 64-bit)</span> <BR>
	Najczê¶ciej s³u¿y do dostêpu do zmiennych lokalnych.
	<BR><BR></LI>
       <LI>wska¼nik stosu:<BR>
       			 RSP (64 bity) = ESP (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 ESP (32 bity) = SP (m³odsze 16 bitów) + starsze 16 bitów.<BR>
			 SP (16 bitów) = SPL (m³odsze 8 bitów) + starsze 8 bitów <span class="b">(tylko tryb 64-bit)</span> <BR>
	S³u¿y do dostêpu do stosu (o tym nieco pó¼niej).
	<BR><BR></LI>
       <LI>wska¼nik instrukcji:<BR>
       			 RIP (64 bity) = EIP (m³odsze 32 bity) + starsze 32 bity,<BR>
     			 EIP (32 bity) = IP (m³odsze 16 bitów) + starsze 16 bitów.<BR>
	Mówi procesorowi, sk±d ma pobieraæ instrukcje do wykonywania.
	</LI>
      </UL></LI>
    </UL><BR>
  <LI>rejestry segmentowe (wszystkie 16-bitowe):<BR><BR>
   <UL>
    <LI>segment kodu CS - mówi procesorowi, gdzie znajduj± siê dla niego instrukcje.</LI>
    <LI>segment danych DS - ten najczê¶ciej pokazuje na miejsce, gdzie trzymamy nasze
	zmienne.</LI>
    <LI>segment stosu SS - dziêki niemu wiemy, w którym segmencie jest nasz stos. O tym,
	czym w ogóle jest stos, powiem w nastêpnej czê¶ci.</LI>
    <LI>segment dodatkowy ES - czêsto u¿ywany, gdy chcemy co¶ napisaæ lub narysowaæ na ekranie
	bez pomocy <span lang="en">Windows</span>,
	 <acronym lang="en" title="Disk Operating System">DOS</acronym>a
	 czy nawet BIOSu. </LI>
    <LI>FS i GS (dostêpne dopiero od 80386) - nie maj± specjalnego przeznaczenia. S± tu
	na wypadek, gdyby zabrak³o nam innych rejestrów segmentowych.</LI>
   </UL><BR>
  <LI>rejestr stanu procesora: FLAGI (16-bitowe), E-FLAGI (32-bitowe) lub R-FLAGI (64-bitowe).<BR>
  	 S³u¿± one przede wszystkim do badania
	wyniku ostatniej operacji (na przyk³ad czy nie wyst±pi³o przepe³nienie, czy wynik jest
	zerem, itp.). Najwa¿niejsze flagi to
	 CF (<span lang="en">carry flag</span> - flaga przeniesienia),
	 OF (<span lang="en">overflow flag</span> - flaga przepe³nienia),
	 SF (<span lang="en">sign flag</span> - flaga znaku),
	 ZF (<span lang="en">zero flag</span> - flaga zera),
	 IF (<span lang="en">interrupt flag</span> - flaga przerwañ),
	 PF (<span lang="en">parity flag</span> - flaga parzysto¶ci),
	 DF (<span lang="en">direction flag</span> - flaga kierunku).<BR><BR></LI>
 </OL>
<P>
   U¿ycie litery <q>R</q> przed symbolem rejestru, na przyk³ad RCX, oznacza rejestr 64-bitowy,
   <span class="b">dostêpny tylko na procesorach 64-bitowych</span>.<BR>
   U¿ycie litery <q>E</q> przed symbolem rejestru, na przyk³ad EAX, oznacza rejestr 32-bitowy,
   <span class="b">dostêpny tylko na procesorach rodziny 80386 lub lepszych</span>.
   Nie dotyczy to rejestru ES.</P>

   Napisy <blockquote>RAX = EAX+starsze 32 bity;  EAX=AX + starsze 16 bitów;  AX=AH+AL</blockquote>
    oznaczaj± takie zale¿no¶ci miêdzy tymi rejestrami:
	<BR><a href="#a_kurs0103" class="bezdruk">(przeskocz rozwiniêcie rejestru RAX)</a>
<PRE title="RAX, EAX, AX oraz AH i AL" class="asciiart">
				RAX (64 bity)
				    |               EAX (32b)
   00000000000000000000000000000000 | 0000000000000000 | 00000000 | 00000000
     		  32b	     	    |	     16b       |        AX(16b)
                       		    | 		       |   AH(8b) |   AL(8b)</PRE>
	  <a name="a_kurs0103" id="a_kurs0103">Napisy</a>
    <blockquote>RSI = ESI + starsze 32 bity;  ESI = SI + starsze 16 bitów;
    SI = SIL+starsze 8 bitów</blockquote> oznaczaj±:
	<BR><a href="#a_kurs0104" class="bezdruk">(przeskocz rozwiniêcie rejestru RSI)</a>
<PRE title="RSI, ESI, SI oraz SIL" class="asciiart">
				RSI (64 bity)
				    |               ESI (32b)
   00000000000000000000000000000000 | 0000000000000000 | 00000000 | 00000000
       		  32b	            |	     16b       |        SI(16b)
                       		    |		       |    8b    |  SIL(8b)</PRE>
	<P>
	  <a name="a_kurs0104" id="a_kurs0104">Tak, w DOSie</a>
	 <em class="wazne">mo¿na u¿ywaæ rejestrów 32-bitowych</em> (o ile posiada siê
	80386 lub nowszy). Mo¿na nawet 64-bitowych, je¶li tylko posiada siê w³a¶ciwy procesor.</P>
	<P>
	Jedna wa¿na uwaga - miêdzy nazwami rejestrów mo¿e pojawiæ siê dwukropek w dwóch ró¿nych
	znaczeniach:</P>
	<UL>
	<LI>zapis <q>DX : AX</q> (lub 2 dowolne zwyk³e rejestry) bêdzie oznaczaæ liczbê,
	której starsza czê¶æ znajduje siê w rejestrze po lewej stronie (DX), a m³odsza - w
	tym z prawej (AX). Warto¶æ liczby wynosi DX*65536 + AX.<BR></LI>
	<LI>zapis <q>CS : SI</q> (rejestr segmentowy + dowolny zwyk³y) bêdzie najczê¶ciej oznaczaæ wska¼nik
	do jakiego¶ obiektu w pamiêci (o pamiêci opowiem nastêpnym razem). Rejestr segmentowy
	zawiera oczywi¶cie segment, w którym znajduje siê ów obiekt, a rejestr zwyk³y -
	<span lang="en">offset</span> (przesuniêcie, adres w tym segmencie) tego¿ obiektu.<BR></LI>
	</UL>
	<P>
	Na razie nie musicie siê przejmowaæ tymi dwukropkami. Mówiê to tylko dlatego, ¿eby¶cie
	nie byli zaskoczeni, gdy¿ w przysz³o¶ci siê pojawi±.</P>
	<P>
   Programista mo¿e odnosiæ siê bezpo¶rednio do wszystkich wymienionych rejestrów, z wyj±tkiem
   *IP oraz flag procesora (z wyj±tkami).</P>
	<P>
	Jak widaæ po ich rozmiarach, do rejestrów 8-bitowych mo¿na wpisaæ liczbê z przedzia³u
	0-255 (lub od -128 do 127, gdy najwy¿szy, siódmy bit s³u¿y nam jako bit oznaczaj±cy
	znak liczby), w 16-bitowych zmieszcz± siê liczby 0-65535 (od -32768 do 32767), a w
	32-bitowych - liczby od 0 do 4.294.967.295 (od -2.147.483.648 do 2.147.483.647)
   </P>
   Dobrym, choæ trudnym w odbiorze ¼ród³em informacji s±:
   <cite lang="en">Intel Architecture Software Developer's Manual</cite> (IASDM)
    dostêpny <em class="wazne">ZA DARMO</em> ze
   	<A class="intel_link" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" hreflang="en">stron Intela</A>

   oraz <em class="wazne">DARMOWE</em> podrêczniki <cite lang="en">AMD64 Architecture
   	Programmer's Manual</cite>
 <A class="amd_link" href="http://developer.amd.com/Resources/documentation/guides/Pages/default.aspx" hreflang="en">firmy
	<acronym title="Advanced Micro Devices" lang="en">AMD</acronym></A><BR>

<br><br>


<!-- ###################################################################### -->
<BR><HR>
<h2 class="nag">Pisanie i kompilowanie (asemblowanie) swoich programów</h2>

<P>Jak pisaæ programy w asemblerze?</P>
<P>   Nale¿y zaopatrzyæ siê w:</P>
<UL>

   <LI> Edytor tekstu, mog±cy zapisywaæ pliki formatu TXT (bez formatowania), na przyk³ad
	 <span lang="en">Programmer's File Editor, Quick Editor, The Gun</span> (wszystkie s± na
	<A HREF="http://www.movsd.com/" hreflang="en">www.movsd.com</A>) czy zwyk³y Notatnik</LI>
   <LI> Kompilator jêzyka asembler (patrz dalej)</LI>
   <LI> Odpowiedni program ³±cz±cy (kosolidator, ang. <span class="b" lang="en">linker</span>),
	chyba ¿e kompilator ma ju¿ taki wbudowany, jak na przyk³ad A86, NASM lub FASM (patrz dalej)</LI>
</UL>
 <P>  Wtedy wystarczy napisaæ w edytorze tekstu plik zawieraj±cy komendy procesora (o tym
   pó¼niej), zapisaæ go z rozszerzeniem .ASM, po czym u¿yæ kompilatora, aby
   przetworzyæ program na kod rozumiany przez procesor. </P>


<P>
 Jakiego kompilatora u¿yæ?</P>
<P>
   Istnieje wiele kompilatorów jêzyka asembler. Do najpopularniejszych nale¿±
   <span lang="en">Turbo asembler</span>
   firmy Borland, <span lang="en">Microsoft Macro asembler</span> (MASM),
   <span lang="en">Netwide asembler Project</span> (NASM), A86/A386,
   NBASM, FASM, HLA.</P>
<P>
   Mo¿na je ¶ci±gn±æ z internetu:
	<BR><a href="#a_kurs0104_1" class="bezdruk">(przeskocz adresy stron kompilatorów)</a></P>
<UL>
    <LI>Strona g³ówna NASMa: <A HREF="http://sourceforge.net/projects/nasm" hreflang="en"
    	>sf.net/projects/nasm</A></LI>
    <LI>A86 z <A HREF="http://eji.com" hreflang="en">eji.com</A></LI>
    <LI><span lang="en">Flat asembler</span> (FASM):
    	 <A HREF="http://www.flatasembler.net" hreflang="en">flatasembler.net</A></LI>
    <LI>MASM z <A HREF="http://webster.cs.ucr.edu" hreflang="en">Webster.cs.ucr.edu</A> lub z
	<A HREF="http://www.movsd.com" hreflang="en">www.movsd.com</A> (wersje 32-bitowe)</LI>
    <LI>HLA <A HREF="http://webster.cs.ucr.edu" hreflang="en">Webster.cs.ucr.edu</A>
	</LI>
</UL>
<P>
	<a name="a_kurs0104_1" id="a_kurs0104_1">Po skompilowaniu pliku</a> z kodem ¼ród³owym
	nale¿y u¿yæ programu ³±cz±cego, dostêpnego zwykle z odpowiednim kompilatorem
	(na przyk³ad tlink z tasm, link z masm).
</P>

<!-- ###################################################################### -->
<P>
Mamy wiêc ju¿ wszystko, co potrzeba. Zaczynamy pisaæ. Bêdê tutaj u¿ywa³ sk³adni Turbo
 asemblera zgodnego z MASMem oraz FASMa i NASMa.
</P>
	<BR><a href="#a_kurs0105" class="bezdruk">(przeskocz program w wersji TASM)</a>
<PRE title="wersja TASM">
	; wersja TASM
	.model tiny
	.code
	org 100h

	start:
		mov	ah, 9
		mov	dx, offset info
		int	21h

		mov	ah, 0
		int	16h

		mov	ax, 4C00h
		int	21h

	info	db	&quot;Czesc.$&quot;

	end start</PRE>

<hr>
<P><a name="a_kurs0105" id="a_kurs0105">Teraz wersja NASM:</a></P>
	<BR><a href="#a_kurs0106" class="bezdruk">(przeskocz program w wersji NASM)</a>
<PRE title="wersja NASM">
	; wersja NASM

	; nie ma &quot;.model&quot; ani &quot;.code&quot;
	; tu mo¿na wstawiæ:
	; section .text
	; aby daæ znaæ NASMowi, ¿e to bêdzie w sekcji kodu.
	; Nie jest to jednak wymagane, bo to jest sekcja domy¶lna.

	org 100h

	start:				; nawet tego NASM nie wymaga
		mov	ah, 9
		mov	dx, info	; nie ma s³owa &quot;offset&quot;
		int	21h

		mov	ah, 0
		int	16h

		mov	ax, 4C00h
		int	21h

	info	db	&quot;Czesc.$&quot;

	; nie ma &quot;end start&quot;</PRE>

<hr>
<P><a name="a_kurs0106" id="a_kurs0106">Teraz wersja FASM</a></P>
	<BR><a href="#a_kurs0107" class="bezdruk">(przeskocz program w wersji FASM)</a>
<PRE title="wersja FASM">
	; wersja FASM

	format binary

	; nie ma &quot;.model&quot; ani &quot;.code&quot;
	org 100h

	start:				; nawet tego FASM nie wymaga
		mov	ah, 9
		mov	dx, info	; nie ma s³owa &quot;offset&quot;
		int	21h

		mov	ah, 0
		int	16h

		mov	ax, 4C00h
		int	21h

	info	db	&quot;Czesc.$&quot;

	; nie ma &quot;end start&quot;</PRE>

<hr>
<P><a name="a_kurs0107" id="a_kurs0107">Bez paniki!</a>
 Teraz omówimy dok³adnie, co ka¿da linia robi.</P>
<UL>

 <LI>linie lub napisy zaczynaj±ce siê ¶rednikiem<BR>
	<P>
 	Traktowane s± jako komentarze i s±
	ca³kowicie ignorowane przy kompilacji. Rozmiar skompilowanego programu wynikowego nie zale¿y od ilo¶ci
	komentarzy. Dlatego najlepiej wstawiaæ tyle komentarzy, aby
	inni (równie¿ my) mogli pó¼niej zrozumieæ nasz kod.</P></LI>

 <LI><P><CODE lang="en">.model tiny</CODE> (pamiêtajcie o kropce) lub
 	 <CODE>format <span lang="en">binary</span></CODE> (w FASMie)</P>
     Wskazuje kompilatorowi rodzaj programu. Jest kilka takich dyrektyw:
  <UL>
   <LI><span lang="en">tiny</span>: kod i dane mieszcz± siê w jednym 64kB segmencie. Typowy dla programów typu .com </LI>
   <LI><span lang="en">small</span>: kod i dane s± w ró¿nych segmentach, ale obydwa s± mniejsze od 64kB </LI>
   <LI><span lang="en">medium</span>: kod mo¿e byæ &gt; 64kB, ale dane musz± byæ &lt; 64kB </LI>
   <LI><span lang="en">compact</span>: kod musi byæ &lt; 64kB, dane mog± mieæ wiêcej ni¿ 64kB </LI>
   <LI><span lang="en">large</span>: kod i dane mog± byæ &gt; 64kB, ale tablice musz± byæ &lt; 64kB </LI>
   <LI><span lang="en">huge</span>: kod, dane i tablice mog± byæ &gt; 64kB </LI>
  </UL><BR><BR></LI>

 <LI><CODE lang="en">.code</CODE> (te¿ z kropk±)<BR>
	<P>
     Wskazuje pocz±tek segmentu, gdzie znajduje siê kod programu. Mo¿na jednak w tym segmencie
     umieszczaæ dane, ale nale¿y to robiæ tak, aby nie sta³y siê one czê¶ci± programu. Zwykle
     wpisuje siê je za ostatni± komend± koñcz±c± program. Procesor przecie¿ nie wie, co jest pod
     danym adresem i z mi³± chêci± potraktuje to co¶ jako instrukcjê, co mo¿e prowadziæ do
     przykrych konsekwencji. Swoje dane umieszczajcie tak, aby w ¿aden sposób strumieñ
     wykonywanych instrukcji nie wszed³ na nie.<BR>
     S± te¿ inne dyrektywy: <code>.data</code>, deklaruj±ca pocz±tek segmentu z danymi oraz
      <code lang="en">.stack</code>,
     deklaruj±ca segment stosu (o tym pó¼niej), której nie mo¿na u¿ywaæ w programach typu
     <q>.com</q>, gdzie stos jest automatycznie ustawiany.</P></LI>

 <LI><CODE>org 100h</CODE> (bez kropki)<BR>
	<P>
     Ta linia mówi kompilatorowi, ¿e nasz kod bêdzie (dopiero po uruchomieniu!) znajdowa³ siê
     pod adresem 100h (256 dziesiêtnie) w swoim segmencie. To jest typowe dla programów .com.
     DOS, uruchamiaj±c taki program, szuka wolnego segmentu i kod programu umieszcza dopiero
     pod adresem (czasami zwanym offsetem - przesuniêciem) 100h.<BR>
     Co jest wiêc wcze¶niej? Wiele ciekawych informacji, z których chyba najczê¶ciej u¿ywan± jest
     linia poleceñ programu (parametry uruchomienia, na przyk³ad ró¿ne opcje itd.).<BR>
     Dyrektywa <code>org</code> podana na pocz±tku kodu NIE wp³ywa na rozmiar programu, u³atwia kompilatorowi
     okre¶lenie adresów ró¿nych etykiet (w tym danych) znajduj±cych siê w programie.<BR>
     Je¶li chcemy tworzyæ programy typu .com, nale¿y zawsze podaæ <q>org 100h</q> i opcjê /t dla
     Turbo Linkera.</P></LI>

 <LI><q><CODE>start:</CODE></q> (z dwukropkiem) i <q><CODE>end start</CODE></q> (bez dwukropka)<BR>
	<P>
     Mówi± kompilatorowi, gdzie s± odpowiednio: pocz±tek i koniec programu.</P></LI>

 <LI><CODE>mov ah,9</CODE><BR>
	<P>
     Do 8-bitowego rejestru AH (górnej czê¶ci 16-bitowego AX) wstaw
      (MOV = <span lang="en">move</span>, przesuñ)
      warto¶æ 9. Po co i czemu akurat 9? Zaraz zobaczymy.</P>

     <P>Najpierw powiem o czym¶ innym: komenda <code>MOV</code> ma wa¿ne ograniczenia:</P>
  <OL>
   <LI>nie mo¿na skopiowaæ jedn± komend± <code>MOV</code> komórki pamiêci do innej komórki pamiêci, czyli
      takie co¶:
    <PRE>		mov	[a], [b]</PRE>
      (gdzie a i b - dwie zmienne w pamiêci) jest <span class="b">zabronione</span>.<BR>
      O tym, co oznaczaj± nawiasy kwadratowe, czyli o adresowaniu zmiennych w pamiêci - nastêpnym razem.
	<br><br></LI>

   <LI>nie mo¿na skopiowaæ jedn± komend± <code>MOV</code> jednego rejestru segmentowego (cs, ds, es, ss, fs, gs)
       do innego rejestru segmentowego, czyli dzia³anie
    <PRE>		mov	es, ds</PRE>
      jest <span class="b">zabronione</span>.<br><br></LI>

   <LI>Nie mo¿na do rejestru segmentowego bezpo¶rednio wpisaæ jakie¶ warto¶ci, czyli nie mo¿na
	<PRE>		mov	ds, 0</PRE>
	ale mo¿na:
 <PRE>		mov	bx, 0
		mov	ds, bx</PRE>
   </OL></LI>

 <LI><CODE>mov dx,offset info</CODE><BR>
	<P>
     Do rejestru danych (DX, 16-bitowy) wstaw <span lang="en">offset</span> (adres wzglêdem
     pocz±tku segmentu) etykiety <q>info</q>. Mo¿na obliczaæ adresy nie tylko danych, ale etykiet
     znajduj±cych siê w kodzie programu.</P></LI>

 <LI><CODE>int 21h</CODE><BR>
	<P>
     INT = <span lang="en">interrupt</span> = przerwanie. Nie jest to jednak znane na przyk³ad z
	kart d¼wiêkowych przerwanie typu <acronym lang="en" title="Interrupt Request">IRQ</acronym>.
     Wywo³uj±c przerwanie 21h (33 dziesiêtnie) uruchamiamy jedn± z funkcji DOSa.
     Któr±? O tym zazwyczaj mówi rejestr AX. W
	<A HREF="http://www-2.cs.cmu.edu/afs/cs.cmu.edu/user/ralf/pub/WWW/files.html" hreflang="en"
	>spisie przerwañ Ralfa <span lang="en">Brown</span>'a
	(<acronym lang="en" title="Ralf Brown's Interrupt List">RBIL</acronym>)</A> patrzymy:</P>
	<a href="#a_kurs0108" class="bezdruk">(przeskocz opis int 21h, ah=9)</a>
 <PRE title="int 21h, ah=9" lang="en">		INT 21 - DOS 1+ - WRITE STRING TO STANDARD OUTPUT
		AH = 09h
		DS:DX -> $-terminated string</PRE>
	<P>
     <a name="a_kurs0108" id="a_kurs0108">Ju¿ widzimy</a>, czemu do AH posz³a warto¶æ 9. Chcieli¶my uruchomiæ
	 funkcjê, która wypisuje na
     na ekran ci±g znaków zakoñczony znakiem dolara. Adres tego ci±gu musi siê znajdowaæ w parze
     rejestrów: DS wskazuje segment, w którym znajduje siê ten ci±g, a DX - jego adres w tym
     segmencie. Dlatego by³o <code>mov dx,offset info</code>.</P>
	<P>
     Zaraz, zaraz! Ale przecie¿ my nic nie robili¶my z DS, a dane znajduj± siê przecie¿ w segmencie
     kodu! I to dzia³a?<BR>
     Oczywi¶cie! Programy typu .com s± ma³e. Tak ma³e, ¿e mieszcz± siê w jednym segmencie
	pamiêci.
     Dlatego przy ich uruchamianiu DOS ustawia nam CS=DS=ES=SS. Nie musimy siê wiêc o to martwiæ.
	</P><P>
     Opis podstawowych funkcji kilku przerwañ znajdziecie na jednej z moich podstron,
	po¶wieconej <a href="dos_int.htm" hreflang="pl">najczê¶ciej stosowanym funkcjom przerwañ</a>,
	gdzie znajdziecie tak¿e instrukcje budowania RBIL.<br>
	</P></LI>

 <LI><CODE>mov ah,0</CODE><BR>
	<P>
     Do rejestru AH wpisz 0. Czemu? Zaraz zobaczymy. Ale najpierw wspomnê o czym¶ innym. Otó¿,</P>
     <PRE>		mov	rejestr, 0</PRE>
     <P>nie jest najlepszym sposobem na wyzerowanie danego rejestru. Szybsze lub krótsze s± dwa inne:</P>
     <PRE>
		xor	rej1, rej1 ; 1 xor 1 = 0 oraz 0 xor 0 = 0.
				   ; St±d &nbsp; &quot;co¶ XOR to_samo_co¶&quot;
				   ; zawsze daje 0.

		sub	rej1, rej1	; sub=<span lang="en">subtract</span>=odejmij.
					; rej1 - rej1 = 0</PRE>
     <P>Ja zwykle u¿ywam XOR.</P></LI>

 <LI><CODE>int 16h</CODE><BR>
	<P>
     Kolejne przerwanie, wiêc znowu do listy Ralfa <span lang="en">Brown</span>'a:</P>
	<a href="#a_kurs0109" class="bezdruk">(przeskocz opis int 16h, ah=0)</a>
 <PRE title="int 16h, ah=0" lang="en">		INT 16 - KEYBOARD - GET KEYSTROKE
		AH = 00h
		Return: AH = BIOS scan code
			AL = ASCII character</PRE>
	<P><a name="a_kurs0109" id="a_kurs0109">Ta funkcja pobiera </a>
     znak z klawiatury i zwraca go w rejestrze AL. Je¶li nie naci¶niêto nic,
     poczeka, a¿ u¿ytkownik naci¶nie.</P></LI>

 <LI><CODE>mov ax,4c00h</CODE><BR>
	<P>Do rejestru AX wpisujemy warto¶æ 4c00 szesnastkowo.</P></LI>

 <LI><CODE>int 21h</CODE><BR>
	<P>
     Znów przerwanie DOSa, funkcja 4ch. Patrzymy do RBIL:</P>
	<a href="#a_kurs0110" class="bezdruk">(przeskocz opis int 21h, ah=4ch)</a>
 <PRE title="int 21h, ah=4ch" lang="en">	  INT 21 - DOS 2+ - &quot;EXIT&quot; - TERMINATE WITH RETURN CODE
		AH = 4Ch
		AL = return code
		Return: never returns</PRE>
	  <P><a name="a_kurs0110" id="a_kurs0110">Jak widzimy, ta funkcja</a>
      powoduje wyj¶cie z powrotem do DOSa, z numerem b³êdu (<span lang="en">errorlevel</span>)
     w AL równym 0. Przyjmuje siê, ¿e 0 oznacza, i¿ program zakoñczy³ siê bez b³êdów. Jak widaæ
     po rozmiarze rejestru AL (8 bitów), program mo¿e wyj¶æ z 2^8=256 ró¿nymi
     numerami b³êdu.</P></LI>

 <LI><CODE>info db &quot;Czesc.$&quot;</CODE><BR>
	<P>
     Etykiet± <q>info</q> opisujemy kilka bajtów, w tym przypadku zapisanych jako ci±g znaków.<BR>
     A po co znak dolara $? Jak sobie przypomnimy, funkcja 9. przerwania DOSa wypisuje ci±g znaków zakoñczony
     w³a¶nie na znak dolara $. Gdyby tego znaczka nie by³o, DOS wypisywa³by ró¿ne ¶mieci z pamiêci, a¿ trafi³by na przypadkowy
     znak dolara $ nie wiadomo gdzie. O deklarowaniu zmiennych bêdzie w nastêpnej czê¶ci.</P></LI>

 <LI><CODE>end start</CODE><BR>
	<P>Koniec programu.</P></LI>

</UL>
<P>
Programik kompilujemy poleceniem:</P>
<PRE title="kompilacja TASM">
	tasm naszplik.asm
	tlink naszplik.obj /t</PRE>
<P>(opcja /t - utworzy plik typu .com).<BR>
Je¶li otrzymujecie komunikaty o braku pamiêci, mo¿ecie wypróbowaæ nastêpuj±cy sposób:</P>
<PRE title="kompilacja TASMX">
	tasmx naszplik.asm
	tlink naszplik.obj /t /3</PRE>
<P>Dla NASMa kompilacja wygl±da tak:</P>
<PRE title="kompilacja NASM">	nasm -o naszplik.com -f bin naszplik.asm</PRE>
<P>(-o = nazwa pliku wyj¶ciowego<BR>
  -f = format pliku. Bin = binarny = na przyk³ad COM lub SYS).</P>
<P>A dla FASMa:</P>
<PRE title="kompilacja FASM">	fasm naszplik.asm naszplik.com</PRE>


<P>Kompilacja, nawet programu w asemblerze (zwana czasem asemblacj±), ma kilka etapów:</P>
<ul>
 <li><span lang="en">pre-processing</span> - w tej fazie preprocesor przetwarza dyrektywy takie
	jak definicje sta³ych, do³±czanie innych plików do kodu, rozwiniêcia makr i inne, zanim
	poda program kompilatorowi do kompilacji<br><br></li>
 <li>kompilacja - na tym etapie tworzony jest binarny kod programu wynikowego. Podprogram kompilatora
	sprawdza sk³adniê instrukcji, zmienia je na ich binarne odpowiedniki, przetwarza zmienne na
	ich binarne odpowiedniki, sprawdza, czy wszystkie wykorzystane symbole (na przyk³ad u nas zmienna
	<CODE>info</CODE>) s± zadeklarowane, sprawdza, czy skoki mieszcz± siê w granicach i wykonuje
	inne niezbêdne czynno¶ci, w tym optymalizacjê. Pozostawia jednak adresy symboli
	nieuzupe³nione.<br><br></li>
 <li>linkowanie (konsolidowanie) - na tym etapie nastêpuje sprawdzenie, czy wszystkie
	symbole pozostawione przez kompilator do uzupe³nienia s± dostêpne w samym programie
	lub innych plikach podanych linkerowi do po³±czenia.
	Je¶li wszystkie symbole s± obecne, nastêpuje wstawianie ich adresów do programu wynikowego
	i wygenerowanie samego programu.
	</li>
</ul>
<p>Je¶li do programu nie do³±czamy innych ju¿ skompilowanych plików ani bibliotek, to
niektóre kompilatory nie wymagaj± osobnego linkera i mog± same sobie poradziæ z wygenerowaniem
programu wyj¶ciowego. Widaæ to na przyk³ad w wywo³aniach NASMa i FASMa powy¿ej.</p>

<P>Teraz uruchamiamy naszplik.com i cieszymy siê swoim dzie³em.</P>

<P>Mi³ego eksperymentowania.</P>

<blockquote>Na ¶wiecie jest 10 rodzajów ludzi:<BR>
ci, którzy rozumiej± liczby binarne i ci, którzy nie.</blockquote>

<br><br>
<div class="bezdruk">
<a accesskey="4" hreflang="pl" href="a_kurs02.htm">Kolejna czê¶æ kursu</a> (Alt+4)<br>
<A accesskey="1" hreflang="pl" href="../index.htm">Spis tre¶ci off-<span lang="en">line</span></a> (Alt+1)<BR>
<A accesskey="2" hreflang="pl" href="../index.php">Spis tre¶ci on-<span lang="en">line</span></a> (Alt+2)<br>
<A accesskey="0" hreflang="pl" href="../ulatwie.htm">U³atwienia dla niepe³nosprawnych</a> (Alt+0)<BR>
</div>

<BR><HR>
<h2 class="nag">Æwiczenia</h2>
<OL>
<LI>Poeksperymentujcie sobie, wstawiaj±c z ró¿ne znaki do napisu. Na przyk³ad, znaki o kodach
  ASCII 10 (<span lang="en">Line Feed</span>), 13 (<span lang="en">Carriage Return</span>),
   7 (<span lang="en">Bell</span>). Pamiêtajcie tylko, ¿e znak dolara $ musi byæ
  ostatni, dlatego róbcie co¶ w stylu:
 <PRE>		info db &quot;Czesc.&quot;, 00, 01, 02, 07, 10, 13, 10, 13, &quot;$&quot;</PRE>
 </LI>
</OL>

</BODY></HTML>
